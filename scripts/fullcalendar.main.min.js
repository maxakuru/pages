/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */
const FullCalendar = (function (e) {
  'use strict';

  var t = function (e, n) { return (t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (e, t) { e.__proto__ = t; } || function (e, t) { for (const n in t)t.hasOwnProperty(n) && (e[n] = t[n]); })(e, n); }; function n(e, n) { function r() { this.constructor = e; }t(e, n), e.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r()); } var r = function () { return (r = Object.assign || function (e) { for (var t, n = 1, r = arguments.length; n < r; n++) for (const o in t = arguments[n])Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]); return e; }).apply(this, arguments); }; function o() { for (var e = 0, t = 0, n = arguments.length; t < n; t++)e += arguments[t].length; const r = Array(e); let o = 0; for (t = 0; t < n; t++) for (let i = arguments[t], a = 0, s = i.length; a < s; a++, o++)r[o] = i[a]; return r; } let i; let a; let s; let l; let u; let c; let d; const p = {}; const f = []; const h = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord/i; function v(e, t) { for (const n in t)e[n] = t[n]; return e; } function g(e) { const t = e.parentNode; t && t.removeChild(e); } function m(e, t, n) { let r; const o = arguments; const i = {}; for (r in t)r !== 'key' && r !== 'ref' && (i[r] = t[r]); if (arguments.length > 3) for (n = [n], r = 3; r < arguments.length; r++)n.push(o[r]); if (n != null && (i.children = n), typeof e === 'function' && e.defaultProps != null) for (r in e.defaultProps) void 0 === i[r] && (i[r] = e.defaultProps[r]); return y(e, i, t && t.key, t && t.ref, null); } function y(e, t, n, r, o) {
    const a = {
      type: e, props: t, key: n, ref: r, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, constructor: void 0, __v: o,
    }; return o == null && (a.__v = a), i.vnode && i.vnode(a), a;
  } function E(e) { return e.children; } function S(e, t) { this.props = e, this.context = t; } function D(e, t) { if (t == null) return e.__ ? D(e.__, e.__.__k.indexOf(e) + 1) : null; for (var n; t < e.__k.length; t++) if ((n = e.__k[t]) != null && n.__e != null) return n.__e; return typeof e.type === 'function' ? D(e) : null; } function b(e) { let t; let n; if ((e = e.__) != null && e.__c != null) { for (e.__e = e.__c.base = null, t = 0; t < e.__k.length; t++) if ((n = e.__k[t]) != null && n.__e != null) { e.__e = e.__c.base = n.__e; break; } return b(e); } } function C(e) { (!e.__d && (e.__d = !0) && a.push(e) && !s++ || u !== i.debounceRendering) && ((u = i.debounceRendering) || l)(w); } function w() { for (var e; s = a.length;)e = a.sort(((e, t) => e.__v.__b - t.__v.__b)), a = [], e.some(((e) => { let t; let n; let r; let o; let i; let a; let s; e.__d && (a = (i = (t = e).__v).__e, (s = t.__P) && (n = [], (r = v({}, i)).__v = r, o = _(s, i, r, t.__n, void 0 !== s.ownerSVGElement, null, n, a == null ? D(i) : a), I(n, i), o != a && b(i))); })); } function R(e, t, n, r, o, i, a, s, l) { let u; let c; let d; let h; let v; let m; let y; const E = n && n.__k || f; const S = E.length; if (s == p && (s = i != null ? i[0] : S ? D(n, 0) : null), u = 0, t.__k = T(t.__k, ((n) => { if (n != null) { if (n.__ = t, n.__b = t.__b + 1, (d = E[u]) === null || d && n.key == d.key && n.type === d.type)E[u] = void 0; else for (c = 0; c < S; c++) { if ((d = E[c]) && n.key == d.key && n.type === d.type) { E[c] = void 0; break; }d = null; } if (h = _(e, n, d = d || p, r, o, i, a, s, l), (c = n.ref) && d.ref != c && (y || (y = []), d.ref && y.push(d.ref, null, n), y.push(c, n.__c || h, n)), h != null) { let f; if (m == null && (m = h), void 0 !== n.__d)f = n.__d, n.__d = void 0; else if (i == d || h != s || h.parentNode == null) { e:if (s == null || s.parentNode !== e)e.appendChild(h), f = null; else { for (v = s, c = 0; (v = v.nextSibling) && c < S; c += 2) if (v == h) break e; e.insertBefore(h, s), f = s; }t.type == 'option' && (e.value = ''); }s = void 0 !== f ? f : h.nextSibling, typeof t.type === 'function' && (t.__d = s); } else s && d.__e == s && s.parentNode != e && (s = D(d)); } return u++, n; })), t.__e = m, i != null && typeof t.type !== 'function') for (u = i.length; u--;)i[u] != null && g(i[u]); for (u = S; u--;)E[u] != null && H(E[u], E[u]); if (y) for (u = 0; u < y.length; u++)N(y[u], y[++u], y[++u]); } function T(e, t, n) { if (n == null && (n = []), e == null || typeof e === 'boolean')t && n.push(t(null)); else if (Array.isArray(e)) for (let r = 0; r < e.length; r++)T(e[r], t, n); else n.push(t ? t(typeof e === 'string' || typeof e === 'number' ? y(null, e, null, null, e) : e.__e != null || e.__c != null ? y(e.type, e.props, e.key, null, e.__v) : e) : e); return n; } function k(e, t, n) { t[0] === '-' ? e.setProperty(t, n) : e[t] = typeof n === 'number' && !1 === h.test(t) ? `${n}px` : n == null ? '' : n; } function M(e, t, n, r, o) { let i; let a; let s; let l; let u; if (o ? t === 'className' && (t = 'class') : t === 'class' && (t = 'className'), t === 'style') if (i = e.style, typeof n === 'string')i.cssText = n; else { if (typeof r === 'string' && (i.cssText = '', r = null), r) for (l in r)n && l in n || k(i, l, ''); if (n) for (u in n)r && n[u] === r[u] || k(i, u, n[u]); } else t[0] === 'o' && t[1] === 'n' ? (a = t !== (t = t.replace(/Capture$/, '')), s = t.toLowerCase(), t = (s in e ? s : t).slice(2), n ? (r || e.addEventListener(t, x, a), (e.l || (e.l = {}))[t] = n) : e.removeEventListener(t, x, a)) : t !== 'list' && t !== 'tagName' && t !== 'form' && t !== 'type' && t !== 'size' && !o && t in e ? e[t] = n == null ? '' : n : typeof n !== 'function' && t !== 'dangerouslySetInnerHTML' && (t !== (t = t.replace(/^xlink:?/, '')) ? n == null || !1 === n ? e.removeAttributeNS('http://www.w3.org/1999/xlink', t.toLowerCase()) : e.setAttributeNS('http://www.w3.org/1999/xlink', t.toLowerCase(), n) : n == null || !1 === n && !/^ar/.test(t) ? e.removeAttribute(t) : e.setAttribute(t, n)); } function x(e) { this.l[e.type](i.event ? i.event(e) : e); } function _(e, t, n, r, o, a, s, l, u) { let c; let d; let p; let f; let h; let g; let m; let y; let D; let b; const C = t.type; if (void 0 !== t.constructor) return null; (c = i.__b) && c(t); try { e:if (typeof C === 'function') { if (y = t.props, D = (c = C.contextType) && r[c.__c], b = c ? D ? D.props.value : c.__ : r, n.__c ? m = (d = t.__c = n.__c).__ = d.__E : ('prototype' in C && C.prototype.render ? t.__c = d = new C(y, b) : (t.__c = d = new S(y, b), d.constructor = C, d.render = O), D && D.sub(d), d.props = y, d.state || (d.state = {}), d.context = b, d.__n = r, p = d.__d = !0, d.__h = []), d.__s == null && (d.__s = d.state), C.getDerivedStateFromProps != null && (d.__s == d.state && (d.__s = v({}, d.__s)), v(d.__s, C.getDerivedStateFromProps(y, d.__s))), f = d.props, h = d.state, p)C.getDerivedStateFromProps == null && d.componentWillMount != null && d.componentWillMount(), d.componentDidMount != null && d.__h.push(d.componentDidMount); else { if (C.getDerivedStateFromProps == null && y !== f && d.componentWillReceiveProps != null && d.componentWillReceiveProps(y, b), !d.__e && d.shouldComponentUpdate != null && !1 === d.shouldComponentUpdate(y, d.__s, b) || t.__v === n.__v && !d.__) { for (d.props = y, d.state = d.__s, t.__v !== n.__v && (d.__d = !1), d.__v = t, t.__e = n.__e, t.__k = n.__k, d.__h.length && s.push(d), c = 0; c < t.__k.length; c++)t.__k[c] && (t.__k[c].__ = t); break e; }d.componentWillUpdate != null && d.componentWillUpdate(y, d.__s, b), d.componentDidUpdate != null && d.__h.push((() => { d.componentDidUpdate(f, h, g); })); }d.context = b, d.props = y, d.state = d.__s, (c = i.__r) && c(t), d.__d = !1, d.__v = t, d.__P = e, c = d.render(d.props, d.state, d.context), t.__k = c != null && c.type == E && c.key == null ? c.props.children : Array.isArray(c) ? c : [c], d.getChildContext != null && (r = v(v({}, r), d.getChildContext())), p || d.getSnapshotBeforeUpdate == null || (g = d.getSnapshotBeforeUpdate(f, h)), R(e, t, n, r, o, a, s, l, u), d.base = t.__e, d.__h.length && s.push(d), m && (d.__E = d.__ = null), d.__e = !1; } else a == null && t.__v === n.__v ? (t.__k = n.__k, t.__e = n.__e) : t.__e = P(n.__e, t, n, r, o, a, s, u); (c = i.diffed) && c(t); } catch (e) { t.__v = null, i.__e(e, t, n); } return t.__e; } function I(e, t) { i.__c && i.__c(t, e), e.some(((t) => { try { e = t.__h, t.__h = [], e.some(((e) => { e.call(t); })); } catch (e) { i.__e(e, t.__v); } })); } function P(e, t, n, r, o, i, a, s) { let l; let u; let c; let d; let h; let v = n.props; const g = t.props; if (o = t.type === 'svg' || o, i != null) for (l = 0; l < i.length; l++) if ((u = i[l]) != null && ((t.type === null ? u.nodeType === 3 : u.localName === t.type) || e == u)) { e = u, i[l] = null; break; } if (e == null) { if (t.type === null) return document.createTextNode(g); e = o ? document.createElementNS('http://www.w3.org/2000/svg', t.type) : document.createElement(t.type, g.is && { is: g.is }), i = null, s = !1; } if (t.type === null)v !== g && e.data != g && (e.data = g); else { if (i != null && (i = f.slice.call(e.childNodes)), c = (v = n.props || p).dangerouslySetInnerHTML, d = g.dangerouslySetInnerHTML, !s) { if (v === p) for (v = {}, h = 0; h < e.attributes.length; h++)v[e.attributes[h].name] = e.attributes[h].value; (d || c) && (d && c && d.__html == c.__html || (e.innerHTML = d && d.__html || '')); }(function (e, t, n, r, o) { let i; for (i in n)i === 'children' || i === 'key' || i in t || M(e, i, null, n[i], r); for (i in t)o && typeof t[i] !== 'function' || i === 'children' || i === 'key' || i === 'value' || i === 'checked' || n[i] === t[i] || M(e, i, t[i], n[i], r); }(e, g, v, o, s)), d ? t.__k = [] : (t.__k = t.props.children, R(e, t, n, r, t.type !== 'foreignObject' && o, i, a, p, s)), s || ('value' in g && void 0 !== (l = g.value) && l !== e.value && M(e, 'value', l, v.value, !1), 'checked' in g && void 0 !== (l = g.checked) && l !== e.checked && M(e, 'checked', l, v.checked, !1)); } return e; } function N(e, t, n) { try { typeof e === 'function' ? e(t) : e.current = t; } catch (e) { i.__e(e, n); } } function H(e, t, n) { let r; let o; let a; if (i.unmount && i.unmount(e), (r = e.ref) && (r.current && r.current !== e.__e || N(r, null, t)), n || typeof e.type === 'function' || (n = (o = e.__e) != null), e.__e = e.__d = void 0, (r = e.__c) != null) { if (r.componentWillUnmount) try { r.componentWillUnmount(); } catch (e) { i.__e(e, t); }r.base = r.__P = null; } if (r = e.__k) for (a = 0; a < r.length; a++)r[a] && H(r[a], t, n); o != null && g(o); } function O(e, t, n) { return this.constructor(e, n); } function A(e, t, n) { let r; let o; let a; i.__ && i.__(e, t), o = (r = n === c) ? null : n && n.__k || t.__k, e = m(E, null, [e]), a = [], _(t, (r ? t : n || t).__k = e, o || p, p, void 0 !== t.ownerSVGElement, n && !r ? [n] : o ? null : f.slice.call(t.childNodes), a, n || p, r), I(a, e); }i = { __e(e, t) { for (var n, r; t = t.__;) if ((n = t.__c) && !n.__) try { if (n.constructor && n.constructor.getDerivedStateFromError != null && (r = !0, n.setState(n.constructor.getDerivedStateFromError(e))), n.componentDidCatch != null && (r = !0, n.componentDidCatch(e)), r) return C(n.__E = n); } catch (t) { e = t; } throw e; } }, S.prototype.setState = function (e, t) { let n; n = this.__s !== this.state ? this.__s : this.__s = v({}, this.state), typeof e === 'function' && (e = e(n, this.props)), e && v(n, e), e != null && this.__v && (t && this.__h.push(t), C(this)); }, S.prototype.forceUpdate = function (e) { this.__v && (this.__e = !0, e && this.__h.push(e), C(this)); }, S.prototype.render = E, a = [], s = 0, l = typeof Promise === 'function' ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, c = p, d = 0, (typeof globalThis !== 'undefined' ? globalThis : window).FullCalendarVDom = {
    Component: S,
    createElement: m,
    render: A,
    createRef() { return {}; },
    Fragment: E,
    createContext(e) {
      const t = (function (e) {
        const t = {}; var n = {
          __c: `__cC${d++}`, __: e, Consumer(e, t) { return e.children(t); }, Provider(e) { let r; const o = this; return this.getChildContext || (r = [], this.getChildContext = function () { return t[n.__c] = o, t; }, this.shouldComponentUpdate = function (e) { o.props.value !== e.value && r.some(((t) => { t.context = e.value, C(t); })); }, this.sub = function (e) { r.push(e); const t = e.componentWillUnmount; e.componentWillUnmount = function () { r.splice(r.indexOf(e), 1), t && t.call(e); }; }), e.children; },
        }; return n.Consumer.contextType = n, n.Provider.__ = n, n;
      }(e)); const n = t.Provider; return t.Provider = function () { const e = this; const t = !this.getChildContext; const r = n.apply(this, arguments); if (t) { const o = []; this.shouldComponentUpdate = function (t) { e.props.value !== t.value && o.some(((e) => { e.context = t.value, e.forceUpdate(); })); }, this.sub = function (e) { o.push(e); const t = e.componentWillUnmount; e.componentWillUnmount = function () { o.splice(o.indexOf(e), 1), t && t.call(e); }; }; } return r; }, t;
    },
    flushToDom() { const e = i.debounceRendering; const t = []; i.debounceRendering = function (e) { t.push(e); }, A(m(U, {}), document.createElement('div')); for (;t.length;)t.shift()(); i.debounceRendering = e; },
  }; var U = (function (e) { function t() { return e !== null && e.apply(this, arguments) || this; } return n(t, e), t.prototype.render = function () { return m('div', {}); }, t.prototype.componentDidMount = function () { this.setState({}); }, t; }(S)); const L = (function () { function e(e, t) { this.context = e, this.internalEventSource = t; } return e.prototype.remove = function () { this.context.dispatch({ type: 'REMOVE_EVENT_SOURCE', sourceId: this.internalEventSource.sourceId }); }, e.prototype.refetch = function () { this.context.dispatch({ type: 'FETCH_EVENT_SOURCES', sourceIds: [this.internalEventSource.sourceId] }); }, Object.defineProperty(e.prototype, 'id', { get() { return this.internalEventSource.publicId; }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, 'url', { get() { return this.internalEventSource.meta.url; }, enumerable: !1, configurable: !0 }), e; }()); function W(e) { e.parentNode && e.parentNode.removeChild(e); } function V(e, t) { if (e.closest) return e.closest(t); if (!document.documentElement.contains(e)) return null; do { if (z(e, t)) return e; e = e.parentElement || e.parentNode; } while (e !== null && e.nodeType === 1); return null; } function z(e, t) { return (e.matches || e.matchesSelector || e.msMatchesSelector).call(e, t); } function F(e, t) { for (var n = e instanceof HTMLElement ? [e] : e, r = [], o = 0; o < n.length; o++) for (let i = n[o].querySelectorAll(t), a = 0; a < i.length; a++)r.push(i[a]); return r; } const B = /(top|left|right|bottom|width|height)$/i; function j(e, t) { for (const n in t)G(e, n, t[n]); } function G(e, t, n) { n == null ? e.style[t] = '' : typeof n === 'number' && B.test(t) ? e.style[t] = `${n}px` : e.style[t] = n; } function q(e) { e.preventDefault(); } function Y(e, t) { return function (n) { const r = V(n.target, e); r && t.call(r, n, r); }; } function Z(e, t, n, r) { const o = Y(n, r); return e.addEventListener(t, o), function () { e.removeEventListener(t, o); }; } const X = ['webkitTransitionEnd', 'otransitionend', 'oTransitionEnd', 'msTransitionEnd', 'transitionend']; function K(e, t) { var n = function (r) { t(r), X.forEach(((t) => { e.removeEventListener(t, n); })); }; X.forEach(((t) => { e.addEventListener(t, n); })); } let J = 0; function $() { return String(J++); } function Q() { document.body.classList.add('fc-not-allowed'); } function ee() { document.body.classList.remove('fc-not-allowed'); } function te(e) { e.classList.add('fc-unselectable'), e.addEventListener('selectstart', q); } function ne(e) { e.classList.remove('fc-unselectable'), e.removeEventListener('selectstart', q); } function re(e) { e.addEventListener('contextmenu', q); } function oe(e) { e.removeEventListener('contextmenu', q); } function ie(e) { let t; let n; const r = []; let o = []; for (typeof e === 'string' ? o = e.split(/\s*,\s*/) : typeof e === 'function' ? o = [e] : Array.isArray(e) && (o = e), t = 0; t < o.length; t++) typeof (n = o[t]) === 'string' ? r.push(n.charAt(0) === '-' ? { field: n.substring(1), order: -1 } : { field: n, order: 1 }) : typeof n === 'function' && r.push({ func: n }); return r; } function ae(e, t, n) { let r; let o; for (r = 0; r < n.length; r++) if (o = se(e, t, n[r])) return o; return 0; } function se(e, t, n) { return n.func ? n.func(e, t) : le(e[n.field], t[n.field]) * (n.order || 1); } function le(e, t) { return e || t ? t == null ? -1 : e == null ? 1 : typeof e === 'string' || typeof t === 'string' ? String(e).localeCompare(String(t)) : e - t : 0; } function ue(e, t) { const n = String(e); return '000'.substr(0, t - n.length) + n; } function ce(e, t) { return e - t; } function de(e) { return e % 1 == 0; } function pe(e) { const t = e.querySelector('.fc-scrollgrid-shrink-frame'); const n = e.querySelector('.fc-scrollgrid-shrink-cushion'); if (!t) throw new Error('needs fc-scrollgrid-shrink-frame className'); if (!n) throw new Error('needs fc-scrollgrid-shrink-cushion className'); return e.getBoundingClientRect().width - t.getBoundingClientRect().width + n.getBoundingClientRect().width; } const fe = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat']; function he(e, t) { const n = ke(e); return n[2] += 7 * t, Me(n); } function ve(e, t) { const n = ke(e); return n[2] += t, Me(n); } function ge(e, t) { const n = ke(e); return n[6] += t, Me(n); } function me(e, t) { return ye(e, t) / 7; } function ye(e, t) { return (t.valueOf() - e.valueOf()) / 864e5; } function Ee(e, t) {
    const n = be(e); const r = be(t); return {
      years: 0, months: 0, days: Math.round(ye(n, r)), milliseconds: t.valueOf() - r.valueOf() - (e.valueOf() - n.valueOf()),
    };
  } function Se(e, t) { const n = De(e, t); return n !== null && n % 7 == 0 ? n / 7 : null; } function De(e, t) { return _e(e) === _e(t) ? Math.round(ye(e, t)) : null; } function be(e) { return Me([e.getUTCFullYear(), e.getUTCMonth(), e.getUTCDate()]); } function Ce(e, t, n, r) { const o = Me([t, 0, 1 + we(t, n, r)]); const i = be(e); const a = Math.round(ye(o, i)); return Math.floor(a / 7) + 1; } function we(e, t, n) { const r = 7 + t - n; return -((7 + Me([e, 0, r]).getUTCDay() - t) % 7) + r - 1; } function Re(e) { return [e.getFullYear(), e.getMonth(), e.getDate(), e.getHours(), e.getMinutes(), e.getSeconds(), e.getMilliseconds()]; } function Te(e) { return new Date(e[0], e[1] || 0, e[2] == null ? 1 : e[2], e[3] || 0, e[4] || 0, e[5] || 0); } function ke(e) { return [e.getUTCFullYear(), e.getUTCMonth(), e.getUTCDate(), e.getUTCHours(), e.getUTCMinutes(), e.getUTCSeconds(), e.getUTCMilliseconds()]; } function Me(e) { return e.length === 1 && (e = e.concat([0])), new Date(Date.UTC.apply(Date, e)); } function xe(e) { return !isNaN(e.valueOf()); } function _e(e) { return 1e3 * e.getUTCHours() * 60 * 60 + 1e3 * e.getUTCMinutes() * 60 + 1e3 * e.getUTCSeconds() + e.getUTCMilliseconds(); } function Ie(e, t, n, r) {
    return {
      instanceId: $(), defId: e, range: t, forcedStartTzo: n == null ? null : n, forcedEndTzo: r == null ? null : r,
    };
  } const Pe = Object.prototype.hasOwnProperty; function Ne(e, t) { const n = {}; if (t) for (const r in t) { for (var o = [], i = e.length - 1; i >= 0; i--) { const a = e[i][r]; if (typeof a === 'object' && a)o.unshift(a); else if (void 0 !== a) { n[r] = a; break; } }o.length && (n[r] = Ne(o)); } for (i = e.length - 1; i >= 0; i--) { const s = e[i]; for (const l in s)l in n || (n[l] = s[l]); } return n; } function He(e, t) { const n = {}; for (const r in e)t(e[r], r) && (n[r] = e[r]); return n; } function Oe(e, t) { const n = {}; for (const r in e)n[r] = t(e[r], r); return n; } function Ae(e) { for (var t = {}, n = 0, r = e; n < r.length; n++) { t[r[n]] = !0; } return t; } function Ue(e) { const t = []; for (const n in e)t.push(e[n]); return t; } function Le(e, t) { if (e === t) return !0; for (var n in e) if (Pe.call(e, n) && !(n in t)) return !1; for (var n in t) if (Pe.call(t, n) && e[n] !== t[n]) return !1; return !0; } function We(e, t) { const n = []; for (var r in e)Pe.call(e, r) && (r in t || n.push(r)); for (var r in t)Pe.call(t, r) && e[r] !== t[r] && n.push(r); return n; } function Ve(e, t, n) { if (void 0 === n && (n = {}), e === t) return !0; for (var r in t) if (!(r in e) || !ze(e[r], t[r], n[r])) return !1; for (var r in e) if (!(r in t)) return !1; return !0; } function ze(e, t, n) { return e === t || !0 === n || !!n && n(e, t); } function Fe(e, t, n, r) { void 0 === t && (t = 0), void 0 === r && (r = 1); const o = []; n == null && (n = Object.keys(e).length); for (let i = t; i < n; i += r) { const a = e[i]; void 0 !== a && o.push(a); } return o; } function Be(e, t, n) { const r = n.dateEnv; const o = n.pluginHooks; const i = n.options; const a = e.defs; let s = e.instances; for (const l in s = He(s, ((e) => !a[e.defId].recurringDef)), a) { const u = a[l]; if (u.recurringDef) { let c = u.recurringDef.duration; c || (c = u.allDay ? i.defaultAllDayEventDuration : i.defaultTimedEventDuration); for (let d = 0, p = je(u, c, t, r, o.recurringTypes); d < p.length; d++) { const f = p[d]; const h = Ie(l, { start: f, end: r.add(f, c) }); s[h.instanceId] = h; } } } return { defs: a, instances: s }; } function je(e, t, n, r, o) { let i = o[e.recurringDef.typeId].expand(e.recurringDef.typeData, { start: r.subtract(n.start, t), end: n.end }, r); return e.allDay && (i = i.map(be)), i; } const Ge = ['years', 'months', 'days', 'milliseconds']; const qe = /^(-?)(?:(\d+)\.)?(\d+):(\d\d)(?::(\d\d)(?:\.(\d\d\d))?)?/; function Ye(e, t) {
    let n; return typeof e === 'string' ? (function (e) {
      const t = qe.exec(e); if (t) {
        const n = t[1] ? -1 : 1; return {
          years: 0, months: 0, days: n * (t[2] ? parseInt(t[2], 10) : 0), milliseconds: n * (60 * (t[3] ? parseInt(t[3], 10) : 0) * 60 * 1e3 + 60 * (t[4] ? parseInt(t[4], 10) : 0) * 1e3 + 1e3 * (t[5] ? parseInt(t[5], 10) : 0) + (t[6] ? parseInt(t[6], 10) : 0)),
        };
      } return null;
    }(e)) : typeof e === 'object' && e ? Ze(e) : typeof e === 'number' ? Ze(((n = {})[t || 'milliseconds'] = e, n)) : null;
  } function Ze(e) {
    const t = {
      years: e.years || e.year || 0, months: e.months || e.month || 0, days: e.days || e.day || 0, milliseconds: 60 * (e.hours || e.hour || 0) * 60 * 1e3 + 60 * (e.minutes || e.minute || 0) * 1e3 + 1e3 * (e.seconds || e.second || 0) + (e.milliseconds || e.millisecond || e.ms || 0),
    }; const n = e.weeks || e.week; return n && (t.days += 7 * n, t.specifiedWeeks = !0), t;
  } function Xe(e, t) {
    return {
      years: e.years + t.years, months: e.months + t.months, days: e.days + t.days, milliseconds: e.milliseconds + t.milliseconds,
    };
  } function Ke(e, t) {
    return {
      years: e.years * t, months: e.months * t, days: e.days * t, milliseconds: e.milliseconds * t,
    };
  } function Je(e) { return $e(e) / 864e5; } function $e(e) { return 31536e6 * e.years + 2592e6 * e.months + 864e5 * e.days + e.milliseconds; } function Qe(e, t) { for (var n = null, r = 0; r < Ge.length; r++) { const o = Ge[r]; if (t[o]) { const i = e[o] / t[o]; if (!de(i) || n !== null && n !== i) return null; n = i; } else if (e[o]) return null; } return n; } function et(e) { const t = e.milliseconds; if (t) { if (t % 1e3 != 0) return { unit: 'millisecond', value: t }; if (t % 6e4 != 0) return { unit: 'second', value: t / 1e3 }; if (t % 36e5 != 0) return { unit: 'minute', value: t / 6e4 }; if (t) return { unit: 'hour', value: t / 36e5 }; } return e.days ? e.specifiedWeeks && e.days % 7 == 0 ? { unit: 'week', value: e.days / 7 } : { unit: 'day', value: e.days } : e.months ? { unit: 'month', value: e.months } : e.years ? { unit: 'year', value: e.years } : { unit: 'millisecond', value: 0 }; } function tt(e) { return e.toISOString().replace(/T.*$/, ''); } function nt(e) { return `${ue(e.getUTCHours(), 2)}:${ue(e.getUTCMinutes(), 2)}:${ue(e.getUTCSeconds(), 2)}`; } function rt(e, t) {
    void 0 === t && (t = !1); const n = e < 0 ? '-' : '+'; const r = Math.abs(e); const o = Math.floor(r / 60); const
      i = Math.round(r % 60); return t ? `${n + ue(o, 2)}:${ue(i, 2)}` : `GMT${n}${o}${i ? `:${ue(i, 2)}` : ''}`;
  } function ot(e, t, n) { if (e === t) return !0; let r; const o = e.length; if (o !== t.length) return !1; for (r = 0; r < o; r++) if (!(n ? n(e[r], t[r]) : e[r] === t[r])) return !1; return !0; } function it(e, t, n) { let r; let o; return function () { for (var i = [], a = 0; a < arguments.length; a++)i[a] = arguments[a]; if (r) { if (!ot(r, i)) { n && n(o); const s = e.apply(this, i); t && t(s, o) || (o = s); } } else o = e.apply(this, i); return r = i, o; }; } function at(e, t, n) { let r; let o; return function (i) { if (r) { if (!Le(r, i)) { n && n(o); const a = e.call(this, i); t && t(a, o) || (o = a); } } else o = e.call(this, i); return r = i, o; }; } const st = {
    week: 3, separator: 0, omitZeroMinute: 0, meridiem: 0, omitCommas: 0,
  }; const lt = {
    timeZoneName: 7, era: 6, year: 5, month: 4, day: 2, weekday: 2, hour: 1, minute: 1, second: 1,
  }; const ut = /\s*([ap])\.?m\.?/i; const ct = /,/g; const dt = /\s+/g; const pt = /\u200e/g; const ft = /UTC|GMT/; const ht = (function () { function e(e) { const t = {}; const n = {}; let r = 0; for (const o in e)o in st ? (n[o] = e[o], r = Math.max(st[o], r)) : (t[o] = e[o], o in lt && (r = Math.max(lt[o], r))); this.standardDateProps = t, this.extendedSettings = n, this.severity = r, this.buildFormattingFunc = it(vt); } return e.prototype.format = function (e, t) { return this.buildFormattingFunc(this.standardDateProps, this.extendedSettings, t)(e); }, e.prototype.formatRange = function (e, t, n, r) { const o = this.standardDateProps; const i = this.extendedSettings; const a = (function (e, t, n) { if (n.getMarkerYear(e) !== n.getMarkerYear(t)) return 5; if (n.getMarkerMonth(e) !== n.getMarkerMonth(t)) return 4; if (n.getMarkerDay(e) !== n.getMarkerDay(t)) return 2; if (_e(e) !== _e(t)) return 1; return 0; }(e.marker, t.marker, n.calendarSystem)); if (!a) return this.format(e, n); let s = a; !(s > 1) || o.year !== 'numeric' && o.year !== '2-digit' || o.month !== 'numeric' && o.month !== '2-digit' || o.day !== 'numeric' && o.day !== '2-digit' || (s = 1); const l = this.format(e, n); const u = this.format(t, n); if (l === u) return l; const c = vt((function (e, t) { const n = {}; for (const r in e)(!(r in lt) || lt[r] <= t) && (n[r] = e[r]); return n; }(o, s)), i, n); const d = c(e); const p = c(t); const f = (function (e, t, n, r) { let o = 0; for (;o < e.length;) { const i = e.indexOf(t, o); if (i === -1) break; const a = e.substr(0, i); o = i + t.length; for (let s = e.substr(o), l = 0; l < n.length;) { const u = n.indexOf(r, l); if (u === -1) break; const c = n.substr(0, u); l = u + r.length; const d = n.substr(l); if (a === c && s === d) return { before: a, after: s }; } } return null; }(l, d, u, p)); const h = i.separator || r || n.defaultSeparator || ''; return f ? f.before + d + h + p + f.after : l + h + u; }, e.prototype.getLargestUnit = function () { switch (this.severity) { case 7: case 6: case 5: return 'year'; case 4: return 'month'; case 3: return 'week'; case 2: return 'day'; default: return 'time'; } }, e; }()); function vt(e, t, n) { const o = Object.keys(e).length; return o === 1 && e.timeZoneName === 'short' ? function (e) { return rt(e.timeZoneOffset); } : o === 0 && t.week ? function (e) { return (function (e, t, n, r) { const o = []; r === 'narrow' ? o.push(t) : r === 'short' && o.push(t, ' '); o.push(n.simpleNumberFormat.format(e)), n.options.direction === 'rtl' && o.reverse(); return o.join(''); }(n.computeWeekNumber(e.marker), n.weekText, n.locale, t.week)); } : (function (e, t, n) { e = { ...e }, t = { ...t }, (function (e, t) { e.timeZoneName && (e.hour || (e.hour = '2-digit'), e.minute || (e.minute = '2-digit')); e.timeZoneName === 'long' && (e.timeZoneName = 'short'); t.omitZeroMinute && (e.second || e.millisecond) && delete t.omitZeroMinute; }(e, t)), e.timeZone = 'UTC'; let o; const i = new Intl.DateTimeFormat(n.locale.codes, e); if (t.omitZeroMinute) { const a = { ...e }; delete a.minute, o = new Intl.DateTimeFormat(n.locale.codes, a); } return function (r) { const a = r.marker; return (function (e, t, n, r, o) { e = e.replace(pt, ''), n.timeZoneName === 'short' && (e = (function (e, t) { let n = !1; e = e.replace(ft, (() => (n = !0, t))), n || (e += ` ${t}`); return e; }(e, o.timeZone === 'UTC' || t.timeZoneOffset == null ? 'UTC' : rt(t.timeZoneOffset)))); r.omitCommas && (e = e.replace(ct, '').trim()); r.omitZeroMinute && (e = e.replace(':00', '')); !1 === r.meridiem ? e = e.replace(ut, '').trim() : r.meridiem === 'narrow' ? e = e.replace(ut, ((e, t) => t.toLocaleLowerCase())) : r.meridiem === 'short' ? e = e.replace(ut, ((e, t) => `${t.toLocaleLowerCase()}m`)) : r.meridiem === 'lowercase' && (e = e.replace(ut, ((e) => e.toLocaleLowerCase()))); return e = (e = e.replace(dt, ' ')).trim(); }((o && !a.getUTCMinutes() ? o : i).format(a), r, e, t, n)); }; }(e, t, n)); } function gt(e, t) {
    const n = t.markerToArray(e.marker); return {
      marker: e.marker, timeZoneOffset: e.timeZoneOffset, array: n, year: n[0], month: n[1], day: n[2], hour: n[3], minute: n[4], second: n[5], millisecond: n[6],
    };
  } function mt(e, t, n, r) {
    const o = gt(e, n.calendarSystem); return {
      date: o, start: o, end: t ? gt(t, n.calendarSystem) : null, timeZone: n.timeZone, localeCodes: n.locale.codes, defaultSeparator: r || n.defaultSeparator,
    };
  } const yt = (function () { function e(e) { this.cmdStr = e; } return e.prototype.format = function (e, t, n) { return t.cmdFormatter(this.cmdStr, mt(e, null, t, n)); }, e.prototype.formatRange = function (e, t, n, r) { return n.cmdFormatter(this.cmdStr, mt(e, t, n, r)); }, e; }()); const Et = (function () { function e(e) { this.func = e; } return e.prototype.format = function (e, t, n) { return this.func(mt(e, null, t, n)); }, e.prototype.formatRange = function (e, t, n, r) { return this.func(mt(e, t, n, r)); }, e; }()); function St(e) { return typeof e === 'object' && e ? new ht(e) : typeof e === 'string' ? new yt(e) : typeof e === 'function' ? new Et(e) : void 0; } const Dt = {
    navLinkDayClick: _t, navLinkWeekClick: _t, duration: Ye, bootstrapFontAwesome: _t, buttonIcons: _t, customButtons: _t, defaultAllDayEventDuration: Ye, defaultTimedEventDuration: Ye, nextDayThreshold: Ye, scrollTime: Ye, slotMinTime: Ye, slotMaxTime: Ye, dayPopoverFormat: St, slotDuration: Ye, snapDuration: Ye, headerToolbar: _t, footerToolbar: _t, defaultRangeSeparator: String, titleRangeSeparator: String, forceEventDuration: Boolean, dayHeaders: Boolean, dayHeaderFormat: St, dayHeaderClassNames: _t, dayHeaderContent: _t, dayHeaderDidMount: _t, dayHeaderWillUnmount: _t, dayCellClassNames: _t, dayCellContent: _t, dayCellDidMount: _t, dayCellWillUnmount: _t, initialView: String, aspectRatio: Number, weekends: Boolean, weekNumberCalculation: _t, weekNumbers: Boolean, weekNumberClassNames: _t, weekNumberContent: _t, weekNumberDidMount: _t, weekNumberWillUnmount: _t, editable: Boolean, viewClassNames: _t, viewDidMount: _t, viewWillUnmount: _t, nowIndicator: Boolean, nowIndicatorClassNames: _t, nowIndicatorContent: _t, nowIndicatorDidMount: _t, nowIndicatorWillUnmount: _t, showNonCurrentDates: Boolean, lazyFetching: Boolean, startParam: String, endParam: String, timeZoneParam: String, timeZone: String, locales: _t, locale: _t, themeSystem: String, dragRevertDuration: Number, dragScroll: Boolean, allDayMaintainDuration: Boolean, unselectAuto: Boolean, dropAccept: _t, eventOrder: ie, handleWindowResize: Boolean, windowResizeDelay: Number, longPressDelay: Number, eventDragMinDistance: Number, expandRows: Boolean, height: _t, contentHeight: _t, direction: String, weekNumberFormat: St, eventResizableFromStart: Boolean, displayEventTime: Boolean, displayEventEnd: Boolean, weekText: String, progressiveEventRendering: Boolean, businessHours: _t, initialDate: _t, now: _t, eventDataTransform: _t, stickyHeaderDates: _t, stickyFooterScrollbar: _t, viewHeight: _t, defaultAllDay: Boolean, eventSourceFailure: _t, eventSourceSuccess: _t, eventDisplay: String, eventStartEditable: Boolean, eventDurationEditable: Boolean, eventOverlap: _t, eventConstraint: _t, eventAllow: _t, eventBackgroundColor: String, eventBorderColor: String, eventTextColor: String, eventColor: String, eventClassNames: _t, eventContent: _t, eventDidMount: _t, eventWillUnmount: _t, selectConstraint: _t, selectOverlap: _t, selectAllow: _t, droppable: Boolean, unselectCancel: String, slotLabelFormat: _t, slotLaneClassNames: _t, slotLaneContent: _t, slotLaneDidMount: _t, slotLaneWillUnmount: _t, slotLabelClassNames: _t, slotLabelContent: _t, slotLabelDidMount: _t, slotLabelWillUnmount: _t, dayMaxEvents: _t, dayMaxEventRows: _t, dayMinWidth: Number, slotLabelInterval: Ye, allDayText: String, allDayClassNames: _t, allDayContent: _t, allDayDidMount: _t, allDayWillUnmount: _t, slotMinWidth: Number, navLinks: Boolean, eventTimeFormat: St, rerenderDelay: Number, moreLinkText: _t, selectMinDistance: Number, selectable: Boolean, selectLongPressDelay: Number, eventLongPressDelay: Number, selectMirror: Boolean, eventMinHeight: Number, slotEventOverlap: Boolean, plugins: _t, firstDay: Number, dayCount: Number, dateAlignment: String, dateIncrement: Ye, hiddenDays: _t, monthMode: Boolean, fixedWeekCount: Boolean, validRange: _t, visibleRange: _t, titleFormat: _t, noEventsText: String,
  }; const bt = {
    eventDisplay: 'auto', defaultRangeSeparator: ' - ', titleRangeSeparator: ' – ', defaultTimedEventDuration: '01:00:00', defaultAllDayEventDuration: { day: 1 }, forceEventDuration: !1, nextDayThreshold: '00:00:00', dayHeaders: !0, initialView: '', aspectRatio: 1.35, headerToolbar: { start: 'title', center: '', end: 'today prev,next' }, weekends: !0, weekNumbers: !1, weekNumberCalculation: 'local', editable: !1, nowIndicator: !1, scrollTime: '06:00:00', slotMinTime: '00:00:00', slotMaxTime: '24:00:00', showNonCurrentDates: !0, lazyFetching: !0, startParam: 'start', endParam: 'end', timeZoneParam: 'timeZone', timeZone: 'local', locales: [], locale: '', themeSystem: 'standard', dragRevertDuration: 500, dragScroll: !0, allDayMaintainDuration: !1, unselectAuto: !0, dropAccept: '*', eventOrder: 'start,-duration,allDay,title', dayPopoverFormat: { month: 'long', day: 'numeric', year: 'numeric' }, handleWindowResize: !0, windowResizeDelay: 100, longPressDelay: 1e3, eventDragMinDistance: 5, expandRows: !1, navLinks: !1, selectable: !1,
  }; const Ct = {
    datesSet: _t, eventsSet: _t, eventAdd: _t, eventChange: _t, eventRemove: _t, windowResize: _t, eventClick: _t, eventMouseEnter: _t, eventMouseLeave: _t, select: _t, unselect: _t, loading: _t, _unmount: _t, _beforeprint: _t, _afterprint: _t, _noEventDrop: _t, _noEventResize: _t, _resize: _t, _scrollRequest: _t,
  }; const wt = {
    buttonText: _t, views: _t, plugins: _t, initialEvents: _t, events: _t, eventSources: _t,
  }; const Rt = {
    headerToolbar: Tt, footerToolbar: Tt, buttonText: Tt, buttonIcons: Tt,
  }; function Tt(e, t) { return typeof e === 'object' && typeof t === 'object' && e && t ? Le(e, t) : e === t; } const kt = {
    type: String, component: _t, buttonText: String, buttonTextKey: String, dateProfileGeneratorClass: _t, usesMinMaxTime: Boolean, classNames: _t, content: _t, didMount: _t, willUnmount: _t,
  }; function Mt(e) { return Ne(e, Rt); } function xt(e, t) { const n = {}; const r = {}; for (var o in t)o in e && (n[o] = t[o](e[o])); for (var o in e)o in t || (r[o] = e[o]); return { refined: n, extra: r }; } function _t(e) { return e; } function It(e, t, n, r) { for (var o = { defs: {}, instances: {} }, i = Zt(n), a = 0, s = e; a < s.length; a++) { const l = qt(s[a], t, n, r, i); l && Pt(l, o); } return o; } function Pt(e, t) { return void 0 === t && (t = { defs: {}, instances: {} }), t.defs[e.def.defId] = e.def, e.instance && (t.instances[e.instance.instanceId] = e.instance), t; } function Nt(e, t) { const n = e.instances[t]; if (n) { const r = e.defs[n.defId]; const o = At(e, ((e) => { return t = r, n = e, Boolean(t.groupId && t.groupId === n.groupId); let t; let n; })); return o.defs[r.defId] = r, o.instances[n.instanceId] = n, o; } return { defs: {}, instances: {} }; } function Ht() { return { defs: {}, instances: {} }; } function Ot(e, t) { return { defs: { ...e.defs, ...t.defs }, instances: { ...e.instances, ...t.instances } }; } function At(e, t) { const n = He(e.defs, t); const r = He(e.instances, ((e) => n[e.defId])); return { defs: n, instances: r }; } function Ut(e) { return Array.isArray(e) ? e : typeof e === 'string' ? e.split(/\s+/) : []; } const Lt = {
    display: String, editable: Boolean, startEditable: Boolean, durationEditable: Boolean, constraint: _t, overlap: _t, allow: _t, className: Ut, classNames: Ut, color: String, backgroundColor: String, borderColor: String, textColor: String,
  }; function Wt(e, t) {
    const n = (function (e, t) { return Array.isArray(e) ? It(e, null, t, !0) : typeof e === 'object' && e ? It([e], null, t, !0) : e != null ? String(e) : null; }(e.constraint, t)); return {
      display: e.display || null, startEditable: e.startEditable != null ? e.startEditable : e.editable, durationEditable: e.durationEditable != null ? e.durationEditable : e.editable, constraints: n != null ? [n] : [], overlap: e.overlap != null ? e.overlap : null, allows: e.allow != null ? [e.allow] : [], backgroundColor: e.backgroundColor || e.color || '', borderColor: e.borderColor || e.color || '', textColor: e.textColor || '', classNames: (e.className || []).concat(e.classNames || []),
    };
  } function Vt(e) { return e.reduce(zt, Ft); } function zt(e, t) {
    return {
      display: t.display != null ? t.display : e.display, startEditable: t.startEditable != null ? t.startEditable : e.startEditable, durationEditable: t.durationEditable != null ? t.durationEditable : e.durationEditable, constraints: e.constraints.concat(t.constraints), overlap: typeof t.overlap === 'boolean' ? t.overlap : e.overlap, allows: e.allows.concat(t.allows), backgroundColor: t.backgroundColor || e.backgroundColor, borderColor: t.borderColor || e.borderColor, textColor: t.textColor || e.textColor, classNames: e.classNames.concat(t.classNames),
    };
  } var Ft = {
    display: null, startEditable: null, durationEditable: null, constraints: [], overlap: null, allows: [], backgroundColor: '', borderColor: '', textColor: '', classNames: [],
  }; const Bt = {
    id: String, groupId: String, title: String, url: String,
  }; const jt = {
    start: _t, end: _t, date: _t, allDay: Boolean,
  }; const Gt = { ...Bt, ...jt, extendedProps: _t }; function qt(e, t, n, r, o) {
    void 0 === o && (o = Zt(n)); const i = Yt(e, n, o); const a = i.refined; const s = i.extra; const l = (function (e, t) { let n = null; e && (n = e.defaultAllDay); n == null && (n = t.options.defaultAllDay); return n; }(t, n)); const u = (function (e, t, n, r) {
      for (let o = 0; o < r.length; o++) {
        const i = r[o].parse(e, n); if (i) {
          let a = e.allDay; return a == null && (a = t) == null && (a = i.allDayGuess) == null && (a = !1), {
            allDay: a, duration: i.duration, typeData: i.typeData, typeId: o,
          };
        }
      } return null;
    }(a, l, n.dateEnv, n.pluginHooks.recurringTypes)); if (u) return (c = Xt(a, s, t ? t.sourceId : '', u.allDay, Boolean(u.duration), n)).recurringDef = { typeId: u.typeId, typeData: u.typeData, duration: u.duration }, { def: c, instance: null }; let c; const d = (function (e, t, n, r) {
      let o; let i; let a = e.allDay; let s = null; let l = !1; let u = null; const c = e.start != null ? e.start : e.date; if (o = n.dateEnv.createMarkerMeta(c))s = o.marker; else if (!r) return null; e.end != null && (i = n.dateEnv.createMarkerMeta(e.end)); a == null && (a = t != null ? t : (!o || o.isTimeUnspecified) && (!i || i.isTimeUnspecified)); a && s && (s = be(s)); i && (u = i.marker, a && (u = be(u)), s && u <= s && (u = null)); u ? l = !0 : r || (l = n.options.forceEventDuration || !1, u = n.dateEnv.add(s, a ? n.options.defaultAllDayEventDuration : n.options.defaultTimedEventDuration)); return {
        allDay: a, hasEnd: l, range: { start: s, end: u }, forcedStartTzo: o ? o.forcedTzo : null, forcedEndTzo: i ? i.forcedTzo : null,
      };
    }(a, l, n, r)); return d ? { def: c = Xt(a, s, t ? t.sourceId : '', d.allDay, d.hasEnd, n), instance: Ie(c.defId, d.range, d.forcedStartTzo, d.forcedEndTzo) } : null;
  } function Yt(e, t, n) { return void 0 === n && (n = Zt(t)), xt(e, n); } function Zt(e) { return { ...Lt, ...Gt, ...e.pluginHooks.eventRefiners }; } function Xt(e, t, n, o, i, a) {
    for (var s = {
        title: e.title || '', groupId: e.groupId || '', publicId: e.id || '', url: e.url || '', recurringDef: null, defId: $(), sourceId: n, allDay: o, hasEnd: i, ui: Wt(e, a), extendedProps: { ...e.extendedProps || {}, ...t },
      }, l = 0, u = a.pluginHooks.eventDefMemberAdders; l < u.length; l++) { const c = u[l]; r(s, c(e)); } return Object.freeze(s.ui.classNames), Object.freeze(s.extendedProps), s;
  } function Kt(e) { const t = Math.floor(ye(e.start, e.end)) || 1; const n = be(e.start); return { start: n, end: ve(n, t) }; } function Jt(e, t) { void 0 === t && (t = Ye(0)); let n = null; let r = null; if (e.end) { r = be(e.end); const o = e.end.valueOf() - r.valueOf(); o && o >= $e(t) && (r = ve(r, 1)); } return e.start && (n = be(e.start), r && r <= n && (r = ve(n, 1))), { start: n, end: r }; } function $t(e) { const t = Jt(e); return ye(t.start, t.end) > 1; } function Qt(e, t, n, r) { return r === 'year' ? Ye(n.diffWholeYears(e, t), 'year') : r === 'month' ? Ye(n.diffWholeMonths(e, t), 'month') : Ee(e, t); } function en(e, t) { let n; let r; const o = []; let i = t.start; for (e.sort(tn), n = 0; n < e.length; n++)(r = e[n]).start > i && o.push({ start: i, end: r.start }), r.end > i && (i = r.end); return i < t.end && o.push({ start: i, end: t.end }), o; } function tn(e, t) { return e.start.valueOf() - t.start.valueOf(); } function nn(e, t) { let n = e.start; let r = e.end; let o = null; return t.start !== null && (n = n === null ? t.start : new Date(Math.max(n.valueOf(), t.start.valueOf()))), t.end != null && (r = r === null ? t.end : new Date(Math.min(r.valueOf(), t.end.valueOf()))), (n === null || r === null || n < r) && (o = { start: n, end: r }), o; } function rn(e, t) { return (e.start === null ? null : e.start.valueOf()) === (t.start === null ? null : t.start.valueOf()) && (e.end === null ? null : e.end.valueOf()) === (t.end === null ? null : t.end.valueOf()); } function on(e, t) { return (e.end === null || t.start === null || e.end > t.start) && (e.start === null || t.end === null || e.start < t.end); } function an(e, t) { return (e.start === null || t.start !== null && t.start >= e.start) && (e.end === null || t.end !== null && t.end <= e.end); } function sn(e, t) { return (e.start === null || t >= e.start) && (e.end === null || t < e.end); } function ln(e, t, n, r) {
    const o = {}; const i = {}; const a = {}; const s = []; const l = []; const u = pn(e.defs, t); for (var c in e.defs) { (f = u[(S = e.defs[c]).defId]).display === 'inverse-background' && (S.groupId ? (o[S.groupId] = [], a[S.groupId] || (a[S.groupId] = S)) : i[c] = []); } for (const d in e.instances) {
      const p = e.instances[d]; var f = u[(S = e.defs[p.defId]).defId]; const h = p.range; const v = !S.allDay && r ? Jt(h, r) : h; const g = nn(v, n); g && (f.display === 'inverse-background' ? S.groupId ? o[S.groupId].push(g) : i[p.defId].push(g) : f.display !== 'none' && (f.display === 'background' ? s : l).push({
        def: S, ui: f, instance: p, range: g, isStart: v.start && v.start.valueOf() === g.start.valueOf(), isEnd: v.end && v.end.valueOf() === g.end.valueOf(),
      }));
    } for (const m in o) {
      for (let y = 0, E = en(o[m], n); y < E.length; y++) {
        var S; var D = E[y]; f = u[(S = a[m]).defId]; s.push({
          def: S, ui: f, instance: null, range: D, isStart: !1, isEnd: !1,
        });
      }
    } for (var c in i) {
      for (let b = 0, C = en(i[c], n); b < C.length; b++) {
        D = C[b]; s.push({
          def: e.defs[c], ui: u[c], instance: null, range: D, isStart: !1, isEnd: !1,
        });
      }
    } return { bg: s, fg: l };
  } function un(e) { return e.ui.display === 'background' || e.ui.display === 'inverse-background'; } function cn(e, t) { e.fcSeg = t; } function dn(e) { return e.fcSeg || e.parentNode.fcSeg || null; } function pn(e, t) { return Oe(e, ((e) => fn(e, t))); } function fn(e, t) { const n = []; return t[''] && n.push(t['']), t[e.defId] && n.push(t[e.defId]), n.push(e.ui), Vt(n); } function hn(e, t) { const n = e.map(vn); return n.sort(((e, n) => ae(e, n, t))), n.map(((e) => e._seg)); } function vn(e) {
    const t = e.eventRange; const n = t.def; const o = t.instance ? t.instance.range : t.range; const i = o.start ? o.start.valueOf() : 0; const a = o.end ? o.end.valueOf() : 0; return {
      ...n.extendedProps, ...n, id: n.publicId, start: i, end: a, duration: a - i, allDay: Number(n.allDay), _seg: e,
    };
  } function gn(e, t) { for (var n = t.pluginHooks.isDraggableTransformers, r = e.eventRange, o = r.def, i = r.ui, a = i.startEditable, s = 0, l = n; s < l.length; s++) { a = (0, l[s])(a, o, i, t); } return a; } function mn(e, t) { return e.isStart && e.eventRange.ui.durationEditable && t.options.eventResizableFromStart; } function yn(e, t) { return e.isEnd && e.eventRange.ui.durationEditable; } function En(e, t, n, r, o, i, a) { const s = n.dateEnv; const l = n.options; let u = l.displayEventTime; let c = l.displayEventEnd; const d = e.eventRange.def; const p = e.eventRange.instance; if (u == null && (u = !1 !== r), c == null && (c = !1 !== o), u && !d.allDay && (e.isStart || e.isEnd)) { const f = i || (e.isStart ? p.range.start : e.start || e.eventRange.range.start); const h = a || (e.isEnd ? p.range.end : e.end || e.eventRange.range.end); return c && d.hasEnd ? s.formatRange(f, h, t, { forcedStartTzo: i ? null : p.forcedStartTzo, forcedEndTzo: a ? null : p.forcedEndTzo }) : s.format(f, t, { forcedTzo: i ? null : p.forcedStartTzo }); } return ''; } function Sn(e, t, n) { const r = e.eventRange.range; return { isPast: r.end < (n || t.start), isFuture: r.start >= (n || t.end), isToday: t && sn(t, r.start) }; } function Dn(e) { const t = ['fc-event']; return e.isMirror && t.push('fc-event-mirror'), e.isDraggable && t.push('fc-event-draggable'), (e.isStartResizable || e.isEndResizable) && t.push('fc-event-resizable'), e.isDragging && t.push('fc-event-dragging'), e.isResizing && t.push('fc-event-resizing'), e.isSelected && t.push('fc-event-selected'), e.isStart && t.push('fc-event-start'), e.isEnd && t.push('fc-event-end'), e.isPast && t.push('fc-event-past'), e.isToday && t.push('fc-event-today'), e.isFuture && t.push('fc-event-future'), t; } function bn(e) { return e.instance ? e.instance.instanceId : `${e.def.defId}:${e.range.start.toISOString()}`; } const Cn = { start: _t, end: _t, allDay: Boolean }; function wn(e, t, n) { const o = (function (e, t) { const n = xt(e, Cn); const o = n.refined; const i = n.extra; const a = o.start ? t.createMarkerMeta(o.start) : null; const s = o.end ? t.createMarkerMeta(o.end) : null; let l = o.allDay; l == null && (l = a && a.isTimeUnspecified && (!s || s.isTimeUnspecified)); return { range: { start: a ? a.marker : null, end: s ? s.marker : null }, allDay: l, ...i }; }(e, t)); const i = o.range; if (!i.start) return null; if (!i.end) { if (n == null) return null; i.end = t.add(i.start, n); } return o; } function Rn(e, t) { return rn(e.range, t.range) && e.allDay === t.allDay && (function (e, t) { for (var n in t) if (n !== 'range' && n !== 'allDay' && e[n] !== t[n]) return !1; for (var n in e) if (!(n in t)) return !1; return !0; }(e, t)); } function Tn(e, t, n) { return { ...kn(e, t, n), timeZone: t.timeZone }; } function kn(e, t, n) {
    return {
      start: t.toDate(e.start), end: t.toDate(e.end), startStr: t.formatIso(e.start, { omitTime: n }), endStr: t.formatIso(e.end, { omitTime: n }),
    };
  } function Mn(e, t, n) {
    const r = Yt({ editable: !1 }, n); const o = Xt(r.refined, r.extra, '', e.allDay, !0, n); return {
      def: o, ui: fn(o, t), instance: Ie(o.defId, e.range), range: e.range, isStart: !0, isEnd: !0,
    };
  } function xn(e, t, n) { n.emitter.trigger('select', { ..._n(e, n), jsEvent: t ? t.origEvent : null, view: n.viewApi || n.calendarApi.view }); } function _n(e, t) { for (var n, o, i = {}, a = 0, s = t.pluginHooks.dateSpanTransforms; a < s.length; a++) { const l = s[a]; r(i, l(e, t)); } return r(i, (n = e, o = t.dateEnv, ({ ...kn(n.range, o, n.allDay), allDay: n.allDay }))), i; } function In(e, t, n) { const r = n.dateEnv; const o = n.options; let i = t; return e ? (i = be(i), i = r.add(i, o.defaultAllDayEventDuration)) : i = r.add(i, o.defaultTimedEventDuration), i; } function Pn(e, t, n, r) { const o = pn(e.defs, t); const i = { defs: {}, instances: {} }; for (const a in e.defs) { var s = e.defs[a]; i.defs[a] = Nn(s, o[a], n, r); } for (const l in e.instances) { const u = e.instances[l]; s = i.defs[u.defId]; i.instances[l] = Hn(u, s, o[u.defId], n, r); } return i; } function Nn(e, t, n, o) { const i = n.standardProps || {}; i.hasEnd == null && t.durationEditable && (n.startDelta || n.endDelta) && (i.hasEnd = !0); const a = { ...e, ...i, ui: { ...e.ui, ...i.ui } }; n.extendedProps && (a.extendedProps = { ...a.extendedProps, ...n.extendedProps }); for (let s = 0, l = o.pluginHooks.eventDefMutationAppliers; s < l.length; s++) { (0, l[s])(a, n, o); } return !a.hasEnd && o.options.forceEventDuration && (a.hasEnd = !0), a; } function Hn(e, t, n, o, i) { const a = i.dateEnv; const s = o.standardProps && !0 === o.standardProps.allDay; const l = o.standardProps && !1 === o.standardProps.hasEnd; const u = { ...e }; return s && (u.range = Kt(u.range)), o.datesDelta && n.startEditable && (u.range = { start: a.add(u.range.start, o.datesDelta), end: a.add(u.range.end, o.datesDelta) }), o.startDelta && n.durationEditable && (u.range = { start: a.add(u.range.start, o.startDelta), end: u.range.end }), o.endDelta && n.durationEditable && (u.range = { start: u.range.start, end: a.add(u.range.end, o.endDelta) }), l && (u.range = { start: u.range.start, end: In(t.allDay, u.range.start, i) }), t.allDay && (u.range = { start: be(u.range.start), end: be(u.range.end) }), u.range.end < u.range.start && (u.range.end = In(t.allDay, u.range.start, i)), u; } const On = (function () { function e(e, t, n) { this.type = e, this.getCurrentData = t, this.dateEnv = n; } return Object.defineProperty(e.prototype, 'calendar', { get() { return this.getCurrentData().calendarApi; }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, 'title', { get() { return this.getCurrentData().viewTitle; }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, 'activeStart', { get() { return this.dateEnv.toDate(this.getCurrentData().dateProfile.activeRange.start); }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, 'activeEnd', { get() { return this.dateEnv.toDate(this.getCurrentData().dateProfile.activeRange.end); }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, 'currentStart', { get() { return this.dateEnv.toDate(this.getCurrentData().dateProfile.currentRange.start); }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, 'currentEnd', { get() { return this.dateEnv.toDate(this.getCurrentData().dateProfile.currentRange.end); }, enumerable: !1, configurable: !0 }), e.prototype.getOption = function (e) { return this.getCurrentData().options[e]; }, e; }()); const An = {
    id: String, defaultAllDay: Boolean, url: String, events: _t, eventDataTransform: _t, success: _t, failure: _t,
  }; function Un(e, t, n) {
    let r; if (void 0 === n && (n = Ln(t)), typeof e === 'string' ? r = { url: e } : typeof e === 'function' || Array.isArray(e) ? r = { events: e } : typeof e === 'object' && e && (r = e), r) {
      const o = xt(r, n); const i = o.refined; const a = o.extra; const s = (function (e, t) { for (let n = t.pluginHooks.eventSourceDefs, r = n.length - 1; r >= 0; r--) { const o = n[r].parseMeta(e); if (o) return { sourceDefId: r, meta: o }; } return null; }(i, t)); if (s) {
        return {
          _raw: e, isFetching: !1, latestFetchId: '', fetchRange: null, defaultAllDay: i.defaultAllDay, eventDataTransform: i.eventDataTransform, success: i.success, failure: i.failure, publicId: i.id || '', sourceId: $(), sourceDefId: s.sourceDefId, meta: s.meta, ui: Wt(i, t), extendedProps: a,
        };
      }
    } return null;
  } function Ln(e) { return { ...Lt, ...An, ...e.pluginHooks.eventSourceRefiners }; } function Wn(e, t) { return typeof e === 'function' && (e = e()), e == null ? t.createNowMarker() : t.createMarker(e); } const Vn = (function () { function e() {} return e.prototype.getCurrentData = function () { return this.currentDataManager.getCurrentData(); }, e.prototype.dispatch = function (e) { return this.currentDataManager.dispatch(e); }, Object.defineProperty(e.prototype, 'view', { get() { return this.getCurrentData().viewApi; }, enumerable: !1, configurable: !0 }), e.prototype.batchRendering = function (e) { e(); }, e.prototype.updateSize = function () { this.trigger('_resize', !0); }, e.prototype.setOption = function (e, t) { this.dispatch({ type: 'SET_OPTION', optionName: e, rawOptionValue: t }); }, e.prototype.getOption = function (e) { return this.currentDataManager.currentCalendarOptionsInput[e]; }, e.prototype.getAvailableLocaleCodes = function () { return Object.keys(this.getCurrentData().availableRawLocales); }, e.prototype.on = function (e, t) { const n = this.currentDataManager; n.currentCalendarOptionsRefiners[e] ? n.emitter.on(e, t) : console.warn(`Unknown listener name '${e}'`); }, e.prototype.off = function (e, t) { this.currentDataManager.emitter.off(e, t); }, e.prototype.trigger = function (e) { for (var t, n = [], r = 1; r < arguments.length; r++)n[r - 1] = arguments[r]; (t = this.currentDataManager.emitter).trigger.apply(t, o([e], n)); }, e.prototype.changeView = function (e, t) { const n = this; this.batchRendering((() => { if (n.unselect(), t) if (t.start && t.end)n.dispatch({ type: 'CHANGE_VIEW_TYPE', viewType: e }), n.dispatch({ type: 'SET_OPTION', optionName: 'visibleRange', rawOptionValue: t }); else { const r = n.getCurrentData().dateEnv; n.dispatch({ type: 'CHANGE_VIEW_TYPE', viewType: e, dateMarker: r.createMarker(t) }); } else n.dispatch({ type: 'CHANGE_VIEW_TYPE', viewType: e }); })); }, e.prototype.zoomTo = function (e, t) { let n; t = t || 'day', n = this.getCurrentData().viewSpecs[t] || this.getUnitViewSpec(t), this.unselect(), n ? this.dispatch({ type: 'CHANGE_VIEW_TYPE', viewType: n.type, dateMarker: e }) : this.dispatch({ type: 'CHANGE_DATE', dateMarker: e }); }, e.prototype.getUnitViewSpec = function (e) { let t; let n; const r = this.getCurrentData(); const o = r.viewSpecs; const i = r.toolbarConfig; const a = [].concat(i.viewsWithButtons); for (const s in o)a.push(s); for (t = 0; t < a.length; t++) if ((n = o[a[t]]) && n.singleUnit === e) return n; }, e.prototype.prev = function () { this.unselect(), this.dispatch({ type: 'PREV' }); }, e.prototype.next = function () { this.unselect(), this.dispatch({ type: 'NEXT' }); }, e.prototype.prevYear = function () { const e = this.getCurrentData(); this.unselect(), this.dispatch({ type: 'CHANGE_DATE', dateMarker: e.dateEnv.addYears(e.currentDate, -1) }); }, e.prototype.nextYear = function () { const e = this.getCurrentData(); this.unselect(), this.dispatch({ type: 'CHANGE_DATE', dateMarker: e.dateEnv.addYears(e.currentDate, 1) }); }, e.prototype.today = function () { const e = this.getCurrentData(); this.unselect(), this.dispatch({ type: 'CHANGE_DATE', dateMarker: Wn(e.calendarOptions.now, e.dateEnv) }); }, e.prototype.gotoDate = function (e) { const t = this.getCurrentData(); this.unselect(), this.dispatch({ type: 'CHANGE_DATE', dateMarker: t.dateEnv.createMarker(e) }); }, e.prototype.incrementDate = function (e) { const t = this.getCurrentData(); const n = Ye(e); n && (this.unselect(), this.dispatch({ type: 'CHANGE_DATE', dateMarker: t.dateEnv.add(t.currentDate, n) })); }, e.prototype.getDate = function () { const e = this.getCurrentData(); return e.dateEnv.toDate(e.currentDate); }, e.prototype.formatDate = function (e, t) { const n = this.getCurrentData().dateEnv; return n.format(n.createMarker(e), St(t)); }, e.prototype.formatRange = function (e, t, n) { const r = this.getCurrentData().dateEnv; return r.formatRange(r.createMarker(e), r.createMarker(t), St(n), n); }, e.prototype.formatIso = function (e, t) { const n = this.getCurrentData().dateEnv; return n.formatIso(n.createMarker(e), { omitTime: t }); }, e.prototype.select = function (e, t) { let n; n = t == null ? e.start != null ? e : { start: e, end: null } : { start: e, end: t }; const r = this.getCurrentData(); const o = wn(n, r.dateEnv, Ye({ days: 1 })); o && (this.dispatch({ type: 'SELECT_DATES', selection: o }), xn(o, null, r)); }, e.prototype.unselect = function (e) { const t = this.getCurrentData(); t.dateSelection && (this.dispatch({ type: 'UNSELECT_DATES' }), (function (e, t) { t.emitter.trigger('unselect', { jsEvent: e ? e.origEvent : null, view: t.viewApi || t.calendarApi.view }); }(e, t))); }, e.prototype.addEvent = function (e, t) { if (e instanceof zn) { const n = e._def; const r = e._instance; return this.getCurrentData().eventStore.defs[n.defId] || (this.dispatch({ type: 'ADD_EVENTS', eventStore: Pt({ def: n, instance: r }) }), this.triggerEventAdd(e)), e; } let o; const i = this.getCurrentData(); if (t instanceof L)o = t.internalEventSource; else if (typeof t === 'boolean')t && (o = Ue(i.eventSources)[0]); else if (t != null) { const a = this.getEventSourceById(t); if (!a) return console.warn(`Could not find an event source with ID "${t}"`), null; o = a.internalEventSource; } const s = qt(e, o, i, !1); if (s) { const l = new zn(i, s.def, s.def.recurringDef ? null : s.instance); return this.dispatch({ type: 'ADD_EVENTS', eventStore: Pt(s) }), this.triggerEventAdd(l), l; } return null; }, e.prototype.triggerEventAdd = function (e) { const t = this; this.getCurrentData().emitter.trigger('eventAdd', { event: e, relatedEvents: [], revert() { t.dispatch({ type: 'REMOVE_EVENTS', eventStore: Fn(e) }); } }); }, e.prototype.getEventById = function (e) { const t = this.getCurrentData(); const n = t.eventStore; const r = n.defs; const o = n.instances; for (const i in e = String(e), r) { const a = r[i]; if (a.publicId === e) { if (a.recurringDef) return new zn(t, a, null); for (const s in o) { const l = o[s]; if (l.defId === a.defId) return new zn(t, a, l); } } } return null; }, e.prototype.getEvents = function () { const e = this.getCurrentData(); return Bn(e.eventStore, e); }, e.prototype.removeAllEvents = function () { this.dispatch({ type: 'REMOVE_ALL_EVENTS' }); }, e.prototype.getEventSources = function () { const e = this.getCurrentData(); const t = e.eventSources; const n = []; for (const r in t)n.push(new L(e, t[r])); return n; }, e.prototype.getEventSourceById = function (e) { const t = this.getCurrentData(); const n = t.eventSources; for (const r in e = String(e), n) if (n[r].publicId === e) return new L(t, n[r]); return null; }, e.prototype.addEventSource = function (e) { const t = this.getCurrentData(); if (e instanceof L) return t.eventSources[e.internalEventSource.sourceId] || this.dispatch({ type: 'ADD_EVENT_SOURCES', sources: [e.internalEventSource] }), e; const n = Un(e, t); return n ? (this.dispatch({ type: 'ADD_EVENT_SOURCES', sources: [n] }), new L(t, n)) : null; }, e.prototype.removeAllEventSources = function () { this.dispatch({ type: 'REMOVE_ALL_EVENT_SOURCES' }); }, e.prototype.refetchEvents = function () { this.dispatch({ type: 'FETCH_EVENT_SOURCES' }); }, e.prototype.scrollToTime = function (e) { const t = Ye(e); t && this.trigger('_scrollRequest', { time: t }); }, e; }()); var zn = (function () {
    function e(e, t, n) { this._context = e, this._def = t, this._instance = n || null; } return e.prototype.setProp = function (e, t) { let n; let r; if (e in jt)console.warn("Could not set date-related prop 'name'. Use one of the date-related methods instead."); else if (e in Bt)t = Bt[e](t), this.mutate({ standardProps: (n = {}, n[e] = t, n) }); else if (e in Lt) { let o = Lt[e](t); e === 'color' ? o = { backgroundColor: t, borderColor: t } : e === 'editable' ? o = { startEditable: t, durationEditable: t } : ((r = {})[e] = t, o = r), this.mutate({ standardProps: { ui: o } }); } else console.warn(`Could not set prop '${e}'. Use setExtendedProp instead.`); }, e.prototype.setExtendedProp = function (e, t) { let n; this.mutate({ extendedProps: (n = {}, n[e] = t, n) }); }, e.prototype.setStart = function (e, t) { void 0 === t && (t = {}); const n = this._context.dateEnv; const r = n.createMarker(e); if (r && this._instance) { const o = Qt(this._instance.range.start, r, n, t.granularity); t.maintainDuration ? this.mutate({ datesDelta: o }) : this.mutate({ startDelta: o }); } }, e.prototype.setEnd = function (e, t) { void 0 === t && (t = {}); let n; const r = this._context.dateEnv; if ((e == null || (n = r.createMarker(e))) && this._instance) if (n) { const o = Qt(this._instance.range.end, n, r, t.granularity); this.mutate({ endDelta: o }); } else this.mutate({ standardProps: { hasEnd: !1 } }); }, e.prototype.setDates = function (e, t, n) { void 0 === n && (n = {}); let r; let o; let i; const a = this._context.dateEnv; const s = { allDay: n.allDay }; const l = a.createMarker(e); if (l && ((t == null || (r = a.createMarker(t))) && this._instance)) { let u = this._instance.range; !0 === n.allDay && (u = Kt(u)); const c = Qt(u.start, l, a, n.granularity); if (r) { const d = Qt(u.end, r, a, n.granularity); i = d, (o = c).years === i.years && o.months === i.months && o.days === i.days && o.milliseconds === i.milliseconds ? this.mutate({ datesDelta: c, standardProps: s }) : this.mutate({ startDelta: c, endDelta: d, standardProps: s }); } else s.hasEnd = !1, this.mutate({ datesDelta: c, standardProps: s }); } }, e.prototype.moveStart = function (e) { const t = Ye(e); t && this.mutate({ startDelta: t }); }, e.prototype.moveEnd = function (e) { const t = Ye(e); t && this.mutate({ endDelta: t }); }, e.prototype.moveDates = function (e) { const t = Ye(e); t && this.mutate({ datesDelta: t }); }, e.prototype.setAllDay = function (e, t) { void 0 === t && (t = {}); const n = { allDay: e }; let r = t.maintainDuration; r == null && (r = this._context.options.allDayMaintainDuration), this._def.allDay !== e && (n.hasEnd = r), this.mutate({ standardProps: n }); }, e.prototype.formatRange = function (e) { const t = this._context.dateEnv; const n = this._instance; const r = St(e); return this._def.hasEnd ? t.formatRange(n.range.start, n.range.end, r, { forcedStartTzo: n.forcedStartTzo, forcedEndTzo: n.forcedEndTzo }) : t.format(n.range.start, r, { forcedTzo: n.forcedStartTzo }); }, e.prototype.mutate = function (t) {
      const n = this._instance; if (n) {
        const r = this._def; const o = this._context; let i = Nt(o.getCurrentData().eventStore, n.instanceId); i = Pn(i, {
          '': {
            display: '', startEditable: !0, durationEditable: !0, constraints: [], overlap: null, allows: [], backgroundColor: '', borderColor: '', textColor: '', classNames: [],
          },
        }, t, o); const a = new e(o, r, n); this._def = i.defs[r.defId], this._instance = i.instances[n.instanceId], o.dispatch({ type: 'MERGE_EVENTS', eventStore: i }), o.emitter.trigger('eventChange', {
          oldEvent: a, event: this, relatedEvents: Bn(i, o, n), revert() { o.dispatch({ type: 'REMOVE_EVENTS', eventStore: i }); },
        });
      }
    }, e.prototype.remove = function () { const e = this._context; const t = Fn(this); e.dispatch({ type: 'REMOVE_EVENTS', eventStore: t }), e.emitter.trigger('eventRemove', { event: this, relatedEvents: [], revert() { e.dispatch({ type: 'MERGE_EVENTS', eventStore: t }); } }); }, Object.defineProperty(e.prototype, 'source', { get() { const e = this._def.sourceId; return e ? new L(this._context, this._context.getCurrentData().eventSources[e]) : null; }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, 'start', { get() { return this._instance ? this._context.dateEnv.toDate(this._instance.range.start) : null; }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, 'end', { get() { return this._instance && this._def.hasEnd ? this._context.dateEnv.toDate(this._instance.range.end) : null; }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, 'startStr', { get() { const e = this._instance; return e ? this._context.dateEnv.formatIso(e.range.start, { omitTime: this._def.allDay, forcedTzo: e.forcedStartTzo }) : ''; }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, 'endStr', { get() { const e = this._instance; return e && this._def.hasEnd ? this._context.dateEnv.formatIso(e.range.end, { omitTime: this._def.allDay, forcedTzo: e.forcedEndTzo }) : ''; }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, 'id', { get() { return this._def.publicId; }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, 'groupId', { get() { return this._def.groupId; }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, 'allDay', { get() { return this._def.allDay; }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, 'title', { get() { return this._def.title; }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, 'url', { get() { return this._def.url; }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, 'display', { get() { return this._def.ui.display || 'auto'; }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, 'startEditable', { get() { return this._def.ui.startEditable; }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, 'durationEditable', { get() { return this._def.ui.durationEditable; }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, 'constraint', { get() { return this._def.ui.constraints[0] || null; }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, 'overlap', { get() { return this._def.ui.overlap; }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, 'allow', { get() { return this._def.ui.allows[0] || null; }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, 'backgroundColor', { get() { return this._def.ui.backgroundColor; }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, 'borderColor', { get() { return this._def.ui.borderColor; }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, 'textColor', { get() { return this._def.ui.textColor; }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, 'classNames', { get() { return this._def.ui.classNames; }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, 'extendedProps', { get() { return this._def.extendedProps; }, enumerable: !1, configurable: !0 }), e.prototype.toPlainObject = function (e) { void 0 === e && (e = {}); const t = this._def; const n = t.ui; const o = this.startStr; const i = this.endStr; const a = {}; return t.title && (a.title = t.title), o && (a.start = o), i && (a.end = i), t.publicId && (a.id = t.publicId), t.groupId && (a.groupId = t.groupId), t.url && (a.url = t.url), n.display && n.display !== 'auto' && (a.display = n.display), e.collapseColor && n.backgroundColor && n.backgroundColor === n.borderColor ? a.color = n.backgroundColor : (n.backgroundColor && (a.backgroundColor = n.backgroundColor), n.borderColor && (a.borderColor = n.borderColor)), n.textColor && (a.textColor = n.textColor), n.classNames.length && (a.classNames = n.classNames), Object.keys(t.extendedProps).length && (e.collapseExtendedProps ? r(a, t.extendedProps) : a.extendedProps = t.extendedProps), a; }, e.prototype.toJSON = function () { return this.toPlainObject(); }, e;
  }()); function Fn(e) { let t; let n; const r = e._def; const o = e._instance; return { defs: (t = {}, t[r.defId] = r, t), instances: o ? (n = {}, n[o.instanceId] = o, n) : {} }; } function Bn(e, t, n) { const r = e.defs; const o = e.instances; const i = []; const a = n ? n.instanceId : ''; for (const s in o) { const l = o[s]; const u = r[l.defId]; l.instanceId !== a && i.push(new zn(t, u, l)); } return i; } const jn = {}; let Gn; const qn = (function () { function e() {} return e.prototype.getMarkerYear = function (e) { return e.getUTCFullYear(); }, e.prototype.getMarkerMonth = function (e) { return e.getUTCMonth(); }, e.prototype.getMarkerDay = function (e) { return e.getUTCDate(); }, e.prototype.arrayToMarker = function (e) { return Me(e); }, e.prototype.markerToArray = function (e) { return ke(e); }, e; }()); Gn = qn, jn.gregory = Gn; const Yn = /^\s*(\d{4})(-?(\d{2})(-?(\d{2})([T ](\d{2}):?(\d{2})(:?(\d{2})(\.(\d+))?)?(Z|(([-+])(\d{2})(:?(\d{2}))?))?)?)?)?$/; function Zn(e) { const t = Yn.exec(e); if (t) { const n = new Date(Date.UTC(Number(t[1]), t[3] ? Number(t[3]) - 1 : 0, Number(t[5] || 1), Number(t[7] || 0), Number(t[8] || 0), Number(t[10] || 0), t[12] ? 1e3 * Number(`0.${t[12]}`) : 0)); if (xe(n)) { let r = null; return t[13] && (r = (t[15] === '-' ? -1 : 1) * (60 * Number(t[16] || 0) + Number(t[18] || 0))), { marker: n, isTimeUnspecified: !t[6], timeZoneOffset: r }; } } return null; } const Xn = (function () { function e(e) { const t = this.timeZone = e.timeZone; const n = t !== 'local' && t !== 'UTC'; e.namedTimeZoneImpl && n && (this.namedTimeZoneImpl = new e.namedTimeZoneImpl(t)), this.canComputeOffset = Boolean(!n || this.namedTimeZoneImpl), this.calendarSystem = (function (e) { return new jn[e](); }(e.calendarSystem)), this.locale = e.locale, this.weekDow = e.locale.week.dow, this.weekDoy = e.locale.week.doy, e.weekNumberCalculation === 'ISO' && (this.weekDow = 1, this.weekDoy = 4), typeof e.firstDay === 'number' && (this.weekDow = e.firstDay), typeof e.weekNumberCalculation === 'function' && (this.weekNumberFunc = e.weekNumberCalculation), this.weekText = e.weekText != null ? e.weekText : e.locale.options.weekText, this.cmdFormatter = e.cmdFormatter, this.defaultSeparator = e.defaultSeparator; } return e.prototype.createMarker = function (e) { const t = this.createMarkerMeta(e); return t === null ? null : t.marker; }, e.prototype.createNowMarker = function () { return this.canComputeOffset ? this.timestampToMarker((new Date()).valueOf()) : Me(Re(new Date())); }, e.prototype.createMarkerMeta = function (e) { if (typeof e === 'string') return this.parse(e); let t = null; return typeof e === 'number' ? t = this.timestampToMarker(e) : e instanceof Date ? (e = e.valueOf(), isNaN(e) || (t = this.timestampToMarker(e))) : Array.isArray(e) && (t = Me(e)), t !== null && xe(t) ? { marker: t, isTimeUnspecified: !1, forcedTzo: null } : null; }, e.prototype.parse = function (e) { const t = Zn(e); if (t === null) return null; let n = t.marker; let r = null; return t.timeZoneOffset !== null && (this.canComputeOffset ? n = this.timestampToMarker(n.valueOf() - 60 * t.timeZoneOffset * 1e3) : r = t.timeZoneOffset), { marker: n, isTimeUnspecified: t.isTimeUnspecified, forcedTzo: r }; }, e.prototype.getYear = function (e) { return this.calendarSystem.getMarkerYear(e); }, e.prototype.getMonth = function (e) { return this.calendarSystem.getMarkerMonth(e); }, e.prototype.add = function (e, t) { const n = this.calendarSystem.markerToArray(e); return n[0] += t.years, n[1] += t.months, n[2] += t.days, n[6] += t.milliseconds, this.calendarSystem.arrayToMarker(n); }, e.prototype.subtract = function (e, t) { const n = this.calendarSystem.markerToArray(e); return n[0] -= t.years, n[1] -= t.months, n[2] -= t.days, n[6] -= t.milliseconds, this.calendarSystem.arrayToMarker(n); }, e.prototype.addYears = function (e, t) { const n = this.calendarSystem.markerToArray(e); return n[0] += t, this.calendarSystem.arrayToMarker(n); }, e.prototype.addMonths = function (e, t) { const n = this.calendarSystem.markerToArray(e); return n[1] += t, this.calendarSystem.arrayToMarker(n); }, e.prototype.diffWholeYears = function (e, t) { const n = this.calendarSystem; return _e(e) === _e(t) && n.getMarkerDay(e) === n.getMarkerDay(t) && n.getMarkerMonth(e) === n.getMarkerMonth(t) ? n.getMarkerYear(t) - n.getMarkerYear(e) : null; }, e.prototype.diffWholeMonths = function (e, t) { const n = this.calendarSystem; return _e(e) === _e(t) && n.getMarkerDay(e) === n.getMarkerDay(t) ? n.getMarkerMonth(t) - n.getMarkerMonth(e) + 12 * (n.getMarkerYear(t) - n.getMarkerYear(e)) : null; }, e.prototype.greatestWholeUnit = function (e, t) { let n = this.diffWholeYears(e, t); return n !== null ? { unit: 'year', value: n } : (n = this.diffWholeMonths(e, t)) !== null ? { unit: 'month', value: n } : (n = Se(e, t)) !== null ? { unit: 'week', value: n } : (n = De(e, t)) !== null ? { unit: 'day', value: n } : de(n = (function (e, t) { return (t.valueOf() - e.valueOf()) / 36e5; }(e, t))) ? { unit: 'hour', value: n } : de(n = (function (e, t) { return (t.valueOf() - e.valueOf()) / 6e4; }(e, t))) ? { unit: 'minute', value: n } : de(n = (function (e, t) { return (t.valueOf() - e.valueOf()) / 1e3; }(e, t))) ? { unit: 'second', value: n } : { unit: 'millisecond', value: t.valueOf() - e.valueOf() }; }, e.prototype.countDurationsBetween = function (e, t, n) { let r; return n.years && (r = this.diffWholeYears(e, t)) !== null ? r / (Je(n) / 365) : n.months && (r = this.diffWholeMonths(e, t)) !== null ? r / (function (e) { return Je(e) / 30; }(n)) : n.days && (r = De(e, t)) !== null ? r / Je(n) : (t.valueOf() - e.valueOf()) / $e(n); }, e.prototype.startOf = function (e, t) { return t === 'year' ? this.startOfYear(e) : t === 'month' ? this.startOfMonth(e) : t === 'week' ? this.startOfWeek(e) : t === 'day' ? be(e) : t === 'hour' ? (function (e) { return Me([e.getUTCFullYear(), e.getUTCMonth(), e.getUTCDate(), e.getUTCHours()]); }(e)) : t === 'minute' ? (function (e) { return Me([e.getUTCFullYear(), e.getUTCMonth(), e.getUTCDate(), e.getUTCHours(), e.getUTCMinutes()]); }(e)) : t === 'second' ? (function (e) { return Me([e.getUTCFullYear(), e.getUTCMonth(), e.getUTCDate(), e.getUTCHours(), e.getUTCMinutes(), e.getUTCSeconds()]); }(e)) : void 0; }, e.prototype.startOfYear = function (e) { return this.calendarSystem.arrayToMarker([this.calendarSystem.getMarkerYear(e)]); }, e.prototype.startOfMonth = function (e) { return this.calendarSystem.arrayToMarker([this.calendarSystem.getMarkerYear(e), this.calendarSystem.getMarkerMonth(e)]); }, e.prototype.startOfWeek = function (e) { return this.calendarSystem.arrayToMarker([this.calendarSystem.getMarkerYear(e), this.calendarSystem.getMarkerMonth(e), e.getUTCDate() - (e.getUTCDay() - this.weekDow + 7) % 7]); }, e.prototype.computeWeekNumber = function (e) { return this.weekNumberFunc ? this.weekNumberFunc(this.toDate(e)) : (function (e, t, n) { const r = e.getUTCFullYear(); const o = Ce(e, r, t, n); if (o < 1) return Ce(e, r - 1, t, n); const i = Ce(e, r + 1, t, n); return i >= 1 ? Math.min(o, i) : o; }(e, this.weekDow, this.weekDoy)); }, e.prototype.format = function (e, t, n) { return void 0 === n && (n = {}), t.format({ marker: e, timeZoneOffset: n.forcedTzo != null ? n.forcedTzo : this.offsetForMarker(e) }, this); }, e.prototype.formatRange = function (e, t, n, r) { return void 0 === r && (r = {}), r.isEndExclusive && (t = ge(t, -1)), n.formatRange({ marker: e, timeZoneOffset: r.forcedStartTzo != null ? r.forcedStartTzo : this.offsetForMarker(e) }, { marker: t, timeZoneOffset: r.forcedEndTzo != null ? r.forcedEndTzo : this.offsetForMarker(t) }, this, r.defaultSeparator); }, e.prototype.formatIso = function (e, t) { void 0 === t && (t = {}); let n = null; return t.omitTimeZoneOffset || (n = t.forcedTzo != null ? t.forcedTzo : this.offsetForMarker(e)), (function (e, t, n) { void 0 === n && (n = !1); let r = e.toISOString(); return r = r.replace('.000', ''), n && (r = r.replace('T00:00:00Z', '')), r.length > 10 && (t == null ? r = r.replace('Z', '') : t !== 0 && (r = r.replace('Z', rt(t, !0)))), r; }(e, n, t.omitTime)); }, e.prototype.timestampToMarker = function (e) { return this.timeZone === 'local' ? Me(Re(new Date(e))) : this.timeZone !== 'UTC' && this.namedTimeZoneImpl ? Me(this.namedTimeZoneImpl.timestampToArray(e)) : new Date(e); }, e.prototype.offsetForMarker = function (e) { return this.timeZone === 'local' ? -Te(ke(e)).getTimezoneOffset() : this.timeZone === 'UTC' ? 0 : this.namedTimeZoneImpl ? this.namedTimeZoneImpl.offsetForArray(ke(e)) : null; }, e.prototype.toDate = function (e, t) { return this.timeZone === 'local' ? Te(ke(e)) : this.timeZone === 'UTC' ? new Date(e.valueOf()) : this.namedTimeZoneImpl ? new Date(e.valueOf() - 1e3 * this.namedTimeZoneImpl.offsetForArray(ke(e)) * 60) : new Date(e.valueOf() - (t || 0)); }, e; }()); const Kn = []; const Jn = {
    code: 'en',
    week: { dow: 0, doy: 4 },
    direction: 'ltr',
    buttonText: {
      prev: 'prev', next: 'next', prevYear: 'prev year', nextYear: 'next year', year: 'year', today: 'today', month: 'month', week: 'week', day: 'day', list: 'list',
    },
    weekText: 'W',
    allDayText: 'all-day',
    moreLinkText: 'more',
    noEventsText: 'No events to display',
  }; function $n(e) { for (var t = e.length > 0 ? e[0].code : 'en', n = Kn.concat(e), r = { en: Jn }, o = 0, i = n; o < i.length; o++) { const a = i[o]; r[a.code] = a; } return { map: r, defaultCode: t }; } function Qn(e, t) { return typeof e !== 'object' || Array.isArray(e) ? (function (e, t) { const n = [].concat(e || []); const r = (function (e, t) { for (let n = 0; n < e.length; n++) for (let r = e[n].toLocaleLowerCase().split('-'), o = r.length; o > 0; o--) { const i = r.slice(0, o).join('-'); if (t[i]) return t[i]; } return null; }(n, t)) || Jn; return er(e, n, r); }(e, t)) : er(e.code, [e.code], e); } function er(e, t, n) {
    const r = Ne([Jn, n], ['buttonText']); delete r.code; const o = r.week; return delete r.week, {
      codeArg: e, codes: t, week: o, simpleNumberFormat: new Intl.NumberFormat(e), options: r,
    };
  } function tr(e) {
    const t = Qn(e.locale || 'en', $n([]).map); return new Xn({
      timeZone: bt.timeZone, calendarSystem: 'gregory', ...e, locale: t,
    });
  } let nr; const rr = {
    startTime: '09:00', endTime: '17:00', daysOfWeek: [1, 2, 3, 4, 5], display: 'inverse-background', classNames: 'fc-non-business', groupId: '_businessHours',
  }; function or(e, t) { return It((function (e) { let t; t = !0 === e ? [{}] : Array.isArray(e) ? e.filter(((e) => e.daysOfWeek)) : typeof e === 'object' && e ? [e] : []; return t = t.map(((e) => ({ ...rr, ...e }))); }(e)), null, t); } function ir(e, t) { return e.left >= t.left && e.left < t.right && e.top >= t.top && e.top < t.bottom; } function ar(e, t) {
    const n = {
      left: Math.max(e.left, t.left), right: Math.min(e.right, t.right), top: Math.max(e.top, t.top), bottom: Math.min(e.bottom, t.bottom),
    }; return n.left < n.right && n.top < n.bottom && n;
  } function sr(e, t) { return { left: Math.min(Math.max(e.left, t.left), t.right), top: Math.min(Math.max(e.top, t.top), t.bottom) }; } function lr(e) { return { left: (e.left + e.right) / 2, top: (e.top + e.bottom) / 2 }; } function ur(e, t) { return { left: e.left - t.left, top: e.top - t.top }; } function cr() { return nr == null && (nr = (function () { if (typeof document === 'undefined') return !0; const e = document.createElement('div'); e.style.position = 'absolute', e.style.top = '0px', e.style.left = '0px', e.innerHTML = '<table><tr><td><div></div></td></tr></table>', e.querySelector('table').style.height = '100px', e.querySelector('div').style.height = '100%', document.body.appendChild(e); const t = e.querySelector('div').offsetHeight > 0; return document.body.removeChild(e), t; }())), nr; } const dr = { defs: {}, instances: {} }; const pr = (function () {
    function e() { this.getKeysForEventDefs = it(this._getKeysForEventDefs), this.splitDateSelection = it(this._splitDateSpan), this.splitEventStore = it(this._splitEventStore), this.splitIndividualUi = it(this._splitIndividualUi), this.splitEventDrag = it(this._splitInteraction), this.splitEventResize = it(this._splitInteraction), this.eventUiBuilders = {}; } return e.prototype.splitProps = function (e) {
      const t = this; const n = this.getKeyInfo(e); const r = this.getKeysForEventDefs(e.eventStore); const o = this.splitDateSelection(e.dateSelection); const i = this.splitIndividualUi(e.eventUiBases, r); const a = this.splitEventStore(e.eventStore, r); const s = this.splitEventDrag(e.eventDrag); const l = this.splitEventResize(e.eventResize); const u = {}; for (const c in this.eventUiBuilders = Oe(n, ((e, n) => t.eventUiBuilders[n] || it(fr))), n) {
        const d = n[c]; const p = a[c] || dr; const f = this.eventUiBuilders[c]; u[c] = {
          businessHours: d.businessHours || e.businessHours, dateSelection: o[c] || null, eventStore: p, eventUiBases: f(e.eventUiBases[''], d.ui, i[c]), eventSelection: p.instances[e.eventSelection] ? e.eventSelection : '', eventDrag: s[c] || null, eventResize: l[c] || null,
        };
      } return u;
    }, e.prototype._splitDateSpan = function (e) { const t = {}; if (e) for (let n = 0, r = this.getKeysForDateSpan(e); n < r.length; n++) { t[r[n]] = e; } return t; }, e.prototype._getKeysForEventDefs = function (e) { const t = this; return Oe(e.defs, ((e) => t.getKeysForEventDef(e))); }, e.prototype._splitEventStore = function (e, t) { const n = e.defs; const r = e.instances; const o = {}; for (const i in n) for (let a = 0, s = t[i]; a < s.length; a++) { o[p = s[a]] || (o[p] = { defs: {}, instances: {} }), o[p].defs[i] = n[i]; } for (const l in r) for (let u = r[l], c = 0, d = t[u.defId]; c < d.length; c++) { var p; o[p = d[c]] && (o[p].instances[l] = u); } return o; }, e.prototype._splitIndividualUi = function (e, t) { const n = {}; for (const r in e) if (r) for (let o = 0, i = t[r]; o < i.length; o++) { const a = i[o]; n[a] || (n[a] = {}), n[a][r] = e[r]; } return n; }, e.prototype._splitInteraction = function (e) { const t = {}; if (e) { const n = this._splitEventStore(e.affectedEvents, this._getKeysForEventDefs(e.affectedEvents)); const r = this._getKeysForEventDefs(e.mutatedEvents); const o = this._splitEventStore(e.mutatedEvents, r); const i = function (r) { t[r] || (t[r] = { affectedEvents: n[r] || dr, mutatedEvents: o[r] || dr, isEvent: e.isEvent }); }; for (var a in n)i(a); for (var a in o)i(a); } return t; }, e;
  }()); function fr(e, t, n) { const o = []; e && o.push(e), t && o.push(t); const i = { '': Vt(o) }; return n && r(i, n), i; } function hr(e, t, n, r) {
    return {
      dow: e.getUTCDay(), isDisabled: Boolean(r && !sn(r.activeRange, e)), isOther: Boolean(r && !sn(r.currentRange, e)), isToday: Boolean(t && sn(t, e)), isPast: Boolean(n ? e < n : !!t && e < t.start), isFuture: Boolean(n ? e > n : !!t && e >= t.end),
    };
  } function vr(e, t) { const n = ['fc-day', `fc-day-${fe[e.dow]}`]; return e.isDisabled ? n.push('fc-day-disabled') : (e.isToday && (n.push('fc-day-today'), n.push(t.getClass('today'))), e.isPast && n.push('fc-day-past'), e.isFuture && n.push('fc-day-future'), e.isOther && n.push('fc-day-other')), n; } function gr(e, t) { return void 0 === t && (t = 'day'), JSON.stringify({ date: tt(e), type: t }); } let mr; let yr = null; function Er() {
    return yr === null && (yr = (function () {
      const e = document.createElement('div'); j(e, {
        position: 'absolute', top: -1e3, left: 0, border: 0, padding: 0, overflow: 'scroll', direction: 'rtl',
      }), e.innerHTML = '<div></div>', document.body.appendChild(e); const t = e.firstChild.getBoundingClientRect().left > e.getBoundingClientRect().left; return W(e), t;
    }())), yr;
  } function Sr() { return mr || (mr = (function () { const e = document.createElement('div'); e.style.overflow = 'scroll', document.body.appendChild(e); const t = Dr(e); return document.body.removeChild(e), t; }())), mr; } function Dr(e) { return { x: e.offsetHeight - e.clientHeight, y: e.offsetWidth - e.clientWidth }; } function br(e, t) {
    void 0 === t && (t = !1); const n = window.getComputedStyle(e); const r = parseInt(n.borderLeftWidth, 10) || 0; const o = parseInt(n.borderRightWidth, 10) || 0; const i = parseInt(n.borderTopWidth, 10) || 0; const a = parseInt(n.borderBottomWidth, 10) || 0; const s = Dr(e); const l = s.y - r - o; const u = {
      borderLeft: r, borderRight: o, borderTop: i, borderBottom: a, scrollbarBottom: s.x - i - a, scrollbarLeft: 0, scrollbarRight: 0,
    }; return Er() && n.direction === 'rtl' ? u.scrollbarLeft = l : u.scrollbarRight = l, t && (u.paddingLeft = parseInt(n.paddingLeft, 10) || 0, u.paddingRight = parseInt(n.paddingRight, 10) || 0, u.paddingTop = parseInt(n.paddingTop, 10) || 0, u.paddingBottom = parseInt(n.paddingBottom, 10) || 0), u;
  } function Cr(e, t, n) {
    void 0 === t && (t = !1); const r = n ? e.getBoundingClientRect() : wr(e); const o = br(e, t); const i = {
      left: r.left + o.borderLeft + o.scrollbarLeft, right: r.right - o.borderRight - o.scrollbarRight, top: r.top + o.borderTop, bottom: r.bottom - o.borderBottom - o.scrollbarBottom,
    }; return t && (i.left += o.paddingLeft, i.right -= o.paddingRight, i.top += o.paddingTop, i.bottom -= o.paddingBottom), i;
  } function wr(e) {
    const t = e.getBoundingClientRect(); return {
      left: t.left + window.pageXOffset, top: t.top + window.pageYOffset, right: t.right + window.pageXOffset, bottom: t.bottom + window.pageYOffset,
    };
  } function Rr(e) { for (var t = []; e instanceof HTMLElement;) { const n = window.getComputedStyle(e); if (n.position === 'fixed') break; /(auto|scroll)/.test(n.overflow + n.overflowY + n.overflowX) && t.push(e), e = e.parentNode; } return t; } function Tr(e, t, n) { let r = !1; const o = function () { r || (r = !0, t.apply(this, arguments)); }; const i = function () { r || (r = !0, n && n.apply(this, arguments)); }; const a = e(o, i); a && typeof a.then === 'function' && a.then(o, i); } const kr = (function () { function e() { this.handlers = {}, this.thisContext = null; } return e.prototype.setThisContext = function (e) { this.thisContext = e; }, e.prototype.setOptions = function (e) { this.options = e; }, e.prototype.on = function (e, t) { !(function (e, t, n) { (e[t] || (e[t] = [])).push(n); }(this.handlers, e, t)); }, e.prototype.off = function (e, t) { !(function (e, t, n) { n ? e[t] && (e[t] = e[t].filter(((e) => e !== n))) : delete e[t]; }(this.handlers, e, t)); }, e.prototype.trigger = function (e) { for (var t = [], n = 1; n < arguments.length; n++)t[n - 1] = arguments[n]; for (let r = this.handlers[e] || [], o = this.options && this.options[e], i = [].concat(o || [], r), a = 0, s = i; a < s.length; a++) { const l = s[a]; l.apply(this.thisContext, t); } }, e.prototype.hasHandlers = function (e) { return this.handlers[e] && this.handlers[e].length || this.options && this.options[e]; }, e; }()); const Mr = (function () { function e(e, t, n, r) { this.els = t; const o = this.originClientRect = e.getBoundingClientRect(); n && this.buildElHorizontals(o.left), r && this.buildElVerticals(o.top); } return e.prototype.buildElHorizontals = function (e) { for (var t = [], n = [], r = 0, o = this.els; r < o.length; r++) { const i = o[r].getBoundingClientRect(); t.push(i.left - e), n.push(i.right - e); } this.lefts = t, this.rights = n; }, e.prototype.buildElVerticals = function (e) { for (var t = [], n = [], r = 0, o = this.els; r < o.length; r++) { const i = o[r].getBoundingClientRect(); t.push(i.top - e), n.push(i.bottom - e); } this.tops = t, this.bottoms = n; }, e.prototype.leftToIndex = function (e) { let t; const n = this.lefts; const r = this.rights; const o = n.length; for (t = 0; t < o; t++) if (e >= n[t] && e < r[t]) return t; }, e.prototype.topToIndex = function (e) { let t; const n = this.tops; const r = this.bottoms; const o = n.length; for (t = 0; t < o; t++) if (e >= n[t] && e < r[t]) return t; }, e.prototype.getWidth = function (e) { return this.rights[e] - this.lefts[e]; }, e.prototype.getHeight = function (e) { return this.bottoms[e] - this.tops[e]; }, e; }()); const xr = (function () { function e() {} return e.prototype.getMaxScrollTop = function () { return this.getScrollHeight() - this.getClientHeight(); }, e.prototype.getMaxScrollLeft = function () { return this.getScrollWidth() - this.getClientWidth(); }, e.prototype.canScrollVertically = function () { return this.getMaxScrollTop() > 0; }, e.prototype.canScrollHorizontally = function () { return this.getMaxScrollLeft() > 0; }, e.prototype.canScrollUp = function () { return this.getScrollTop() > 0; }, e.prototype.canScrollDown = function () { return this.getScrollTop() < this.getMaxScrollTop(); }, e.prototype.canScrollLeft = function () { return this.getScrollLeft() > 0; }, e.prototype.canScrollRight = function () { return this.getScrollLeft() < this.getMaxScrollLeft(); }, e; }()); const _r = (function (e) { function t(t) { const n = e.call(this) || this; return n.el = t, n; } return n(t, e), t.prototype.getScrollTop = function () { return this.el.scrollTop; }, t.prototype.getScrollLeft = function () { return this.el.scrollLeft; }, t.prototype.setScrollTop = function (e) { this.el.scrollTop = e; }, t.prototype.setScrollLeft = function (e) { this.el.scrollLeft = e; }, t.prototype.getScrollWidth = function () { return this.el.scrollWidth; }, t.prototype.getScrollHeight = function () { return this.el.scrollHeight; }, t.prototype.getClientHeight = function () { return this.el.clientHeight; }, t.prototype.getClientWidth = function () { return this.el.clientWidth; }, t; }(xr)); const Ir = (function (e) { function t() { return e !== null && e.apply(this, arguments) || this; } return n(t, e), t.prototype.getScrollTop = function () { return window.pageYOffset; }, t.prototype.getScrollLeft = function () { return window.pageXOffset; }, t.prototype.setScrollTop = function (e) { window.scroll(window.pageXOffset, e); }, t.prototype.setScrollLeft = function (e) { window.scroll(e, window.pageYOffset); }, t.prototype.getScrollWidth = function () { return document.documentElement.scrollWidth; }, t.prototype.getScrollHeight = function () { return document.documentElement.scrollHeight; }, t.prototype.getClientHeight = function () { return document.documentElement.clientHeight; }, t.prototype.getClientWidth = function () { return document.documentElement.clientWidth; }, t; }(xr)); const Pr = (function () { function e(e) { this.iconOverrideOption && this.setIconOverride(e[this.iconOverrideOption]); } return e.prototype.setIconOverride = function (e) { let t; let n; if (typeof e === 'object' && e) { for (n in t = { ...this.iconClasses }, e)t[n] = this.applyIconOverridePrefix(e[n]); this.iconClasses = t; } else !1 === e && (this.iconClasses = {}); }, e.prototype.applyIconOverridePrefix = function (e) { const t = this.iconOverridePrefix; return t && e.indexOf(t) !== 0 && (e = t + e), e; }, e.prototype.getClass = function (e) { return this.classes[e] || ''; }, e.prototype.getIconClass = function (e, t) { let n; return (n = t && this.rtlIconClasses && this.rtlIconClasses[e] || this.iconClasses[e]) ? `${this.baseIconClass} ${n}` : ''; }, e.prototype.getCustomButtonIconClass = function (e) { let t; return this.iconOverrideCustomButtonOption && (t = e[this.iconOverrideCustomButtonOption]) ? `${this.baseIconClass} ${this.applyIconOverridePrefix(t)}` : ''; }, e; }()); if (Pr.prototype.classes = {}, Pr.prototype.iconClasses = {}, Pr.prototype.baseIconClass = '', Pr.prototype.iconOverridePrefix = '', typeof FullCalendarVDom === 'undefined') throw new Error('Please import the top-level fullcalendar lib before attempting to import a plugin.'); const Nr = FullCalendarVDom.Component; const Hr = FullCalendarVDom.createElement; const Or = FullCalendarVDom.render; const Ar = FullCalendarVDom.createRef; const Ur = FullCalendarVDom.Fragment; const Lr = FullCalendarVDom.createContext; const Wr = FullCalendarVDom.flushToDom; const Vr = (function () { function e(e, t, n) { const o = this; this.execFunc = e, this.emitter = t, this.scrollTime = n, this.handleScrollRequest = function (e) { o.queuedRequest = { ...o.queuedRequest || {}, ...e }, o.drain(); }, t.on('_scrollRequest', this.handleScrollRequest), this.fireInitialScroll(); } return e.prototype.detach = function () { this.emitter.off('_scrollRequest', this.handleScrollRequest); }, e.prototype.update = function (e) { e ? this.fireInitialScroll() : this.drain(); }, e.prototype.fireInitialScroll = function () { this.handleScrollRequest({ time: this.scrollTime }); }, e.prototype.drain = function () { this.queuedRequest && this.execFunc(this.queuedRequest) && (this.queuedRequest = null); }, e; }()); const zr = Lr({}); function Fr(e, t, n, r, o, i, a, s, l, u, c, d, p) {
    return {
      dateEnv: o, options: n, pluginHooks: a, emitter: u, dispatch: s, getCurrentData: l, calendarApi: c, viewSpec: e, viewApi: t, dateProfileGenerator: r, theme: i, isRtl: n.direction === 'rtl', addResizeHandler(e) { u.on('_resize', e); }, removeResizeHandler(e) { u.off('_resize', e); }, createScrollResponder(e) { return new Vr(e, u, Ye(n.scrollTime)); }, registerInteractiveComponent: d, unregisterInteractiveComponent: p,
    };
  } const Br = (function (e) { function t() { return e !== null && e.apply(this, arguments) || this; } return n(t, e), t.prototype.shouldComponentUpdate = function (e, t) { return this.debug && console.log(We(e, this.props), We(t, this.state)), !Ve(this.props, e, this.propEquality) || !Ve(this.state, t, this.stateEquality); }, t.addPropsEquality = Gr, t.addStateEquality = qr, t.contextType = zr, t; }(Nr)); Br.prototype.propEquality = {}, Br.prototype.stateEquality = {}; const jr = (function (e) { function t() { return e !== null && e.apply(this, arguments) || this; } return n(t, e), t.contextType = zr, t; }(Br)); function Gr(e) { const t = Object.create(this.prototype.propEquality); r(t, e), this.prototype.propEquality = t; } function qr(e) { const t = Object.create(this.prototype.stateEquality); r(t, e), this.prototype.stateEquality = t; } function Yr(e, t) { typeof e === 'function' ? e(t) : e && (e.current = t); } function Zr(e, t, n, r, o) { switch (t.type) { case 'RECEIVE_EVENTS': return (function (e, t, n, r, o, i) { if (t && n === t.latestFetchId) { let a = It((function (e, t, n) { const r = n.options.eventDataTransform; const o = t ? t.eventDataTransform : null; o && (e = Xr(e, o)); r && (e = Xr(e, r)); return e; }(o, t, i)), t, i); return r && (a = Be(a, r, i)), Ot(Kr(e, t.sourceId), a); } return e; }(e, n[t.sourceId], t.fetchId, t.fetchRange, t.rawEvents, o)); case 'ADD_EVENTS': return (function (e, t, n, r) { n && (t = Be(t, n, r)); return Ot(e, t); }(e, t.eventStore, r ? r.activeRange : null, o)); case 'MERGE_EVENTS': return Ot(e, t.eventStore); case 'PREV': case 'NEXT': case 'CHANGE_DATE': case 'CHANGE_VIEW_TYPE': return r ? Be(e, r.activeRange, o) : e; case 'REMOVE_EVENTS': return (function (e, t) { const n = e.defs; const r = e.instances; const o = {}; const i = {}; for (const a in n)t.defs[a] || (o[a] = n[a]); for (const s in r)!t.instances[s] && o[r[s].defId] && (i[s] = r[s]); return { defs: o, instances: i }; }(e, t.eventStore)); case 'REMOVE_EVENT_SOURCE': return Kr(e, t.sourceId); case 'REMOVE_ALL_EVENT_SOURCES': return At(e, ((e) => !e.sourceId)); case 'REMOVE_ALL_EVENTS': return { defs: {}, instances: {} }; default: return e; } } function Xr(e, t) { let n; if (t) { n = []; for (let r = 0, o = e; r < o.length; r++) { const i = o[r]; const a = t(i); a ? n.push(a) : a == null && n.push(i); } } else n = e; return n; } function Kr(e, t) { return At(e, ((e) => e.sourceId !== t)); } function Jr(e, t) { return $r({ eventDrag: e }, t); } function $r(e, t) {
    const n = t.getCurrentData(); const o = {
      businessHours: n.businessHours, dateSelection: '', eventStore: n.eventStore, eventUiBases: n.eventUiBases, eventSelection: '', eventDrag: null, eventResize: null, ...e,
    }; return (t.pluginHooks.isPropsValid || Qr)(o, t);
  } function Qr(e, t, n, o) { return void 0 === n && (n = {}), !(e.eventDrag && !(function (e, t, n, o) { const i = t.getCurrentData(); const a = e.eventDrag; const s = a.mutatedEvents; const l = s.defs; const u = s.instances; let c = pn(l, a.isEvent ? e.eventUiBases : { '': i.selectionConfig }); o && (c = Oe(c, o)); const d = (v = e.eventStore, g = a.affectedEvents.instances, { defs: v.defs, instances: He(v.instances, ((e) => !g[e.instanceId])) }); const p = d.defs; const f = d.instances; const h = pn(p, e.eventUiBases); let v; let g; for (const m in u) { const y = u[m]; const E = y.range; const S = c[y.defId]; const D = l[y.defId]; if (!eo(S.constraints, E, d, e.businessHours, t)) return !1; const b = t.options.eventOverlap; const C = typeof b === 'function' ? b : null; for (const w in f) { const R = f[w]; if (on(E, R.range)) { if (!1 === h[R.defId].overlap && a.isEvent) return !1; if (!1 === S.overlap) return !1; if (C && !C(new zn(t, p[R.defId], R), new zn(t, D, y))) return !1; } } for (let T = i.eventStore, k = 0, M = S.allows; k < M.length; k++) { const x = M[k]; const _ = { ...n, range: y.range, allDay: D.allDay }; const I = T.defs[D.defId]; const P = T.instances[m]; let N = void 0; if (N = I ? new zn(t, I, P) : new zn(t, D), !x(_n(_, t), N)) return !1; } } return !0; }(e, t, n, o))) && !(e.dateSelection && !(function (e, t, n, o) { const i = e.eventStore; const a = i.defs; const s = i.instances; const l = e.dateSelection; const u = l.range; let c = t.getCurrentData().selectionConfig; o && (c = o(c)); if (!eo(c.constraints, u, i, e.businessHours, t)) return !1; const d = t.options.selectOverlap; const p = typeof d === 'function' ? d : null; for (const f in s) { const h = s[f]; if (on(u, h.range)) { if (!1 === c.overlap) return !1; if (p && !p(new zn(t, a[h.defId], h), null)) return !1; } } for (let v = 0, g = c.allows; v < g.length; v++) { const m = g[v]; const y = { ...n, ...l }; if (!m(_n(y, t), null)) return !1; } return !0; }(e, t, n, o))); } function eo(e, t, n, r, o) { for (let i = 0, a = e; i < a.length; i++) { if (!ro(to(a[i], t, n, r, o), t)) return !1; } return !0; } function to(e, t, n, r, o) { return e === 'businessHours' ? no(Be(r, t, o)) : typeof e === 'string' ? no(At(n, ((t) => t.groupId === e))) : typeof e === 'object' && e ? no(Be(e, t, o)) : []; } function no(e) { const t = e.instances; const n = []; for (const r in t)n.push(t[r].range); return n; } function ro(e, t) { for (let n = 0, r = e; n < r.length; n++) { if (an(r[n], t)) return !0; } return !1; } const oo = (function (e) { function t() { const t = e !== null && e.apply(this, arguments) || this; return t.uid = $(), t; } return n(t, e), t.prototype.prepareHits = function () {}, t.prototype.queryHit = function (e, t, n, r) { return null; }, t.prototype.isInteractionValid = function (e) { const t = this.props.dateProfile; const n = e.mutatedEvents.instances; if (t) for (const r in n) if (!an(t.validRange, n[r].range)) return !1; return Jr(e, this.context); }, t.prototype.isDateSelectionValid = function (e) { let t; let n; const r = this.props.dateProfile; return !(r && !an(r.validRange, e.range)) && (t = e, n = this.context, $r({ dateSelection: t }, n)); }, t.prototype.isValidSegDownEl = function (e) { return !this.props.eventDrag && !this.props.eventResize && !V(e, '.fc-event-mirror') && (this.isPopover() || !this.isInPopover(e)); }, t.prototype.isValidDateDownEl = function (e) { return !(V(e, '.fc-event:not(.fc-bg-event)') || V(e, '.fc-daygrid-more-link') || V(e, 'a[data-navlink]') || this.isInPopover(e)); }, t.prototype.isPopover = function () { return !1; }, t.prototype.isInPopover = function (e) { return Boolean(V(e, '.fc-popover')); }, t; }(jr)); function io(e) {
    return {
      id: $(), deps: e.deps || [], reducers: e.reducers || [], contextInit: [].concat(e.contextInit || []), eventRefiners: e.eventRefiners || {}, eventDefMemberAdders: e.eventDefMemberAdders || [], eventSourceRefiners: e.eventSourceRefiners || {}, isDraggableTransformers: e.isDraggableTransformers || [], eventDragMutationMassagers: e.eventDragMutationMassagers || [], eventDefMutationAppliers: e.eventDefMutationAppliers || [], dateSelectionTransformers: e.dateSelectionTransformers || [], datePointTransforms: e.datePointTransforms || [], dateSpanTransforms: e.dateSpanTransforms || [], views: e.views || {}, viewPropsTransformers: e.viewPropsTransformers || [], isPropsValid: e.isPropsValid || null, externalDefTransforms: e.externalDefTransforms || [], eventResizeJoinTransforms: e.eventResizeJoinTransforms || [], viewContainerAppends: e.viewContainerAppends || [], eventDropTransformers: e.eventDropTransformers || [], componentInteractions: e.componentInteractions || [], calendarInteractions: e.calendarInteractions || [], themeClasses: e.themeClasses || {}, eventSourceDefs: e.eventSourceDefs || [], cmdFormatter: e.cmdFormatter, recurringTypes: e.recurringTypes || [], namedTimeZonedImpl: e.namedTimeZonedImpl, initialView: e.initialView || '', elementDraggingImpl: e.elementDraggingImpl, optionChangeHandlers: e.optionChangeHandlers || {}, scrollGridImpl: e.scrollGridImpl || null, contentTypeHandlers: e.contentTypeHandlers || {}, listenerRefiners: e.listenerRefiners || {}, optionRefiners: e.optionRefiners || {}, propSetHandlers: e.propSetHandlers || {},
    };
  } function ao() {
    let e; let t = []; let n = []; return function (o, i) {
      return e && ot(o, t) && ot(i, n) || (e = (function (e, t) {
        const n = {}; let o = {
          reducers: [], contextInit: [], eventRefiners: {}, eventDefMemberAdders: [], eventSourceRefiners: {}, isDraggableTransformers: [], eventDragMutationMassagers: [], eventDefMutationAppliers: [], dateSelectionTransformers: [], datePointTransforms: [], dateSpanTransforms: [], views: {}, viewPropsTransformers: [], isPropsValid: null, externalDefTransforms: [], eventResizeJoinTransforms: [], viewContainerAppends: [], eventDropTransformers: [], componentInteractions: [], calendarInteractions: [], themeClasses: {}, eventSourceDefs: [], cmdFormatter: null, recurringTypes: [], namedTimeZonedImpl: null, initialView: '', elementDraggingImpl: null, optionChangeHandlers: {}, scrollGridImpl: null, contentTypeHandlers: {}, listenerRefiners: {}, optionRefiners: {}, propSetHandlers: {},
        }; function i(e) {
          for (let t = 0, a = e; t < a.length; t++) {
            const s = a[t]; n[s.id] || (n[s.id] = !0, i(s.deps), u = s, o = {
              reducers: (l = o).reducers.concat(u.reducers), contextInit: l.contextInit.concat(u.contextInit), eventRefiners: { ...l.eventRefiners, ...u.eventRefiners }, eventDefMemberAdders: l.eventDefMemberAdders.concat(u.eventDefMemberAdders), eventSourceRefiners: { ...l.eventSourceRefiners, ...u.eventSourceRefiners }, isDraggableTransformers: l.isDraggableTransformers.concat(u.isDraggableTransformers), eventDragMutationMassagers: l.eventDragMutationMassagers.concat(u.eventDragMutationMassagers), eventDefMutationAppliers: l.eventDefMutationAppliers.concat(u.eventDefMutationAppliers), dateSelectionTransformers: l.dateSelectionTransformers.concat(u.dateSelectionTransformers), datePointTransforms: l.datePointTransforms.concat(u.datePointTransforms), dateSpanTransforms: l.dateSpanTransforms.concat(u.dateSpanTransforms), views: { ...l.views, ...u.views }, viewPropsTransformers: l.viewPropsTransformers.concat(u.viewPropsTransformers), isPropsValid: u.isPropsValid || l.isPropsValid, externalDefTransforms: l.externalDefTransforms.concat(u.externalDefTransforms), eventResizeJoinTransforms: l.eventResizeJoinTransforms.concat(u.eventResizeJoinTransforms), viewContainerAppends: l.viewContainerAppends.concat(u.viewContainerAppends), eventDropTransformers: l.eventDropTransformers.concat(u.eventDropTransformers), calendarInteractions: l.calendarInteractions.concat(u.calendarInteractions), componentInteractions: l.componentInteractions.concat(u.componentInteractions), themeClasses: { ...l.themeClasses, ...u.themeClasses }, eventSourceDefs: l.eventSourceDefs.concat(u.eventSourceDefs), cmdFormatter: u.cmdFormatter || l.cmdFormatter, recurringTypes: l.recurringTypes.concat(u.recurringTypes), namedTimeZonedImpl: u.namedTimeZonedImpl || l.namedTimeZonedImpl, initialView: l.initialView || u.initialView, elementDraggingImpl: l.elementDraggingImpl || u.elementDraggingImpl, optionChangeHandlers: { ...l.optionChangeHandlers, ...u.optionChangeHandlers }, scrollGridImpl: u.scrollGridImpl || l.scrollGridImpl, contentTypeHandlers: { ...l.contentTypeHandlers, ...u.contentTypeHandlers }, listenerRefiners: { ...l.listenerRefiners, ...u.listenerRefiners }, optionRefiners: { ...l.optionRefiners, ...u.optionRefiners }, propSetHandlers: { ...l.propSetHandlers, ...u.propSetHandlers },
            });
          } let l; let u;
        } return e && i(e), i(t), o;
      }(o, i))), t = o, n = i, e;
    };
  } const so = (function (e) { function t() { return e !== null && e.apply(this, arguments) || this; } return n(t, e), t; }(Pr)); function lo(e, t, n, o) {
    if (t[e]) return t[e]; const i = (function (e, t, n, o) {
      const i = n[e]; const a = o[e]; const s = function (e) { return i && i[e] !== null ? i[e] : a && a[e] !== null ? a[e] : null; }; let l = s('component'); const u = s('superType'); let c = null; if (u) { if (u === e) throw new Error("Can't have a custom view type that references itself"); c = lo(u, t, n, o); }!l && c && (l = c.component); if (!l) return null; return {
        type: e, component: l, defaults: { ...(c ? c.defaults : {}), ...(i ? i.rawOptions : {}) }, overrides: { ...(c ? c.overrides : {}), ...(a ? a.rawOptions : {}) },
      };
    }(e, t, n, o)); return i && (t[e] = i), i;
  }so.prototype.classes = {
    root: 'fc-theme-standard', tableCellShaded: 'fc-cell-shaded', buttonGroup: 'fc-button-group', button: 'fc-button fc-button-primary', buttonActive: 'fc-button-active',
  }, so.prototype.baseIconClass = 'fc-icon', so.prototype.iconClasses = {
    close: 'fc-icon-x', prev: 'fc-icon-chevron-left', next: 'fc-icon-chevron-right', prevYear: 'fc-icon-chevrons-left', nextYear: 'fc-icon-chevrons-right',
  }, so.prototype.rtlIconClasses = {
    prev: 'fc-icon-chevron-right', next: 'fc-icon-chevron-left', prevYear: 'fc-icon-chevrons-right', nextYear: 'fc-icon-chevrons-left',
  }, so.prototype.iconOverrideOption = 'buttonIcons', so.prototype.iconOverrideCustomButtonOption = 'icon', so.prototype.iconOverridePrefix = 'fc-icon-'; const uo = (function (e) {
    function t() { const t = e !== null && e.apply(this, arguments) || this; return t.rootElRef = Ar(), t.handleRootEl = function (e) { Yr(t.rootElRef, e), t.props.elRef && Yr(t.props.elRef, e); }, t; } return n(t, e), t.prototype.render = function () {
      const e = this; const t = this.props; const n = t.hookProps; return Hr(ho, {
        hookProps: n, didMount: t.didMount, willUnmount: t.willUnmount, elRef: this.handleRootEl,
      }, ((r) => Hr(po, {
        hookProps: n, content: t.content, defaultContent: t.defaultContent, backupElRef: e.rootElRef,
      }, ((e, o) => t.children(r, go(t.classNames, n), e, o)))));
    }, t;
  }(jr)); const co = Lr(0); function po(e) { return Hr(co.Consumer, null, ((t) => Hr(fo, { renderId: t, ...e }))); } var fo = (function (e) { function t() { const t = e !== null && e.apply(this, arguments) || this; return t.innerElRef = Ar(), t; } return n(t, e), t.prototype.render = function () { return this.props.children(this.innerElRef, this.renderInnerContent()); }, t.prototype.componentDidMount = function () { this.updateCustomContent(); }, t.prototype.componentDidUpdate = function () { this.updateCustomContent(); }, t.prototype.renderInnerContent = function () { const e = this.context.pluginHooks.contentTypeHandlers; const t = this.props; let n = this.customContentInfo; let r = mo(t.content, t.hookProps); let o = null; if (void 0 === r && (r = mo(t.defaultContent, t.hookProps)), void 0 !== r) { if (n)n.contentVal = r[n.contentKey]; else if (typeof r === 'object') for (const i in e) if (void 0 !== r[i]) { n = this.customContentInfo = { contentKey: i, contentVal: r[i], handler: e[i]() }; break; }o = n ? [] : r; } return o; }, t.prototype.updateCustomContent = function () { this.customContentInfo && this.customContentInfo.handler(this.innerElRef.current || this.props.backupElRef.current, this.customContentInfo.contentVal); }, t; }(jr)); var ho = (function (e) { function t() { const t = e !== null && e.apply(this, arguments) || this; return t.handleRootEl = function (e) { t.rootEl = e, t.props.elRef && Yr(t.props.elRef, e); }, t; } return n(t, e), t.prototype.render = function () { return this.props.children(this.handleRootEl); }, t.prototype.componentDidMount = function () { const e = this.props.didMount; e && e({ ...this.props.hookProps, el: this.rootEl }); }, t.prototype.componentWillUnmount = function () { const e = this.props.willUnmount; e && e({ ...this.props.hookProps, el: this.rootEl }); }, t; }(jr)); function vo() { let e; let t; let n = []; return function (r, o) { return t && Le(t, o) && r === e || (e = r, t = o, n = go(r, o)), n; }; } function go(e, t) { return typeof e === 'function' && (e = e(t)), Ut(e); } function mo(e, t) { return typeof e === 'function' ? e(t, Hr) : e; } const yo = (function (e) {
    function t() { const t = e !== null && e.apply(this, arguments) || this; return t.normalizeClassNames = vo(), t; } return n(t, e), t.prototype.render = function () {
      const e = this.props; const t = this.context; const n = t.options; const r = { view: t.viewApi }; const o = this.normalizeClassNames(n.viewClassNames, r); return Hr(ho, {
        hookProps: r, didMount: n.viewDidMount, willUnmount: n.viewWillUnmount, elRef: e.elRef,
      }, ((t) => e.children(t, [`fc-${e.viewSpec.type}-view`, 'fc-view'].concat(o))));
    }, t;
  }(jr)); function Eo(e) { return Oe(e, So); } function So(e) {
    let t; const n = typeof e === 'function' ? { component: e } : e; let o = n.component; return n.content && (t = n, o = function (e) {
      return Hr(zr.Consumer, null, ((n) => Hr(yo, { viewSpec: n.viewSpec }, ((o, i) => {
        const a = { ...e, nextDayThreshold: n.options.nextDayThreshold }; return Hr(uo, {
          hookProps: a, classNames: t.classNames, content: t.content, didMount: t.didMount, willUnmount: t.willUnmount, elRef: o,
        }, ((e, t, n, r) => Hr('div', { className: i.concat(t).join(' '), ref: e }, r)));
      }))));
    }), { superType: n.type, component: o, rawOptions: n };
  } function Do(e, t, n, o) {
    const i = Eo(e); const a = Eo(t.views); return Oe((function (e, t) { let n; const r = {}; for (n in e)lo(n, r, e, t); for (n in t)lo(n, r, e, t); return r; }(i, a)), ((e) => (function (e, t, n, o, i) {
      const a = e.overrides.duration || e.defaults.duration || o.duration || n.duration; let s = null; let l = ''; let u = ''; let c = {}; if (a && (s = (function (e) { const t = JSON.stringify(e); let n = bo[t]; void 0 === n && (n = Ye(e), bo[t] = n); return n; }(a)))) { const d = et(s); l = d.unit, d.value === 1 && (u = l, c = t[l] ? t[l].rawOptions : {}); } const p = function (t) { const n = t.buttonText || {}; const r = e.defaults.buttonTextKey; return r != null && n[r] != null ? n[r] : n[e.type] != null ? n[e.type] : n[u] != null ? n[u] : void 0; }; return {
        type: e.type, component: e.component, duration: s, durationUnit: l, singleUnit: u, optionDefaults: e.defaults, optionOverrides: { ...c, ...e.overrides }, buttonTextOverride: p(o) || p(n) || e.overrides.buttonText, buttonTextDefault: p(i) || e.defaults.buttonText || p(bt) || e.type,
      };
    }(e, a, t, n, o))));
  } var bo = {}; const Co = (function () {
    function e(e) { this.props = e, this.nowDate = Wn(e.nowInput, e.dateEnv), this.initHiddenDays(); } return e.prototype.buildPrev = function (e, t, n) { const r = this.props.dateEnv; const o = r.subtract(r.startOf(t, e.currentRangeUnit), e.dateIncrement); return this.build(o, -1, n); }, e.prototype.buildNext = function (e, t, n) { const r = this.props.dateEnv; const o = r.add(r.startOf(t, e.currentRangeUnit), e.dateIncrement); return this.build(o, 1, n); }, e.prototype.build = function (e, t, n) {
      void 0 === n && (n = !0); let r; let o; let i; let a; let s; let l; let u; let c; const d = this.props; return r = this.buildValidRange(), r = this.trimHiddenDays(r), n && (u = e, e = (c = r).start != null && u < c.start ? c.start : c.end != null && u >= c.end ? new Date(c.end.valueOf() - 1) : u), o = this.buildCurrentRangeInfo(e, t), i = /^(year|month|week|day)$/.test(o.unit), a = this.buildRenderRange(this.trimHiddenDays(o.range), o.unit, i), s = a = this.trimHiddenDays(a), d.showNonCurrentDates || (s = nn(s, o.range)), s = nn(s = this.adjustActiveRange(s), r), l = on(o.range, r), {
        validRange: r, currentRange: o.range, currentRangeUnit: o.unit, isRangeAllDay: i, activeRange: s, renderRange: a, slotMinTime: d.slotMinTime, slotMaxTime: d.slotMaxTime, isValid: l, dateIncrement: this.buildDateIncrement(o.duration),
      };
    }, e.prototype.buildValidRange = function () { const e = this.props.validRangeInput; const t = typeof e === 'function' ? e.call(this.props.calendarApi, this.nowDate) : e; return this.refineRange(t) || { start: null, end: null }; }, e.prototype.buildCurrentRangeInfo = function (e, t) { let n; const r = this.props; let o = null; let i = null; let a = null; return r.duration ? (o = r.duration, i = r.durationUnit, a = this.buildRangeFromDuration(e, t, o, i)) : (n = this.props.dayCount) ? (i = 'day', a = this.buildRangeFromDayCount(e, t, n)) : (a = this.buildCustomVisibleRange(e)) ? i = r.dateEnv.greatestWholeUnit(a.start, a.end).unit : (i = et(o = this.getFallbackDuration()).unit, a = this.buildRangeFromDuration(e, t, o, i)), { duration: o, unit: i, range: a }; }, e.prototype.getFallbackDuration = function () { return Ye({ day: 1 }); }, e.prototype.adjustActiveRange = function (e) { const t = this.props; const n = t.dateEnv; const r = t.usesMinMaxTime; const o = t.slotMinTime; const i = t.slotMaxTime; let a = e.start; let s = e.end; return r && (Je(o) < 0 && (a = be(a), a = n.add(a, o)), Je(i) > 1 && (s = ve(s = be(s), -1), s = n.add(s, i))), { start: a, end: s }; }, e.prototype.buildRangeFromDuration = function (e, t, n, r) { let o; let i; let a; const s = this.props; const l = s.dateEnv; let u = s.dateAlignment; if (!u) { const c = this.props.dateIncrement; u = c && $e(c) < $e(n) ? et(c).unit : r; } function d() { o = l.startOf(e, u), i = l.add(o, n), a = { start: o, end: i }; } return Je(n) <= 1 && this.isHiddenDay(o) && (o = be(o = this.skipHiddenDays(o, t))), d(), this.trimHiddenDays(a) || (e = this.skipHiddenDays(e, t), d()), a; }, e.prototype.buildRangeFromDayCount = function (e, t, n) { let r; const o = this.props; const i = o.dateEnv; const a = o.dateAlignment; let s = 0; let l = e; a && (l = i.startOf(l, a)), l = be(l), r = l = this.skipHiddenDays(l, t); do { r = ve(r, 1), this.isHiddenDay(r) || s++; } while (s < n); return { start: l, end: r }; }, e.prototype.buildCustomVisibleRange = function (e) { const t = this.props; const n = t.visibleRangeInput; const r = typeof n === 'function' ? n.call(t.calendarApi, t.dateEnv.toDate(e)) : n; const o = this.refineRange(r); return !o || o.start != null && o.end != null ? o : null; }, e.prototype.buildRenderRange = function (e, t, n) { return e; }, e.prototype.buildDateIncrement = function (e) { let t; const n = this.props.dateIncrement; return n || ((t = this.props.dateAlignment) ? Ye(1, t) : e || Ye({ days: 1 })); }, e.prototype.refineRange = function (e) { if (e) { let t = (n = e, r = this.props.dateEnv, o = null, i = null, n.start && (o = r.createMarker(n.start)), n.end && (i = r.createMarker(n.end)), o || i ? o && i && i < o ? null : { start: o, end: i } : null); return t && (t = Jt(t)), t; } let n; let r; let o; let i; return null; }, e.prototype.initHiddenDays = function () { let e; const t = this.props.hiddenDays || []; const n = []; let r = 0; for (!1 === this.props.weekends && t.push(0, 6), e = 0; e < 7; e++)(n[e] = t.indexOf(e) !== -1) || r++; if (!r) throw new Error('invalid hiddenDays'); this.isHiddenDayHash = n; }, e.prototype.trimHiddenDays = function (e) { let t = e.start; let n = e.end; return t && (t = this.skipHiddenDays(t)), n && (n = this.skipHiddenDays(n, -1, !0)), t == null || n == null || t < n ? { start: t, end: n } : null; }, e.prototype.isHiddenDay = function (e) { return e instanceof Date && (e = e.getUTCDay()), this.isHiddenDayHash[e]; }, e.prototype.skipHiddenDays = function (e, t, n) { for (void 0 === t && (t = 1), void 0 === n && (n = !1); this.isHiddenDayHash[(e.getUTCDay() + (n ? t : 0) + 7) % 7];)e = ve(e, t); return e; }, e;
  }()); function wo(e, t, n) { const r = t ? t.activeRange : null; return ko({}, (function (e, t) { const n = Ln(t); const r = [].concat(e.eventSources || []); const o = []; e.initialEvents && r.unshift(e.initialEvents); e.events && r.unshift(e.events); for (let i = 0, a = r; i < a.length; i++) { const s = Un(a[i], t, n); s && o.push(s); } return o; }(e, n)), r, n); } function Ro(e, t, n, o) { let i; let a; const s = n ? n.activeRange : null; switch (t.type) { case 'ADD_EVENT_SOURCES': return ko(e, t.sources, s, o); case 'REMOVE_EVENT_SOURCE': return i = e, a = t.sourceId, He(i, ((e) => e.sourceId !== a)); case 'PREV': case 'NEXT': case 'CHANGE_DATE': case 'CHANGE_VIEW_TYPE': return n ? Mo(e, s, o) : e; case 'FETCH_EVENT_SOURCES': return xo(e, t.sourceIds ? Ae(t.sourceIds) : Io(e, o), s, o); case 'RECEIVE_EVENTS': case 'RECEIVE_EVENT_ERROR': return (function (e, t, n, o) { let i; const a = e[t]; if (a && n === a.latestFetchId) return { ...e, ...((i = {})[t] = { ...a, isFetching: !1, fetchRange: o }, i) }; return e; }(e, t.sourceId, t.fetchId, t.fetchRange)); case 'REMOVE_ALL_EVENT_SOURCES': return {}; default: return e; } } function To(e) { let t = 0; for (const n in e)e[n].isFetching && t++; return t; } function ko(e, t, n, o) { for (var i = {}, a = 0, s = t; a < s.length; a++) { const l = s[a]; i[l.sourceId] = l; } return n && (i = Mo(i, n, o)), ({ ...e, ...i }); } function Mo(e, t, n) { return xo(e, He(e, ((e) => (function (e, t, n) { return Po(e, n) ? !n.options.lazyFetching || !e.fetchRange || e.isFetching || t.start < e.fetchRange.start || t.end > e.fetchRange.end : !e.latestFetchId; }(e, t, n)))), t, n); } function xo(e, t, n, r) { const o = {}; for (const i in e) { const a = e[i]; t[i] ? o[i] = _o(a, n, r) : o[i] = a; } return o; } function _o(e, t, n) {
    const o = n.options; const i = n.calendarApi; const a = n.pluginHooks.eventSourceDefs[e.sourceDefId]; const s = $(); return a.fetch({ eventSource: e, range: t, context: n }, ((r) => {
      let a = r.rawEvents; o.eventSourceSuccess && (a = o.eventSourceSuccess.call(i, a, r.xhr) || a), e.success && (a = e.success.call(i, a, r.xhr) || a), n.dispatch({
        type: 'RECEIVE_EVENTS', sourceId: e.sourceId, fetchId: s, fetchRange: t, rawEvents: a,
      });
    }), ((r) => {
      console.warn(r.message, r), o.eventSourceFailure && o.eventSourceFailure.call(i, r), e.failure && e.failure(r), n.dispatch({
        type: 'RECEIVE_EVENT_ERROR', sourceId: e.sourceId, fetchId: s, fetchRange: t, error: r,
      });
    })), ({ ...e, isFetching: !0, latestFetchId: s });
  } function Io(e, t) { return He(e, ((e) => Po(e, t))); } function Po(e, t) { return !t.pluginHooks.eventSourceDefs[e.sourceDefId].ignoreRange; } function No(e, t) { switch (t.type) { case 'UNSELECT_DATES': return null; case 'SELECT_DATES': return t.selection; default: return e; } } function Ho(e, t) { switch (t.type) { case 'UNSELECT_EVENT': return ''; case 'SELECT_EVENT': return t.eventInstanceId; default: return e; } } function Oo(e, t) { let n; switch (t.type) { case 'UNSET_EVENT_DRAG': return null; case 'SET_EVENT_DRAG': return { affectedEvents: (n = t.state).affectedEvents, mutatedEvents: n.mutatedEvents, isEvent: n.isEvent }; default: return e; } } function Ao(e, t) { let n; switch (t.type) { case 'UNSET_EVENT_RESIZE': return null; case 'SET_EVENT_RESIZE': return { affectedEvents: (n = t.state).affectedEvents, mutatedEvents: n.mutatedEvents, isEvent: n.isEvent }; default: return e; } } function Uo(e, t, n, r, o) { const i = []; return { headerToolbar: e.headerToolbar ? Lo(e.headerToolbar, e, t, n, r, o, i) : null, footerToolbar: e.footerToolbar ? Lo(e.footerToolbar, e, t, n, r, o, i) : null, viewsWithButtons: i }; } function Lo(e, t, n, r, o, i, a) {
    return Oe(e, ((e) => (function (e, t, n, r, o, i, a) {
      const s = t.direction === 'rtl'; const l = t.customButtons || {}; const u = n.buttonText || {}; const c = t.buttonText || {}; return (e ? e.split(' ') : []).map(((e) => e.split(',').map(((e) => {
        if (e === 'title') return { buttonName: e }; let t; let n = void 0; let d = void 0; let p = void 0; let f = void 0; return (t = l[e]) ? (d = function (e) { t.click && t.click.call(e.target, e, e.target); }, (p = r.getCustomButtonIconClass(t)) || (p = r.getIconClass(e, s)) || (f = t.text)) : (n = o[e]) ? (a.push(e), d = function () { i.changeView(e); }, (f = n.buttonTextOverride) || (p = r.getIconClass(e, s)) || (f = n.buttonTextDefault)) : i[e] && (d = function () { i[e](); }, (f = u[e]) || (p = r.getIconClass(e, s)) || (f = c[e])), {
          buttonName: e, buttonClick: d, buttonIcon: p, buttonText: f,
        };
      }))));
    }(e, t, n, r, o, i, a))));
  } function Wo(e, t, n, r, o) { let i = null; (e = e.toUpperCase()) === 'GET' ? t = (function (e, t) { return e + (e.indexOf('?') === -1 ? '?' : '&') + Vo(t); }(t, n)) : i = Vo(n); const a = new XMLHttpRequest(); a.open(e, t, !0), e !== 'GET' && a.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded'), a.onload = function () { if (a.status >= 200 && a.status < 400) { let e = !1; let t = void 0; try { t = JSON.parse(a.responseText), e = !0; } catch (e) {}e ? r(t, a) : o('Failure parsing JSON', a); } else o('Request failed', a); }, a.onerror = function () { o('Request failed', a); }, a.send(i); } function Vo(e) { const t = []; for (const n in e)t.push(`${encodeURIComponent(n)}=${encodeURIComponent(e[n])}`); return t.join('&'); } function zo(e, t) { for (var n = Ue(t.getCurrentData().eventSources), r = [], o = 0, i = e; o < i.length; o++) { for (var a = i[o], s = !1, l = 0; l < n.length; l++) if (n[l]._raw === a) { n.splice(l, 1), s = !0; break; }s || r.push(a); } for (let u = 0, c = n; u < c.length; u++) { const d = c[u]; t.dispatch({ type: 'REMOVE_EVENT_SOURCE', sourceId: d.sourceId }); } for (let p = 0, f = r; p < f.length; p++) { const h = f[p]; t.calendarApi.addEventSource(h); } } const Fo = [io({ eventSourceDefs: [{ ignoreRange: !0, parseMeta(e) { return Array.isArray(e.events) ? e.events : null; }, fetch(e, t) { t({ rawEvents: e.eventSource.meta }); } }] }), io({ eventSourceDefs: [{ parseMeta(e) { return typeof e.events === 'function' ? e.events : null; }, fetch(e, t, n) { const r = e.context.dateEnv; Tr(e.eventSource.meta.bind(null, Tn(e.range, r)), ((e) => { t({ rawEvents: e }); }), n); } }] }), io({
    eventSourceRefiners: {
      method: String, extraParams: _t, startParam: String, endParam: String, timeZoneParam: String,
    },
    eventSourceDefs: [{
      parseMeta(e) {
        return e.url ? {
          url: e.url, method: (e.method || 'GET').toUpperCase(), extraParams: e.extraParams, startParam: e.startParam, endParam: e.endParam, timeZoneParam: e.timeZoneParam,
        } : null;
      },
      fetch(e, t, n) { const o = e.eventSource.meta; const i = (function (e, t, n) { let o; let i; let a; let s; const l = n.dateEnv; const u = n.options; const c = {}; (o = e.startParam) == null && (o = u.startParam); (i = e.endParam) == null && (i = u.endParam); (a = e.timeZoneParam) == null && (a = u.timeZoneParam); s = typeof e.extraParams === 'function' ? e.extraParams() : e.extraParams || {}; r(c, s), c[o] = l.formatIso(t.start), c[i] = l.formatIso(t.end), l.timeZone !== 'local' && (c[a] = l.timeZone); return c; }(o, e.range, e.context)); Wo(o.method, o.url, i, ((e, n) => { t({ rawEvents: e, xhr: n }); }), ((e, t) => { n({ message: e, xhr: t }); })); },
    }],
  }), io({
    recurringTypes: [{
      parse(e, t) {
        if (e.daysOfWeek || e.startTime || e.endTime || e.startRecur || e.endRecur) {
          const n = {
            daysOfWeek: e.daysOfWeek || null, startTime: e.startTime || null, endTime: e.endTime || null, startRecur: e.startRecur ? t.createMarker(e.startRecur) : null, endRecur: e.endRecur ? t.createMarker(e.endRecur) : null,
          }; let r = void 0; return e.duration && (r = e.duration), !r && e.startTime && e.endTime && (o = e.endTime, i = e.startTime, r = {
            years: o.years - i.years, months: o.months - i.months, days: o.days - i.days, milliseconds: o.milliseconds - i.milliseconds,
          }), { allDayGuess: Boolean(!e.startTime && !e.endTime), duration: r, typeData: n };
        } let o; let i; return null;
      },
      expand(e, t, n) { const r = nn(t, { start: e.startRecur, end: e.endRecur }); return r ? (function (e, t, n, r) { const o = e ? Ae(e) : null; let i = be(n.start); const a = n.end; const s = []; for (;i < a;) { let l = void 0; o && !o[i.getUTCDay()] || (l = t ? r.add(i, t) : i, s.push(l)), i = ve(i, 1); } return s; }(e.daysOfWeek, e.startTime, r, n)) : []; },
    }],
    eventRefiners: {
      daysOfWeek: _t, startTime: Ye, endTime: Ye, duration: Ye, startRecur: _t, endRecur: _t,
    },
  }), io({ optionChangeHandlers: { events(e, t) { zo([e], t); }, eventSources: zo } }), io({ contentTypeHandlers: { html() { return Bo; }, domNodes() { return jo; } }, propSetHandlers: { dateProfile(e, t) { t.emitter.trigger('datesSet', { ...Tn(e.activeRange, t.dateEnv), view: t.viewApi }); }, eventStore(e, t) { const n = t.emitter; n.hasHandlers('eventsSet') && n.trigger('eventsSet', Bn(e, t)); } } })]; function Bo(e, t) { e.innerHTML = t; } function jo(e, t) { const n = Array.prototype.slice.call(e.childNodes); const r = Array.prototype.slice.call(t); if (!ot(n, r)) { for (let o = 0, i = r; o < i.length; o++) { const a = i[o]; e.appendChild(a); }n.forEach(W); } } const Go = (function () { function e(e) { this.drainedOption = e, this.isRunning = !1, this.isDirty = !1, this.pauseDepths = {}, this.timeoutId = 0; } return e.prototype.request = function (e) { this.isDirty = !0, this.isPaused() || (this.clearTimeout(), e == null ? this.tryDrain() : this.timeoutId = setTimeout(this.tryDrain.bind(this), e)); }, e.prototype.pause = function (e) { void 0 === e && (e = ''); const t = this.pauseDepths; t[e] = (t[e] || 0) + 1, this.clearTimeout(); }, e.prototype.resume = function (e, t) { void 0 === e && (e = ''); const n = this.pauseDepths; if (e in n) { if (t) delete n[e]; else --n[e] <= 0 && delete n[e]; this.tryDrain(); } }, e.prototype.isPaused = function () { return Object.keys(this.pauseDepths).length; }, e.prototype.tryDrain = function () { if (!this.isRunning && !this.isPaused()) { for (this.isRunning = !0; this.isDirty;) this.isDirty = !1, this.drained(); this.isRunning = !1; } }, e.prototype.clear = function () { this.clearTimeout(), this.isDirty = !1, this.pauseDepths = {}; }, e.prototype.clearTimeout = function () { this.timeoutId && (clearTimeout(this.timeoutId), this.timeoutId = 0); }, e.prototype.drained = function () { this.drainedOption && this.drainedOption(); }, e; }()); const qo = (function () { function e(e, t) { this.runTaskOption = e, this.drainedOption = t, this.queue = [], this.delayedRunner = new Go(this.drain.bind(this)); } return e.prototype.request = function (e, t) { this.queue.push(e), this.delayedRunner.request(t); }, e.prototype.pause = function (e) { this.delayedRunner.pause(e); }, e.prototype.resume = function (e, t) { this.delayedRunner.resume(e, t); }, e.prototype.drain = function () { for (let e = this.queue; e.length;) { for (var t = [], n = void 0; n = e.shift();) this.runTask(n), t.push(n); this.drained(t); } }, e.prototype.runTask = function (e) { this.runTaskOption && this.runTaskOption(e); }, e.prototype.drained = function (e) { this.drainedOption && this.drainedOption(e); }, e; }()); function Yo(e, t, n) { let r; return r = /^(year|month)$/.test(e.currentRangeUnit) ? e.currentRange : e.activeRange, n.formatRange(r.start, r.end, St(t.titleFormat || (function (e) { const t = e.currentRangeUnit; if (t === 'year') return { year: 'numeric' }; if (t === 'month') return { year: 'numeric', month: 'long' }; const n = De(e.currentRange.start, e.currentRange.end); return n !== null && n > 1 ? { year: 'numeric', month: 'short', day: 'numeric' } : { year: 'numeric', month: 'long', day: 'numeric' }; }(e))), { isEndExclusive: e.isRangeAllDay, defaultSeparator: t.titleRangeSeparator }); } const Zo = (function () {
    function e(e) {
      const t = this; this.computeOptionsData = it(this._computeOptionsData), this.computeCurrentViewData = it(this._computeCurrentViewData), this.organizeRawLocales = it($n), this.buildLocale = it(Qn), this.buildPluginHooks = ao(), this.buildDateEnv = it(Xo), this.buildTheme = it(Ko), this.parseToolbars = it(Uo), this.buildViewSpecs = it(Do), this.buildDateProfileGenerator = at(Jo), this.buildViewApi = it($o), this.buildViewUiProps = at(ti), this.buildEventUiBySource = it(Qo, Le), this.buildEventUiBases = it(ei), this.parseContextBusinessHours = at(ni), this.buildTitle = it(Yo), this.emitter = new kr(), this.actionRunner = new qo(this._handleAction.bind(this), this.updateData.bind(this)), this.currentCalendarOptionsInput = {}, this.currentCalendarOptionsRefined = {}, this.currentViewOptionsInput = {}, this.currentViewOptionsRefined = {}, this.currentCalendarOptionsRefiners = {}, this.getCurrentData = function () { return t.data; }, this.dispatch = function (e) { t.actionRunner.request(e); }, this.props = e, this.actionRunner.pause(); const n = {}; const o = this.computeOptionsData(e.optionOverrides, n, e.calendarApi); const i = o.calendarOptions.initialView || o.pluginHooks.initialView; const a = this.computeCurrentViewData(i, o, e.optionOverrides, n); e.calendarApi.currentDataManager = this, this.emitter.setThisContext(e.calendarApi), this.emitter.setOptions(a.options); let s; let l; let u; let c = (s = o.calendarOptions, l = o.dateEnv, (u = s.initialDate) != null ? l.createMarker(u) : Wn(s.now, l)); const d = a.dateProfileGenerator.build(c); sn(d.activeRange, c) || (c = d.currentRange.start); for (var p = {
          dateEnv: o.dateEnv, options: o.calendarOptions, pluginHooks: o.pluginHooks, calendarApi: e.calendarApi, dispatch: this.dispatch, emitter: this.emitter, getCurrentData: this.getCurrentData,
        }, f = 0, h = o.pluginHooks.contextInit; f < h.length; f++) { (0, h[f])(p); } for (var v = wo(o.calendarOptions, d, p), g = {
          dynamicOptionOverrides: n, currentViewType: i, currentDate: c, dateProfile: d, businessHours: this.parseContextBusinessHours(p), eventSources: v, eventUiBases: {}, loadingLevel: To(v), eventStore: { defs: {}, instances: {} }, renderableEventStore: { defs: {}, instances: {} }, dateSelection: null, eventSelection: '', eventDrag: null, eventResize: null, selectionConfig: this.buildViewUiProps(p).selectionConfig,
        }, m = { ...p, ...g }, y = 0, E = o.pluginHooks.reducers; y < E.length; y++) { const S = E[y]; r(g, S(null, null, m)); }g.loadingLevel && this.emitter.trigger('loading', !0), this.state = g, this.updateData(), this.actionRunner.resume();
    } return e.prototype.resetOptions = function (e, t) { const n = this.props; n.optionOverrides = t ? ({ ...n.optionOverrides, ...e }) : e, this.actionRunner.request({ type: 'NOTHING' }); }, e.prototype._handleAction = function (e) {
      const t = this.props; const n = this.state; const o = this.emitter; const i = (function (e, t) { let n; switch (t.type) { case 'SET_OPTION': return { ...e, ...((n = {})[t.optionName] = t.rawOptionValue, n) }; default: return e; } }(n.dynamicOptionOverrides, e)); const a = this.computeOptionsData(t.optionOverrides, i, t.calendarApi); const s = (function (e, t) { switch (t.type) { case 'CHANGE_VIEW_TYPE': return t.viewType; } return e; }(n.currentViewType, e)); const l = this.computeCurrentViewData(s, a, t.optionOverrides, i); t.calendarApi.currentDataManager = this, o.setThisContext(t.calendarApi), o.setOptions(l.options); const u = {
        dateEnv: a.dateEnv, options: a.calendarOptions, pluginHooks: a.pluginHooks, calendarApi: t.calendarApi, dispatch: this.dispatch, emitter: o, getCurrentData: this.getCurrentData,
      }; let c = n.currentDate; let d = n.dateProfile; this.data && this.data.dateProfileGenerator !== l.dateProfileGenerator && (d = l.dateProfileGenerator.build(c)), d = (function (e, t, n, r) { let o; switch (t.type) { case 'CHANGE_VIEW_TYPE': return r.build(t.dateMarker || n); case 'CHANGE_DATE': if (!e.activeRange || !sn(e.currentRange, t.dateMarker)) return r.build(t.dateMarker); break; case 'PREV': if ((o = r.buildPrev(e, n)).isValid) return o; break; case 'NEXT': if ((o = r.buildNext(e, n)).isValid) return o; } return e; }(d, e, c = (function (e, t) { switch (t.type) { case 'CHANGE_DATE': return t.dateMarker; default: return e; } }(c, e)), l.dateProfileGenerator)), sn(d.currentRange, c) || (c = d.currentRange.start); for (var p = Ro(n.eventSources, e, d, u), f = To(p), h = Zr(n.eventStore, e, p, d, u), v = f && !l.options.progressiveEventRendering && n.renderableEventStore || h, g = this.buildViewUiProps(u), m = g.eventUiSingleBase, y = g.selectionConfig, E = this.buildEventUiBySource(p), S = this.buildEventUiBases(v.defs, m, E), D = n.loadingLevel || 0, b = f, C = {
          dynamicOptionOverrides: i, currentViewType: s, currentDate: c, dateProfile: d, eventSources: p, eventStore: h, renderableEventStore: v, selectionConfig: y, eventUiBases: S, loadingLevel: b, businessHours: this.parseContextBusinessHours(u), dateSelection: No(n.dateSelection, e), eventSelection: Ho(n.eventSelection, e), eventDrag: Oo(n.eventDrag, e), eventResize: Ao(n.eventResize, e),
        }, w = { ...u, ...C }, R = 0, T = a.pluginHooks.reducers; R < T.length; R++) { const k = T[R]; r(C, k(n, e, w)); }!D && b ? o.trigger('loading', !0) : D && !b && o.trigger('loading', !1), this.state = C, t.onAction && t.onAction(e);
    }, e.prototype.updateData = function () {
      let e; let t; let n; let o; let i; let a; let s; let l; let u; const c = this.props; const d = this.state; const p = this.data; const f = this.computeOptionsData(c.optionOverrides, d.dynamicOptionOverrides, c.calendarApi); const h = this.computeCurrentViewData(d.currentViewType, f, c.optionOverrides, d.dynamicOptionOverrides); const v = this.data = {
        viewTitle: this.buildTitle(d.dateProfile, h.options, f.dateEnv), calendarApi: c.calendarApi, dispatch: this.dispatch, emitter: this.emitter, getCurrentData: this.getCurrentData, ...f, ...h, ...d,
      }; const g = f.pluginHooks.optionChangeHandlers; const m = p && p.calendarOptions; const y = f.calendarOptions; if (m && m !== y) {
 for (const E in m.timeZone !== y.timeZone && (d.eventSources = v.eventSources = (a = v.eventSources, s = d.dateProfile, l = v, u = s ? s.activeRange : null, xo(a, Io(a, l), u, l)), d.eventStore = v.eventStore = (e = v.eventStore, t = p.dateEnv, n = v.dateEnv, o = e.defs, i = Oe(e.instances, ((e) => {
        const i = o[e.defId]; return i.allDay || i.recurringDef ? e : ({
          ...e, range: { start: n.createMarker(t.toDate(e.range.start, e.forcedStartTzo)), end: n.createMarker(t.toDate(e.range.end, e.forcedEndTzo)) }, forcedStartTzo: n.canComputeOffset ? null : e.forcedStartTzo, forcedEndTzo: n.canComputeOffset ? null : e.forcedEndTzo,
        });
      })), { defs: o, instances: i })), g)m[E] !== y[E] && g[E](y[E], v); 
} c.onData && c.onData(v);
    }, e.prototype._computeOptionsData = function (e, t, n) {
      const r = this.processRawCalendarOptions(e, t); const o = r.refinedOptions; const i = r.pluginHooks; const a = r.localeDefaults; const s = r.availableLocaleData; ri(r.extra); const l = this.buildDateEnv(o.timeZone, o.locale, o.weekNumberCalculation, o.firstDay, o.weekText, i, s, o.defaultRangeSeparator); const u = this.buildViewSpecs(i.views, e, t, a); const c = this.buildTheme(o, i); return {
        calendarOptions: o, pluginHooks: i, dateEnv: l, viewSpecs: u, theme: c, toolbarConfig: this.parseToolbars(o, e, c, u, n), localeDefaults: a, availableRawLocales: s.map,
      };
    }, e.prototype.processRawCalendarOptions = function (e, t) {
      const n = Mt([bt, e, t]); const o = n.locales; const i = n.locale; const a = this.organizeRawLocales(o); const s = a.map; const l = this.buildLocale(i || a.defaultCode, s).options; const u = this.buildPluginHooks(e.plugins || [], Fo); const c = this.currentCalendarOptionsRefiners = {
 ...Dt, ...Ct, ...wt, ...u.listenerRefiners, ...u.optionRefiners 
}; const d = {}; const p = Mt([bt, l, e, t]); const f = {}; const h = this.currentCalendarOptionsInput; const v = this.currentCalendarOptionsRefined; let g = !1; for (const m in p)m !== 'plugins' && (p[m] === h[m] || Rt[m] && m in h && Rt[m](h[m], p[m]) ? f[m] = v[m] : c[m] ? (f[m] = c[m](p[m]), g = !0) : d[m] = h[m]); return g && (this.currentCalendarOptionsInput = p, this.currentCalendarOptionsRefined = f), {
        rawOptions: this.currentCalendarOptionsInput, refinedOptions: this.currentCalendarOptionsRefined, pluginHooks: u, availableLocaleData: a, localeDefaults: l, extra: d,
      };
    }, e.prototype._computeCurrentViewData = function (e, t, n, r) {
      const o = t.viewSpecs[e]; if (!o) throw new Error(`viewType "${e}" is not available. Please make sure you've loaded all neccessary plugins`); const i = this.processRawViewOptions(o, t.pluginHooks, t.localeDefaults, n, r); const a = i.refinedOptions; return ri(i.extra), {
        viewSpec: o,
        options: a,
        dateProfileGenerator: this.buildDateProfileGenerator({
          dateProfileGeneratorClass: o.optionDefaults.dateProfileGeneratorClass, duration: o.duration, durationUnit: o.durationUnit, usesMinMaxTime: o.optionDefaults.usesMinMaxTime, dateEnv: t.dateEnv, calendarApi: this.props.calendarApi, slotMinTime: a.slotMinTime, slotMaxTime: a.slotMaxTime, showNonCurrentDates: a.showNonCurrentDates, dayCount: a.dayCount, dateAlignment: a.dateAlignment, dateIncrement: a.dateIncrement, hiddenDays: a.hiddenDays, weekends: a.weekends, nowInput: a.now, validRangeInput: a.validRange, visibleRangeInput: a.visibleRange, monthMode: a.monthMode, fixedWeekCount: a.fixedWeekCount,
        }),
        viewApi: this.buildViewApi(e, this.getCurrentData, t.dateEnv),
      };
    }, e.prototype.processRawViewOptions = function (e, t, n, o, i) { const a = Mt([bt, e.optionDefaults, n, o, e.optionOverrides, i]); const s = { ...Dt, ...Ct, ...wt, ...kt, ...t.listenerRefiners, ...t.optionRefiners }; const l = {}; const u = this.currentViewOptionsInput; const c = this.currentViewOptionsRefined; let d = !1; const p = {}; for (const f in a)a[f] === u[f] ? l[f] = c[f] : (a[f] === this.currentCalendarOptionsInput[f] ? f in this.currentCalendarOptionsRefined && (l[f] = this.currentCalendarOptionsRefined[f]) : s[f] ? l[f] = s[f](a[f]) : p[f] = a[f], d = !0); return d && (this.currentViewOptionsInput = a, this.currentViewOptionsRefined = l), { rawOptions: this.currentViewOptionsInput, refinedOptions: this.currentViewOptionsRefined, extra: p }; }, e;
  }()); function Xo(e, t, n, r, o, i, a, s) {
    const l = Qn(t || a.defaultCode, a.map); return new Xn({
      calendarSystem: 'gregory', timeZone: e, namedTimeZoneImpl: i.namedTimeZonedImpl, locale: l, weekNumberCalculation: n, firstDay: r, weekText: o, cmdFormatter: i.cmdFormatter, defaultSeparator: s,
    });
  } function Ko(e, t) { return new (t.themeClasses[e.themeSystem] || so)(e); } function Jo(e) { return new (e.dateProfileGeneratorClass || Co)(e); } function $o(e, t, n) { return new On(e, t, n); } function Qo(e) { return Oe(e, ((e) => e.ui)); } function ei(e, t, n) { const r = { '': t }; for (const o in e) { const i = e[o]; i.sourceId && n[i.sourceId] && (r[o] = n[i.sourceId]); } return r; } function ti(e) {
    const t = e.options; return {
      eventUiSingleBase: Wt({
        display: t.eventDisplay, editable: t.editable, startEditable: t.eventStartEditable, durationEditable: t.eventDurationEditable, constraint: t.eventConstraint, overlap: typeof t.eventOverlap === 'boolean' ? t.eventOverlap : void 0, allow: t.eventAllow, backgroundColor: t.eventBackgroundColor, borderColor: t.eventBorderColor, textColor: t.eventTextColor, color: t.eventColor,
      }, e),
      selectionConfig: Wt({ constraint: t.selectConstraint, overlap: typeof t.selectOverlap === 'boolean' ? t.selectOverlap : void 0, allow: t.selectAllow }, e),
    };
  } function ni(e) { return or(e.options.businessHours, e); } function ri(e, t) { for (const n in e)console.warn(`Unknown option '${n}'${t ? ` for view '${t}'` : ''}`); } const oi = (function (e) { function t(t) { const n = e.call(this, t) || this; return n.handleData = function (e) { n.dataManager ? n.setState(e) : n.state = e; }, n.dataManager = new Zo({ optionOverrides: t.optionOverrides, calendarApi: t.calendarApi, onData: n.handleData }), n; } return n(t, e), t.prototype.render = function () { return this.props.children(this.state); }, t.prototype.componentDidUpdate = function (e) { const t = this.props.optionOverrides; t !== e.optionOverrides && this.dataManager.resetOptions(t); }, t; }(Nr)); const ii = function (e) { this.timeZoneName = e; }; const ai = (function () { function e(e) { this.component = e.component; } return e.prototype.destroy = function () {}, e; }()); function si(e, t) { return { component: e, el: t.el, useEventCenter: t.useEventCenter == null || t.useEventCenter }; } function li(e) { let t; return (t = {})[e.component.uid] = e, t; } const ui = {}; const ci = (function () { function e(e, t) { this.emitter = new kr(); } return e.prototype.destroy = function () {}, e.prototype.setMirrorIsVisible = function (e) {}, e.prototype.setMirrorNeedsRevert = function (e) {}, e.prototype.setAutoScrollEnabled = function (e) {}, e; }()); const di = {}; const pi = {
    startTime: Ye, duration: Ye, create: Boolean, sourceId: String,
  }; function fi(e) {
    const t = xt(e, pi); const n = t.refined; const r = t.extra; return {
      startTime: n.startTime || null, duration: n.duration || null, create: n.create == null || n.create, sourceId: n.sourceId, leftoverProps: r,
    };
  } const hi = (function (e) {
    function t() { return e !== null && e.apply(this, arguments) || this; } return n(t, e), t.prototype.render = function () { let e; let t; const n = this.props; const r = n.model; const o = n.extraClassName; let i = !1; const a = r.center; return r.left ? (i = !0, e = r.left) : e = r.start, r.right ? (i = !0, t = r.right) : t = r.end, Hr('div', { className: [o || '', 'fc-toolbar', i ? 'fc-toolbar-ltr' : ''].join(' ') }, this.renderSection('start', e || []), this.renderSection('center', a || []), this.renderSection('end', t || [])); }, t.prototype.renderSection = function (e, t) {
      const n = this.props; return Hr(vi, {
        key: e, widgetGroups: t, title: n.title, activeButton: n.activeButton, isTodayEnabled: n.isTodayEnabled, isPrevEnabled: n.isPrevEnabled, isNextEnabled: n.isNextEnabled,
      });
    }, t;
  }(jr)); var vi = (function (e) {
    function t() { return e !== null && e.apply(this, arguments) || this; } return n(t, e), t.prototype.render = function () { const e = this; const t = this.props.widgetGroups.map(((t) => e.renderWidgetGroup(t))); return Hr.apply(void 0, o(['div', { className: 'fc-toolbar-chunk' }], t)); }, t.prototype.renderWidgetGroup = function (e) {
      for (var t = this.props, n = this.context.theme, i = [], a = !0, s = 0, l = e; s < l.length; s++) {
        const u = l[s]; const c = u.buttonName; const d = u.buttonClick; const p = u.buttonText; const f = u.buttonIcon; if (c === 'title')a = !1, i.push(Hr('h2', { className: 'fc-toolbar-title' }, t.title)); else {
          const h = f ? { 'aria-label': c } : {}; const v = [`fc-${c}-button`, n.getClass('button')]; c === t.activeButton && v.push(n.getClass('buttonActive')); const g = !t.isTodayEnabled && c === 'today' || !t.isPrevEnabled && c === 'prev' || !t.isNextEnabled && c === 'next'; i.push(Hr('button', {
            disabled: g, className: v.join(' '), onClick: d, type: 'button', ...h,
          }, p || (f ? Hr('span', { className: f }) : '')));
        }
      } if (i.length > 1) { const m = a && n.getClass('buttonGroup') || ''; return Hr.apply(void 0, o(['div', { className: m }], i)); } return i[0];
    }, t;
  }(jr)); const gi = (function (e) {
    function t() { const t = e !== null && e.apply(this, arguments) || this; return t.state = { availableWidth: null }, t.handleEl = function (e) { t.el = e, Yr(t.props.elRef, e), t.updateAvailableWidth(); }, t.handleResize = function () { t.updateAvailableWidth(); }, t; } return n(t, e), t.prototype.render = function () {
      const e = this.props; const t = this.state; const n = e.aspectRatio; const r = ['fc-view-harness', n || e.liquid || e.height ? 'fc-view-harness-active' : 'fc-view-harness-passive']; let o = ''; let i = ''; return n ? t.availableWidth !== null ? o = t.availableWidth / n : i = `${1 / n * 100}%` : o = e.height || '', Hr('div', {
        ref: this.handleEl, onClick: e.onClick, className: r.join(' '), style: { height: o, paddingBottom: i },
      }, e.children);
    }, t.prototype.componentDidMount = function () { this.context.addResizeHandler(this.handleResize); }, t.prototype.componentWillUnmount = function () { this.context.removeResizeHandler(this.handleResize); }, t.prototype.updateAvailableWidth = function () { this.el && this.props.aspectRatio && this.setState({ availableWidth: this.el.offsetWidth }); }, t;
  }(jr)); const mi = (function (e) {
    function t(t) {
      const n = e.call(this, t) || this; return n.handleSegClick = function (e, t) {
        const r = n.component; const o = r.context; const i = dn(t); if (i && r.isValidSegDownEl(e.target)) {
          const a = V(e.target, '.fc-event-forced-url'); const s = a ? a.querySelector('a[href]').href : ''; o.emitter.trigger('eventClick', {
            el: t, event: new zn(r.context, i.eventRange.def, i.eventRange.instance), jsEvent: e, view: o.viewApi,
          }), s && !e.defaultPrevented && (window.location.href = s);
        }
      }, n.destroy = Z(t.el, 'click', '.fc-event', n.handleSegClick), n;
    } return n(t, e), t;
  }(ai)); const yi = (function (e) {
    function t(t) { let n; let r; let o; let i; let a; const s = e.call(this, t) || this; return s.handleEventElRemove = function (e) { e === s.currentSegEl && s.handleSegLeave(null, s.currentSegEl); }, s.handleSegEnter = function (e, t) { dn(t) && (s.currentSegEl = t, s.triggerEvent('eventMouseEnter', e, t)); }, s.handleSegLeave = function (e, t) { s.currentSegEl && (s.currentSegEl = null, s.triggerEvent('eventMouseLeave', e, t)); }, s.removeHoverListeners = (n = t.el, r = '.fc-event', o = s.handleSegEnter, i = s.handleSegLeave, Z(n, 'mouseover', r, ((e, t) => { if (t !== a) { a = t, o(e, t); var n = function (e) { a = null, i(e, t), t.removeEventListener('mouseleave', n); }; t.addEventListener('mouseleave', n); } }))), s; } return n(t, e), t.prototype.destroy = function () { this.removeHoverListeners(); }, t.prototype.triggerEvent = function (e, t, n) {
      const r = this.component; const o = r.context; const i = dn(n); t && !r.isValidSegDownEl(t.target) || o.emitter.trigger(e, {
        el: n, event: new zn(o, i.eventRange.def, i.eventRange.instance), jsEvent: t, view: o.viewApi,
      });
    }, t;
  }(ai)); const Ei = (function (e) {
    function t() { const t = e !== null && e.apply(this, arguments) || this; return t.buildViewContext = it(Fr), t.buildViewPropTransformers = it(Di), t.buildToolbarProps = it(Si), t.handleNavLinkClick = Y('a[data-navlink]', t._handleNavLinkClick.bind(t)), t.headerRef = Ar(), t.footerRef = Ar(), t.interactionsStore = {}, t.registerInteractiveComponent = function (e, n) { const r = si(e, n); const o = [mi, yi].concat(t.props.pluginHooks.componentInteractions).map(((e) => new e(r))); t.interactionsStore[e.uid] = o, ui[e.uid] = r; }, t.unregisterInteractiveComponent = function (e) { for (let n = 0, r = t.interactionsStore[e.uid]; n < r.length; n++) { r[n].destroy(); } delete t.interactionsStore[e.uid], delete ui[e.uid]; }, t.resizeRunner = new Go((() => { t.props.emitter.trigger('_resize', !0), t.props.emitter.trigger('windowResize', { view: t.props.viewApi }); })), t.handleWindowResize = function (e) { const n = t.props.options; n.handleWindowResize && e.target === window && t.resizeRunner.request(n.windowResizeDelay); }, t; } return n(t, e), t.prototype.render = function () {
      let e; const t = this.props; const n = t.toolbarConfig; const o = t.options; const i = this.buildToolbarProps(t.viewSpec, t.dateProfile, t.dateProfileGenerator, t.currentDate, Wn(t.options.now, t.dateEnv), t.viewTitle); let a = !1; let s = ''; t.isHeightAuto || t.forPrint ? s = '' : o.height != null ? a = !0 : o.contentHeight != null ? s = o.contentHeight : e = Math.max(o.aspectRatio, 0.5); const l = this.buildViewContext(t.viewSpec, t.viewApi, t.options, t.dateProfileGenerator, t.dateEnv, t.theme, t.pluginHooks, t.dispatch, t.getCurrentData, t.emitter, t.calendarApi, this.registerInteractiveComponent, this.unregisterInteractiveComponent); return Hr(zr.Provider, { value: l }, n.headerToolbar && Hr(hi, {
        ref: this.headerRef, extraClassName: 'fc-header-toolbar', model: n.headerToolbar, ...i,
      }), Hr(gi, {
        liquid: a, height: s, aspectRatio: e, onClick: this.handleNavLinkClick,
      }, this.renderView(t), this.buildAppendContent()), n.footerToolbar && Hr(hi, {
        ref: this.footerRef, extraClassName: 'fc-footer-toolbar', model: n.footerToolbar, ...i,
      }));
    }, t.prototype.componentDidMount = function () { const e = this.props; this.calendarInteractions = e.pluginHooks.calendarInteractions.map(((t) => new t(e))), window.addEventListener('resize', this.handleWindowResize); const t = e.pluginHooks.propSetHandlers; for (const n in t)t[n](e[n], e); }, t.prototype.componentDidUpdate = function (e) { const t = this.props; const n = t.pluginHooks.propSetHandlers; for (const r in n)t[r] !== e[r] && n[r](t[r], t); }, t.prototype.componentWillUnmount = function () { window.removeEventListener('resize', this.handleWindowResize), this.resizeRunner.clear(); for (let e = 0, t = this.calendarInteractions; e < t.length; e++) { t[e].destroy(); } this.props.emitter.trigger('_unmount'); }, t.prototype._handleNavLinkClick = function (e, t) { const n = this.props; const r = n.dateEnv; const o = n.options; const i = n.calendarApi; let a = t.getAttribute('data-navlink'); a = a ? JSON.parse(a) : {}; const s = r.createMarker(a.date); let l = a.type; const u = l === 'day' ? o.navLinkDayClick : l === 'week' ? o.navLinkWeekClick : null; typeof u === 'function' ? u.call(i, r.toDate(s), e) : (typeof u === 'string' && (l = u), i.zoomTo(s, l)); }, t.prototype.buildAppendContent = function () { const e = this.props; const t = e.pluginHooks.viewContainerAppends.map(((t) => t(e))); return Hr.apply(void 0, o([Ur, {}], t)); }, t.prototype.renderView = function (e) {
      for (var t = e.pluginHooks, n = e.viewSpec, o = {
          dateProfile: e.dateProfile, businessHours: e.businessHours, eventStore: e.renderableEventStore, eventUiBases: e.eventUiBases, dateSelection: e.dateSelection, eventSelection: e.eventSelection, eventDrag: e.eventDrag, eventResize: e.eventResize, isHeightAuto: e.isHeightAuto, forPrint: e.forPrint,
        }, i = 0, a = this.buildViewPropTransformers(t.viewPropsTransformers); i < a.length; i++) { const s = a[i]; r(o, s.transform(o, e)); } const l = n.component; return Hr(l, { ...o });
    }, t;
  }(Br)); function Si(e, t, n, r, o, i) {
    const a = n.build(o, void 0, !1); const s = n.buildPrev(t, r, !1); const l = n.buildNext(t, r, !1); return {
      title: i, activeButton: e.type, isTodayEnabled: a.isValid && !sn(t.currentRange, o), isPrevEnabled: s.isValid, isNextEnabled: l.isValid,
    };
  } function Di(e) { return e.map(((e) => new e())); } const bi = (function (e) { function t() { const t = e !== null && e.apply(this, arguments) || this; return t.state = { forPrint: !1 }, t.handleBeforePrint = function () { t.setState({ forPrint: !0 }); }, t.handleAfterPrint = function () { t.setState({ forPrint: !1 }); }, t; } return n(t, e), t.prototype.render = function () { const e = this.props; const t = e.options; const n = this.state.forPrint; const r = n || t.height === 'auto' || t.contentHeight === 'auto'; const o = r || t.height == null ? '' : t.height; const i = ['fc', n ? 'fc-media-print' : 'fc-media-screen', `fc-direction-${t.direction}`, e.theme.getClass('root')]; return cr() || i.push('fc-liquid-hack'), e.children(i, o, r, n); }, t.prototype.componentDidMount = function () { const e = this.props.emitter; e.on('_beforeprint', this.handleBeforePrint), e.on('_afterprint', this.handleAfterPrint); }, t.prototype.componentWillUnmount = function () { const e = this.props.emitter; e.off('_beforeprint', this.handleBeforePrint), e.off('_afterprint', this.handleAfterPrint); }, t; }(jr)); function Ci(e, t) {
    return St(!e || t > 10 ? { weekday: 'short' } : t > 1 ? {
      weekday: 'short', month: 'numeric', day: 'numeric', omitCommas: !0,
    } : { weekday: 'long' });
  } const wi = 'fc-col-header-cell'; const Ri = (function (e) {
    function t() { return e !== null && e.apply(this, arguments) || this; } return n(t, e), t.prototype.render = function () {
      const e = this.context; const t = e.dateEnv; const n = e.options; const o = e.theme; const i = e.viewApi; const a = this.props; const s = a.date; const l = a.dateProfile; const u = hr(s, a.todayRange, null, l); const c = [wi].concat(vr(u, o)); const d = t.format(s, a.dayHeaderFormat); const p = n.navLinks && !u.isDisabled && a.colCnt > 1 ? { 'data-navlink': gr(s), tabIndex: 0 } : {}; const f = {
        date: t.toDate(s), view: i, ...a.extraHookProps, text: d, ...u,
      }; return Hr(uo, {
        hookProps: f, classNames: n.dayHeaderClassNames, content: n.dayHeaderContent, defaultContent: ki, didMount: n.dayHeaderDidMount, willUnmount: n.dayHeaderWillUnmount,
      }, ((e, t, n, o) => Hr('th', {
        ref: e, className: c.concat(t).join(' '), 'data-date': u.isDisabled ? void 0 : tt(s), colSpan: a.colSpan, ...a.extraDataAttrs,
      }, Hr('div', { className: 'fc-scrollgrid-sync-inner' }, !u.isDisabled && Hr('a', { ref: n, className: ['fc-col-header-cell-cushion', a.isSticky ? 'fc-sticky' : ''].join(' '), ...p }, o)))));
    }, t;
  }(jr)); const Ti = (function (e) {
    function t() { return e !== null && e.apply(this, arguments) || this; } return n(t, e), t.prototype.render = function () {
      const e = this.props; const t = this.context; const n = t.dateEnv; const o = t.theme; const i = t.viewApi; const a = t.options; const s = ve(new Date(2592e5), e.dow); const l = {
        dow: e.dow, isDisabled: !1, isFuture: !1, isPast: !1, isToday: !1, isOther: !1,
      }; const u = [wi].concat(vr(l, o), e.extraClassNames || []); const c = n.format(s, e.dayHeaderFormat); const d = {
        date: s, ...l, view: i, ...e.extraHookProps, text: c,
      }; return Hr(uo, {
        hookProps: d, classNames: a.dayHeaderClassNames, content: a.dayHeaderContent, defaultContent: ki, didMount: a.dayHeaderDidMount, willUnmount: a.dayHeaderWillUnmount,
      }, ((t, n, o, i) => Hr('th', {
        ref: t, className: u.concat(n).join(' '), colSpan: e.colSpan, ...e.extraDataAttrs,
      }, Hr('div', { className: 'fc-scrollgrid-sync-inner' }, Hr('a', { className: ['fc-col-header-cell-cushion', e.isSticky ? 'fc-sticky' : ''].join(' '), ref: o }, i)))));
    }, t;
  }(jr)); function ki(e) { return e.text; } const Mi = (function (e) { function t(t, n) { const r = e.call(this, t, n) || this; return r.initialNowDate = Wn(n.options.now, n.dateEnv), r.initialNowQueriedMs = (new Date()).valueOf(), r.state = r.computeTiming().currentState, r; } return n(t, e), t.prototype.render = function () { const e = this.props; const t = this.state; return e.children(t.nowDate, t.todayRange); }, t.prototype.componentDidMount = function () { this.setTimeout(); }, t.prototype.componentDidUpdate = function (e) { e.unit !== this.props.unit && (this.clearTimeout(), this.setTimeout()); }, t.prototype.componentWillUnmount = function () { this.clearTimeout(); }, t.prototype.computeTiming = function () { const e = this.props; const t = this.context; const n = ge(this.initialNowDate, (new Date()).valueOf() - this.initialNowQueriedMs); const r = t.dateEnv.startOf(n, e.unit); const o = t.dateEnv.add(r, Ye(1, e.unit)); const i = o.valueOf() - n.valueOf(); return { currentState: { nowDate: r, todayRange: xi(r) }, nextState: { nowDate: o, todayRange: xi(o) }, waitMs: i }; }, t.prototype.setTimeout = function () { const e = this; const t = this.computeTiming(); const n = t.nextState; const r = t.waitMs; this.timeoutId = setTimeout((() => { e.setState(n, (() => { e.setTimeout(); })); }), r); }, t.prototype.clearTimeout = function () { this.timeoutId && clearTimeout(this.timeoutId); }, t.contextType = zr, t; }(Nr)); function xi(e) { const t = be(e); return { start: t, end: ve(t, 1) }; } const _i = (function (e) {
    function t() { const t = e !== null && e.apply(this, arguments) || this; return t.createDayHeaderFormatter = it(Ii), t; } return n(t, e), t.prototype.render = function () {
      const e = this.context; const t = this.props; const n = t.dates; const r = t.dateProfile; const o = t.datesRepDistinctDays; const i = t.renderIntro; const a = this.createDayHeaderFormatter(e.options.dayHeaderFormat, o, n.length); return Hr(Mi, { unit: 'day' }, ((e, t) => Hr('tr', null, i && i(), n.map(((e) => (o ? Hr(Ri, {
        key: e.toISOString(), date: e, dateProfile: r, todayRange: t, colCnt: n.length, dayHeaderFormat: a,
      }) : Hr(Ti, { key: e.getUTCDay(), dow: e.getUTCDay(), dayHeaderFormat: a })))))));
    }, t;
  }(jr)); function Ii(e, t, n) { return e || Ci(t, n); } const Pi = (function () {
    function e(e, t) { for (var n = e.start, r = e.end, o = [], i = [], a = -1; n < r;)t.isHiddenDay(n) ? o.push(a + 0.5) : (a++, o.push(a), i.push(n)), n = ve(n, 1); this.dates = i, this.indices = o, this.cnt = i.length; } return e.prototype.sliceRange = function (e) {
      const t = this.getDateDayIndex(e.start); const n = this.getDateDayIndex(ve(e.end, -1)); let r = Math.max(0, t); let o = Math.min(this.cnt - 1, n); return (r = Math.ceil(r)) <= (o = Math.floor(o)) ? {
        firstIndex: r, lastIndex: o, isStart: t === r, isEnd: n === o,
      } : null;
    }, e.prototype.getDateDayIndex = function (e) { const t = this.indices; const n = Math.floor(ye(this.dates[0], e)); return n < 0 ? t[0] - 1 : n >= t.length ? t[t.length - 1] + 1 : t[n]; }, e;
  }()); const Ni = (function () {
    function e(e, t) { let n; let r; let o; const i = e.dates; if (t) { for (r = i[0].getUTCDay(), n = 1; n < i.length && i[n].getUTCDay() !== r; n++);o = Math.ceil(i.length / n); } else o = 1, n = i.length; this.rowCnt = o, this.colCnt = n, this.daySeries = e, this.cells = this.buildCells(), this.headerDates = this.buildHeaderDates(); } return e.prototype.buildCells = function () { for (var e = [], t = 0; t < this.rowCnt; t++) { for (var n = [], r = 0; r < this.colCnt; r++)n.push(this.buildCell(t, r)); e.push(n); } return e; }, e.prototype.buildCell = function (e, t) { const n = this.daySeries.dates[e * this.colCnt + t]; return { key: n.toISOString(), date: n }; }, e.prototype.buildHeaderDates = function () { for (var e = [], t = 0; t < this.colCnt; t++)e.push(this.cells[0][t].date); return e; }, e.prototype.sliceRange = function (e) {
      const t = this.colCnt; const n = this.daySeries.sliceRange(e); const r = []; if (n) {
        for (let o = n.firstIndex, i = n.lastIndex, a = o; a <= i;) {
          const s = Math.floor(a / t); const l = Math.min((s + 1) * t, i + 1); r.push({
            row: s, firstCol: a % t, lastCol: (l - 1) % t, isStart: n.isStart && a === o, isEnd: n.isEnd && l - 1 === i,
          }), a = l;
        }
      } return r;
    }, e;
  }()); const Hi = (function () {
    function e() { this.sliceBusinessHours = it(this._sliceBusinessHours), this.sliceDateSelection = it(this._sliceDateSpan), this.sliceEventStore = it(this._sliceEventStore), this.sliceEventDrag = it(this._sliceInteraction), this.sliceEventResize = it(this._sliceInteraction), this.forceDayIfListItem = !1; } return e.prototype.sliceProps = function (e, t, n, r) {
      for (var i = [], a = 4; a < arguments.length; a++)i[a - 4] = arguments[a]; const s = e.eventUiBases; const l = this.sliceEventStore.apply(this, o([e.eventStore, s, t, n], i)); return {
        dateSelectionSegs: this.sliceDateSelection.apply(this, o([e.dateSelection, s, r], i)), businessHourSegs: this.sliceBusinessHours.apply(this, o([e.businessHours, t, n, r], i)), fgEventSegs: l.fg, bgEventSegs: l.bg, eventDrag: this.sliceEventDrag.apply(this, o([e.eventDrag, s, t, n], i)), eventResize: this.sliceEventResize.apply(this, o([e.eventResize, s, t, n], i)), eventSelection: e.eventSelection,
      };
    }, e.prototype.sliceNowDate = function (e, t) { for (var n = [], r = 2; r < arguments.length; r++)n[r - 2] = arguments[r]; return this._sliceDateSpan.apply(this, o([{ range: { start: e, end: ge(e, 1) }, allDay: !1 }, {}, t], n)); }, e.prototype._sliceBusinessHours = function (e, t, n, r) { for (var i = [], a = 4; a < arguments.length; a++)i[a - 4] = arguments[a]; return e ? this._sliceEventStore.apply(this, o([Be(e, Oi(t, Boolean(n)), r), {}, t, n], i)).bg : []; }, e.prototype._sliceEventStore = function (e, t, n, r) { for (var o = [], i = 4; i < arguments.length; i++)o[i - 4] = arguments[i]; if (e) { const a = ln(e, t, Oi(n, Boolean(r)), r); return { bg: this.sliceEventRanges(a.bg, o), fg: this.sliceEventRanges(a.fg, o) }; } return { bg: [], fg: [] }; }, e.prototype._sliceInteraction = function (e, t, n, r) { for (var o = [], i = 4; i < arguments.length; i++)o[i - 4] = arguments[i]; if (!e) return null; const a = ln(e.mutatedEvents, t, Oi(n, Boolean(r)), r); return { segs: this.sliceEventRanges(a.fg, o), affectedInstances: e.affectedEvents.instances, isEvent: e.isEvent }; }, e.prototype._sliceDateSpan = function (e, t, n) { for (var r = [], i = 3; i < arguments.length; i++)r[i - 3] = arguments[i]; if (!e) return []; for (var a = Mn(e, t, n), s = this.sliceRange.apply(this, o([e.range], r)), l = 0, u = s; l < u.length; l++) { const c = u[l]; c.eventRange = a; } return s; }, e.prototype.sliceEventRanges = function (e, t) { for (var n = [], r = 0, o = e; r < o.length; r++) { const i = o[r]; n.push.apply(n, this.sliceEventRange(i, t)); } return n; }, e.prototype.sliceEventRange = function (e, t) { let n = e.range; this.forceDayIfListItem && e.ui.display === 'list-item' && (n = { start: n.start, end: ve(n.start, 1) }); for (var r = this.sliceRange.apply(this, o([n], t)), i = 0, a = r; i < a.length; i++) { const s = a[i]; s.eventRange = e, s.isStart = e.isStart && s.isStart, s.isEnd = e.isEnd && s.isEnd; } return r; }, e;
  }()); function Oi(e, t) { const n = e.activeRange; return t ? n : { start: ge(n.start, e.slotMinTime.milliseconds), end: ge(n.end, e.slotMaxTime.milliseconds - 864e5) }; } const Ai = /^(visible|hidden)$/; const Ui = (function (e) {
    function t() { const t = e !== null && e.apply(this, arguments) || this; return t.handleEl = function (e) { t.el = e, Yr(t.props.elRef, e); }, t; } return n(t, e), t.prototype.render = function () {
      const e = this.props; const t = e.liquid; const n = e.liquidIsAbsolute; const r = t && n; const o = ['fc-scroller']; return t && (n ? o.push('fc-scroller-liquid-absolute') : o.push('fc-scroller-liquid')), Hr('div', {
        ref: this.handleEl,
        className: o.join(' '),
        style: {
          overflowX: e.overflowX, overflowY: e.overflowY, left: r && -(e.overcomeLeft || 0) || '', right: r && -(e.overcomeRight || 0) || '', bottom: r && -(e.overcomeBottom || 0) || '', marginLeft: !r && -(e.overcomeLeft || 0) || '', marginRight: !r && -(e.overcomeRight || 0) || '', marginBottom: !r && -(e.overcomeBottom || 0) || '', maxHeight: e.maxHeight || '',
        },
      }, e.children);
    }, t.prototype.needsXScrolling = function () { if (Ai.test(this.props.overflowX)) return !1; for (let e = this.el, t = this.el.getBoundingClientRect().width - this.getYScrollbarWidth(), n = e.children, r = 0; r < n.length; r++) { if (n[r].getBoundingClientRect().width > t) return !0; } return !1; }, t.prototype.needsYScrolling = function () { if (Ai.test(this.props.overflowY)) return !1; for (let e = this.el, t = this.el.getBoundingClientRect().height - this.getXScrollbarWidth(), n = e.children, r = 0; r < n.length; r++) { if (n[r].getBoundingClientRect().height > t) return !0; } return !1; }, t.prototype.getXScrollbarWidth = function () { return Ai.test(this.props.overflowX) ? 0 : this.el.offsetHeight - this.el.clientHeight; }, t.prototype.getYScrollbarWidth = function () { return Ai.test(this.props.overflowY) ? 0 : this.el.offsetWidth - this.el.clientWidth; }, t;
  }(jr)); const Li = (function () { function e(e) { const t = this; this.masterCallback = e, this.currentMap = {}, this.depths = {}, this.callbackMap = {}, this.handleValue = function (e, n) { const r = t; const o = r.depths; const i = r.currentMap; let a = !1; let s = !1; e !== null ? (a = n in i, i[n] = e, o[n] = (o[n] || 0) + 1, s = !0) : --o[n] == 0 && (delete i[n], delete t.callbackMap[n], a = !0), t.masterCallback && (a && t.masterCallback(null, String(n)), s && t.masterCallback(e, String(n))); }; } return e.prototype.createRef = function (e) { const t = this; let n = this.callbackMap[e]; return n || (n = this.callbackMap[e] = function (n) { t.handleValue(n, String(e)); }), n; }, e.prototype.collect = function (e, t, n) { return Fe(this.currentMap, e, t, n); }, e.prototype.getAll = function () { return Ue(this.currentMap); }, e; }()); function Wi(e) { for (var t = 0, n = 0, r = F(e, '.fc-scrollgrid-shrink'); n < r.length; n++) { const o = r[n]; t = Math.max(t, pe(o)); } return Math.ceil(t); } function Vi(e, t) { return e.liquid && t.liquid; } function zi(e, t) { return t.maxHeight != null || Vi(e, t); } function Fi(e, t, n) { const r = n.expandRows; return typeof t.content === 'function' ? t.content(n) : Hr('table', { className: [t.tableClassName, e.syncRowHeights ? 'fc-scrollgrid-sync-table' : ''].join(' '), style: { minWidth: n.tableMinWidth, width: n.clientWidth, height: r ? n.clientHeight : '' } }, n.tableColGroupNode, Hr('tbody', {}, typeof t.rowContent === 'function' ? t.rowContent(n) : t.rowContent)); } function Bi(e, t) { return ot(e, t, Le); } function ji(e, t) { for (var n = [], r = 0, i = e; r < i.length; r++) for (let a = i[r], s = a.span || 1, l = 0; l < s; l++)n.push(Hr('col', { style: { width: a.width === 'shrink' ? Gi(t) : a.width || '', minWidth: a.minWidth || '' } })); return Hr.apply(void 0, o(['colgroup', {}], n)); } function Gi(e) { return e == null ? 4 : e; } function qi(e) { for (let t = 0, n = e; t < n.length; t++) { if (n[t].width === 'shrink') return !0; } return !1; } function Yi(e, t) { const n = ['fc-scrollgrid', t.theme.getClass('table')]; return e && n.push('fc-scrollgrid-liquid'), n; } function Zi(e, t) { const n = ['fc-scrollgrid-section', `fc-scrollgrid-section-${e.type}`, e.className]; return t && e.liquid && e.maxHeight == null && n.push('fc-scrollgrid-section-liquid'), e.isSticky && n.push('fc-scrollgrid-section-sticky'), n; } function Xi(e) { return Hr('div', { className: 'fc-scrollgrid-sticky-shim', style: { width: e.clientWidth, minWidth: e.tableMinWidth } }); } function Ki(e) { let t = e.stickyHeaderDates; return t != null && t !== 'auto' || (t = e.height === 'auto' || e.viewHeight === 'auto'), t; } function Ji(e) { let t = e.stickyFooterScrollbar; return t != null && t !== 'auto' || (t = e.height === 'auto' || e.viewHeight === 'auto'), t; } const $i = (function (e) {
    function t() {
      const t = e !== null && e.apply(this, arguments) || this; return t.processCols = it(((e) => e), Bi), t.renderMicroColGroup = it(ji), t.scrollerRefs = new Li(), t.scrollerElRefs = new Li(t._handleScrollerEl.bind(t)), t.state = {
        shrinkWidth: null, forceYScrollbars: !1, scrollerClientWidths: {}, scrollerClientHeights: {},
      }, t.handleSizing = function () { t.setState({ shrinkWidth: t.computeShrinkWidth(), ...t.computeScrollerDims() }); }, t;
    } return n(t, e), t.prototype.render = function () { for (var e, t = this.props, n = this.state, r = this.context, i = t.sections || [], a = this.processCols(t.cols), s = this.renderMicroColGroup(a, n.shrinkWidth), l = Yi(t.liquid, r), u = i.length, c = 0, d = [], p = [], f = []; c < u && (e = i[c]).type === 'header';)d.push(this.renderSection(e, c, s)), c++; for (;c < u && (e = i[c]).type === 'body';)p.push(this.renderSection(e, c, s)), c++; for (;c < u && (e = i[c]).type === 'footer';)f.push(this.renderSection(e, c, s)), c++; const h = !cr(); return Hr('table', { className: l.join(' '), style: { height: t.height } }, Boolean(!h && d.length) && Hr.apply(void 0, o(['thead', {}], d)), Boolean(!h && p.length) && Hr.apply(void 0, o(['tbody', {}], p)), Boolean(!h && f.length) && Hr.apply(void 0, o(['tfoot', {}], f)), h && Hr.apply(void 0, o(['tbody', {}], d, p, f))); }, t.prototype.renderSection = function (e, t, n) { return 'outerContent' in e ? Hr(Ur, { key: e.key }, e.outerContent) : Hr('tr', { key: e.key, className: Zi(e, this.props.liquid).join(' ') }, this.renderChunkTd(e, t, n, e.chunk)); }, t.prototype.renderChunkTd = function (e, t, n, r) {
      if ('outerContent' in r) return r.outerContent; const o = this.props; const i = this.state; const a = i.forceYScrollbars; const s = i.scrollerClientWidths; const l = i.scrollerClientHeights; const u = zi(o, e); const c = Vi(o, e); const d = o.liquid ? a ? 'scroll' : u ? 'auto' : 'hidden' : 'visible'; const p = Fi(e, r, {
        tableColGroupNode: n, tableMinWidth: '', clientWidth: void 0 !== s[t] ? s[t] : null, clientHeight: void 0 !== l[t] ? l[t] : null, expandRows: e.expandRows, syncRowHeights: !1, rowSyncHeights: [], reportRowHeightChange() {},
      }); return Hr('td', { ref: r.elRef }, Hr('div', { className: `fc-scroller-harness${c ? ' fc-scroller-harness-liquid' : ''}` }, Hr(Ui, {
        ref: this.scrollerRefs.createRef(t), elRef: this.scrollerElRefs.createRef(t), overflowY: d, overflowX: o.liquid ? 'hidden' : 'visible', maxHeight: e.maxHeight, liquid: c, liquidIsAbsolute: !0,
      }, p)));
    }, t.prototype._handleScrollerEl = function (e, t) { const n = parseInt(t, 10); Yr(this.props.sections[n].chunk.scrollerElRef, e); }, t.prototype.componentDidMount = function () { this.handleSizing(), this.context.addResizeHandler(this.handleSizing); }, t.prototype.componentDidUpdate = function () { this.handleSizing(); }, t.prototype.componentWillUnmount = function () { this.context.removeResizeHandler(this.handleSizing); }, t.prototype.computeShrinkWidth = function () { return qi(this.props.cols) ? Wi(this.scrollerElRefs.getAll()) : 0; }, t.prototype.computeScrollerDims = function () { for (var e = Sr(), t = this.props.sections.length, n = this.scrollerRefs, r = this.scrollerElRefs, o = !1, i = {}, a = {}, s = 0; s < t; s++) { const l = n.currentMap[s]; if (l && l.needsYScrolling()) { o = !0; break; } } for (s = 0; s < t; s++) { const u = r.currentMap[s]; if (u) { const c = u.parentNode; i[s] = Math.floor(c.getBoundingClientRect().width - (o ? e.y : 0)), a[s] = Math.floor(c.getBoundingClientRect().height); } } return { forceYScrollbars: o, scrollerClientWidths: i, scrollerClientHeights: a }; }, t;
  }(jr)); $i.addStateEquality({ scrollerClientWidths: Le, scrollerClientHeights: Le }); const Qi = (function (e) {
    function t() { const t = e !== null && e.apply(this, arguments) || this; return t.elRef = Ar(), t; } return n(t, e), t.prototype.render = function () {
      const e = this.props; const t = this.context; const n = t.options; const r = e.seg; const o = r.eventRange; const i = o.ui; const a = {
        event: new zn(t, o.def, o.instance), view: t.viewApi, timeText: e.timeText, textColor: i.textColor, backgroundColor: i.backgroundColor, borderColor: i.borderColor, isDraggable: !e.disableDragging && gn(r, t), isStartResizable: !e.disableResizing && mn(r, t), isEndResizable: !e.disableResizing && yn(r), isMirror: Boolean(e.isDragging || e.isResizing || e.isDateSelecting), isStart: Boolean(r.isStart), isEnd: Boolean(r.isEnd), isPast: Boolean(e.isPast), isFuture: Boolean(e.isFuture), isToday: Boolean(e.isToday), isSelected: Boolean(e.isSelected), isDragging: Boolean(e.isDragging), isResizing: Boolean(e.isResizing),
      }; const s = Dn(a).concat(i.classNames); return Hr(uo, {
        hookProps: a, classNames: n.eventClassNames, content: n.eventContent, defaultContent: e.defaultContent, didMount: n.eventDidMount, willUnmount: n.eventWillUnmount, elRef: this.elRef,
      }, ((t, n, r, o) => e.children(t, s.concat(n), r, o, a)));
    }, t.prototype.componentDidMount = function () { cn(this.elRef.current, this.props.seg); }, t.prototype.componentDidUpdate = function (e) { const t = this.props.seg; t !== e.seg && cn(this.elRef.current, t); }, t;
  }(jr)); const ea = (function (e) {
    function t() { return e !== null && e.apply(this, arguments) || this; } return n(t, e), t.prototype.render = function () {
      const e = this.props; const t = this.context; const n = e.seg; const o = t.options.eventTimeFormat || e.defaultTimeFormat; const i = En(n, o, t, e.defaultDisplayEventTime, e.defaultDisplayEventEnd); return Hr(Qi, {
        seg: n, timeText: i, disableDragging: e.disableDragging, disableResizing: e.disableResizing, defaultContent: e.defaultContent || ta, isDragging: e.isDragging, isResizing: e.isResizing, isDateSelecting: e.isDateSelecting, isSelected: e.isSelected, isPast: e.isPast, isFuture: e.isFuture, isToday: e.isToday,
      }, ((t, o, i, a, s) => Hr('a', {
        className: e.extraClassNames.concat(o).join(' '), style: { borderColor: s.borderColor, backgroundColor: s.backgroundColor }, ref: t, ...(function (e) { const t = e.eventRange.def.url; return t ? { href: t } : {}; }(n)),
      }, Hr('div', { className: 'fc-event-main', ref: i, style: { color: s.textColor } }, a), s.isStartResizable && Hr('div', { className: 'fc-event-resizer fc-event-resizer-start' }), s.isEndResizable && Hr('div', { className: 'fc-event-resizer fc-event-resizer-end' }))));
    }, t;
  }(jr)); function ta(e) { return Hr('div', { className: 'fc-event-main-frame' }, e.timeText && Hr('div', { className: 'fc-event-time' }, e.timeText), Hr('div', { className: 'fc-event-title-container' }, Hr('div', { className: 'fc-event-title fc-sticky' }, e.event.title || Hr(Ur, null, ' ')))); } const na = function (e) {
    return Hr(zr.Consumer, null, ((t) => {
      const n = t.options; const r = { isAxis: e.isAxis, date: t.dateEnv.toDate(e.date), view: t.viewApi }; return Hr(uo, {
        hookProps: r, classNames: n.nowIndicatorClassNames, content: n.nowIndicatorContent, didMount: n.nowIndicatorDidMount, willUnmount: n.nowIndicatorWillUnmount,
      }, e.children);
    }));
  }; const ra = St({ day: 'numeric' }); const oa = (function (e) {
    function t() { const t = e !== null && e.apply(this, arguments) || this; return t.refineHookProps = at(aa), t.normalizeClassNames = vo(), t; } return n(t, e), t.prototype.render = function () {
      const e = this.props; const t = this.context; const n = t.options; const r = this.refineHookProps({
        date: e.date, dateProfile: e.dateProfile, todayRange: e.todayRange, showDayNumber: e.showDayNumber, extraProps: e.extraHookProps, viewApi: t.viewApi, dateEnv: t.dateEnv,
      }); const o = vr(r, t.theme).concat(r.isDisabled ? [] : this.normalizeClassNames(n.dayCellClassNames, r)); const i = r.isDisabled ? {} : { 'data-date': tt(e.date) }; return Hr(ho, {
        hookProps: r, didMount: n.dayCellDidMount, willUnmount: n.dayCellWillUnmount, elRef: e.elRef,
      }, ((t) => e.children(t, o, i, r.isDisabled)));
    }, t;
  }(jr)); const ia = (function (e) {
    function t() { return e !== null && e.apply(this, arguments) || this; } return n(t, e), t.prototype.render = function () {
      const e = this.props; const t = this.context; const n = t.options; const r = aa({
        date: e.date, dateProfile: e.dateProfile, todayRange: e.todayRange, showDayNumber: e.showDayNumber, extraProps: e.extraHookProps, viewApi: t.viewApi, dateEnv: t.dateEnv,
      }); return Hr(po, { hookProps: r, content: n.dayCellContent, defaultContent: e.defaultContent }, e.children);
    }, t;
  }(jr)); function aa(e) {
    const t = e.date; const n = e.dateEnv; const o = hr(t, e.todayRange, null, e.dateProfile); return {
      date: n.toDate(t), view: e.viewApi, ...o, dayNumberText: e.showDayNumber ? n.format(t, ra) : '', ...e.extraProps,
    };
  } function sa(e) { return Hr('div', { className: `fc-${e}` }); } const la = function (e) {
    return Hr(Qi, {
      defaultContent: ua, seg: e.seg, timeText: '', disableDragging: !0, disableResizing: !0, isDragging: !1, isResizing: !1, isDateSelecting: !1, isSelected: !1, isPast: e.isPast, isFuture: e.isFuture, isToday: e.isToday,
    }, ((e, t, n, r, o) => Hr('div', { ref: e, className: ['fc-bg-event'].concat(t).join(' '), style: { backgroundColor: o.backgroundColor } }, r)));
  }; function ua(e) { return e.event.title && Hr('div', { className: 'fc-event-title' }, e.event.title); } const ca = function (e) {
    return Hr(zr.Consumer, null, ((t) => {
      const n = t.dateEnv; const r = t.options; const o = e.date; const i = r.weekNumberFormat || e.defaultFormat; const a = n.computeWeekNumber(o); const s = n.format(o, i); return Hr(uo, {
        hookProps: { num: a, text: s, date: o }, classNames: r.weekNumberClassNames, content: r.weekNumberContent, defaultContent: da, didMount: r.weekNumberDidMount, willUnmount: r.weekNumberWillUnmount,
      }, e.children);
    }));
  }; function da(e) { return e.text; } const pa = (function (e) {
    function t(t, n) {
      void 0 === n && (n = {}); const o = e.call(this) || this; return o.isRendering = !1, o.isRendered = !1, o.currentClassNames = [], o.customContentRenderId = 0, o.handleAction = function (e) { switch (e.type) { case 'SET_EVENT_DRAG': case 'SET_EVENT_RESIZE': o.renderRunner.tryDrain(); } }, o.handleData = function (e) { o.currentData = e, o.renderRunner.request(e.calendarOptions.rerenderDelay); }, o.handleRenderRequest = function () { if (o.isRendering) { o.isRendered = !0; const e = o.currentData; Or(Hr(bi, { options: e.calendarOptions, theme: e.theme, emitter: e.emitter }, ((t, n, i, a) => (o.setClassNames(t), o.setHeight(n), Hr(co.Provider, { value: o.customContentRenderId }, Hr(Ei, { isHeightAuto: i, forPrint: a, ...e }))))), o.el); } else o.isRendered && (o.isRendered = !1, Or(null, o.el), o.setClassNames([]), o.setHeight('')); Wr(); }, o.el = t, o.renderRunner = new Go(o.handleRenderRequest), new Zo({
        optionOverrides: n, calendarApi: o, onAction: o.handleAction, onData: o.handleData,
      }), o;
    } return n(t, e), Object.defineProperty(t.prototype, 'view', { get() { return this.currentData.viewApi; }, enumerable: !1, configurable: !0 }), t.prototype.render = function () { this.isRendering ? this.customContentRenderId++ : this.isRendering = !0, this.renderRunner.request(); }, t.prototype.destroy = function () { this.isRendering && (this.isRendering = !1, this.renderRunner.request()); }, t.prototype.updateSize = function () { e.prototype.updateSize.call(this), Wr(); }, t.prototype.batchRendering = function (e) { this.renderRunner.pause('batchRendering'), e(), this.renderRunner.resume('batchRendering'); }, t.prototype.pauseRendering = function () { this.renderRunner.pause('pauseRendering'); }, t.prototype.resumeRendering = function () { this.renderRunner.resume('pauseRendering', !0); }, t.prototype.resetOptions = function (e, t) { this.currentDataManager.resetOptions(e, t); }, t.prototype.setClassNames = function (e) { if (!ot(e, this.currentClassNames)) { for (var t = this.el.classList, n = 0, r = this.currentClassNames; n < r.length; n++) { var o = r[n]; t.remove(o); } for (let i = 0, a = e; i < a.length; i++) { o = a[i]; t.add(o); } this.currentClassNames = e; } }, t.prototype.setHeight = function (e) { G(this.el, 'height', e); }, t;
  }(Vn)); di.touchMouseIgnoreWait = 500; let fa = 0; let ha = 0; let va = !1; const ga = (function () {
    function e(e) {
      const t = this; this.subjectEl = null, this.downEl = null, this.selector = '', this.handleSelector = '', this.shouldIgnoreMove = !1, this.shouldWatchScroll = !0, this.isDragging = !1, this.isTouchDragging = !1, this.wasTouchScroll = !1, this.handleMouseDown = function (e) { if (!t.shouldIgnoreMouse() && (function (e) { return e.button === 0 && !e.ctrlKey; }(e)) && t.tryStart(e)) { const n = t.createEventFromMouse(e, !0); t.emitter.trigger('pointerdown', n), t.initScrollWatch(n), t.shouldIgnoreMove || document.addEventListener('mousemove', t.handleMouseMove), document.addEventListener('mouseup', t.handleMouseUp); } }, this.handleMouseMove = function (e) { const n = t.createEventFromMouse(e); t.recordCoords(n), t.emitter.trigger('pointermove', n); }, this.handleMouseUp = function (e) { document.removeEventListener('mousemove', t.handleMouseMove), document.removeEventListener('mouseup', t.handleMouseUp), t.emitter.trigger('pointerup', t.createEventFromMouse(e)), t.cleanup(); }, this.handleTouchStart = function (e) { if (t.tryStart(e)) { t.isTouchDragging = !0; const n = t.createEventFromTouch(e, !0); t.emitter.trigger('pointerdown', n), t.initScrollWatch(n); const r = e.target; t.shouldIgnoreMove || r.addEventListener('touchmove', t.handleTouchMove), r.addEventListener('touchend', t.handleTouchEnd), r.addEventListener('touchcancel', t.handleTouchEnd), window.addEventListener('scroll', t.handleTouchScroll, !0); } }, this.handleTouchMove = function (e) { const n = t.createEventFromTouch(e); t.recordCoords(n), t.emitter.trigger('pointermove', n); }, this.handleTouchEnd = function (e) { if (t.isDragging) { const n = e.target; n.removeEventListener('touchmove', t.handleTouchMove), n.removeEventListener('touchend', t.handleTouchEnd), n.removeEventListener('touchcancel', t.handleTouchEnd), window.removeEventListener('scroll', t.handleTouchScroll, !0), t.emitter.trigger('pointerup', t.createEventFromTouch(e)), t.cleanup(), t.isTouchDragging = !1, fa++, setTimeout((() => { fa--; }), di.touchMouseIgnoreWait); } }, this.handleTouchScroll = function () { t.wasTouchScroll = !0; }, this.handleScroll = function (e) {
        if (!t.shouldIgnoreMove) {
          const n = window.pageXOffset - t.prevScrollX + t.prevPageX; const r = window.pageYOffset - t.prevScrollY + t.prevPageY; t.emitter.trigger('pointermove', {
            origEvent: e, isTouch: t.isTouchDragging, subjectEl: t.subjectEl, pageX: n, pageY: r, deltaX: n - t.origPageX, deltaY: r - t.origPageY,
          });
        }
      }, this.containerEl = e, this.emitter = new kr(), e.addEventListener('mousedown', this.handleMouseDown), e.addEventListener('touchstart', this.handleTouchStart, { passive: !0 }), ha++ || window.addEventListener('touchmove', ma, { passive: !1 });
    } return e.prototype.destroy = function () { this.containerEl.removeEventListener('mousedown', this.handleMouseDown), this.containerEl.removeEventListener('touchstart', this.handleTouchStart, { passive: !0 }), --ha || window.removeEventListener('touchmove', ma, { passive: !1 }); }, e.prototype.tryStart = function (e) { const t = this.querySubjectEl(e); const n = e.target; return !(!t || this.handleSelector && !V(n, this.handleSelector)) && (this.subjectEl = t, this.downEl = n, this.isDragging = !0, this.wasTouchScroll = !1, !0); }, e.prototype.cleanup = function () { va = !1, this.isDragging = !1, this.subjectEl = null, this.downEl = null, this.destroyScrollWatch(); }, e.prototype.querySubjectEl = function (e) { return this.selector ? V(e.target, this.selector) : this.containerEl; }, e.prototype.shouldIgnoreMouse = function () { return fa || this.isTouchDragging; }, e.prototype.cancelTouchScroll = function () { this.isDragging && (va = !0); }, e.prototype.initScrollWatch = function (e) { this.shouldWatchScroll && (this.recordCoords(e), window.addEventListener('scroll', this.handleScroll, !0)); }, e.prototype.recordCoords = function (e) { this.shouldWatchScroll && (this.prevPageX = e.pageX, this.prevPageY = e.pageY, this.prevScrollX = window.pageXOffset, this.prevScrollY = window.pageYOffset); }, e.prototype.destroyScrollWatch = function () { this.shouldWatchScroll && window.removeEventListener('scroll', this.handleScroll, !0); }, e.prototype.createEventFromMouse = function (e, t) {
      let n = 0; let r = 0; return t ? (this.origPageX = e.pageX, this.origPageY = e.pageY) : (n = e.pageX - this.origPageX, r = e.pageY - this.origPageY), {
        origEvent: e, isTouch: !1, subjectEl: this.subjectEl, pageX: e.pageX, pageY: e.pageY, deltaX: n, deltaY: r,
      };
    }, e.prototype.createEventFromTouch = function (e, t) {
      let n; let r; const o = e.touches; let i = 0; let a = 0; return o && o.length ? (n = o[0].pageX, r = o[0].pageY) : (n = e.pageX, r = e.pageY), t ? (this.origPageX = n, this.origPageY = r) : (i = n - this.origPageX, a = r - this.origPageY), {
        origEvent: e, isTouch: !0, subjectEl: this.subjectEl, pageX: n, pageY: r, deltaX: i, deltaY: a,
      };
    }, e;
  }()); function ma(e) { va && e.preventDefault(); } const ya = (function () {
    function e() { this.isVisible = !1, this.sourceEl = null, this.mirrorEl = null, this.sourceElRect = null, this.parentNode = document.body, this.zIndex = 9999, this.revertDuration = 0; } return e.prototype.start = function (e, t, n) { this.sourceEl = e, this.sourceElRect = this.sourceEl.getBoundingClientRect(), this.origScreenX = t - window.pageXOffset, this.origScreenY = n - window.pageYOffset, this.deltaX = 0, this.deltaY = 0, this.updateElPosition(); }, e.prototype.handleMove = function (e, t) { this.deltaX = e - window.pageXOffset - this.origScreenX, this.deltaY = t - window.pageYOffset - this.origScreenY, this.updateElPosition(); }, e.prototype.setIsVisible = function (e) { e ? this.isVisible || (this.mirrorEl && (this.mirrorEl.style.display = ''), this.isVisible = e, this.updateElPosition()) : this.isVisible && (this.mirrorEl && (this.mirrorEl.style.display = 'none'), this.isVisible = e); }, e.prototype.stop = function (e, t) { const n = this; const r = function () { n.cleanup(), t(); }; e && this.mirrorEl && this.isVisible && this.revertDuration && (this.deltaX || this.deltaY) ? this.doRevertAnimation(r, this.revertDuration) : setTimeout(r, 0); }, e.prototype.doRevertAnimation = function (e, t) { const n = this.mirrorEl; const r = this.sourceEl.getBoundingClientRect(); n.style.transition = `top ${t}ms,left ${t}ms`, j(n, { left: r.left, top: r.top }), K(n, (() => { n.style.transition = '', e(); })); }, e.prototype.cleanup = function () { this.mirrorEl && (W(this.mirrorEl), this.mirrorEl = null), this.sourceEl = null; }, e.prototype.updateElPosition = function () { this.sourceEl && this.isVisible && j(this.getMirrorEl(), { left: this.sourceElRect.left + this.deltaX, top: this.sourceElRect.top + this.deltaY }); }, e.prototype.getMirrorEl = function () {
      const e = this.sourceElRect; let t = this.mirrorEl; return t || ((t = this.mirrorEl = this.sourceEl.cloneNode(!0)).classList.add('fc-unselectable'), t.classList.add('fc-event-dragging'), j(t, {
        position: 'fixed', zIndex: this.zIndex, visibility: '', boxSizing: 'border-box', width: e.right - e.left, height: e.bottom - e.top, right: 'auto', bottom: 'auto', margin: 0,
      }), this.parentNode.appendChild(t)), t;
    }, e;
  }()); const Ea = (function (e) { function t(t, n) { const r = e.call(this) || this; return r.handleScroll = function () { r.scrollTop = r.scrollController.getScrollTop(), r.scrollLeft = r.scrollController.getScrollLeft(), r.handleScrollChange(); }, r.scrollController = t, r.doesListening = n, r.scrollTop = r.origScrollTop = t.getScrollTop(), r.scrollLeft = r.origScrollLeft = t.getScrollLeft(), r.scrollWidth = t.getScrollWidth(), r.scrollHeight = t.getScrollHeight(), r.clientWidth = t.getClientWidth(), r.clientHeight = t.getClientHeight(), r.clientRect = r.computeClientRect(), r.doesListening && r.getEventTarget().addEventListener('scroll', r.handleScroll), r; } return n(t, e), t.prototype.destroy = function () { this.doesListening && this.getEventTarget().removeEventListener('scroll', this.handleScroll); }, t.prototype.getScrollTop = function () { return this.scrollTop; }, t.prototype.getScrollLeft = function () { return this.scrollLeft; }, t.prototype.setScrollTop = function (e) { this.scrollController.setScrollTop(e), this.doesListening || (this.scrollTop = Math.max(Math.min(e, this.getMaxScrollTop()), 0), this.handleScrollChange()); }, t.prototype.setScrollLeft = function (e) { this.scrollController.setScrollLeft(e), this.doesListening || (this.scrollLeft = Math.max(Math.min(e, this.getMaxScrollLeft()), 0), this.handleScrollChange()); }, t.prototype.getClientWidth = function () { return this.clientWidth; }, t.prototype.getClientHeight = function () { return this.clientHeight; }, t.prototype.getScrollWidth = function () { return this.scrollWidth; }, t.prototype.getScrollHeight = function () { return this.scrollHeight; }, t.prototype.handleScrollChange = function () {}, t; }(xr)); const Sa = (function (e) { function t(t, n) { return e.call(this, new _r(t), n) || this; } return n(t, e), t.prototype.getEventTarget = function () { return this.scrollController.el; }, t.prototype.computeClientRect = function () { return Cr(this.scrollController.el); }, t; }(Ea)); const Da = (function (e) {
    function t(t) { return e.call(this, new Ir(), t) || this; } return n(t, e), t.prototype.getEventTarget = function () { return window; }, t.prototype.computeClientRect = function () {
      return {
        left: this.scrollLeft, right: this.scrollLeft + this.clientWidth, top: this.scrollTop, bottom: this.scrollTop + this.clientHeight,
      };
    }, t.prototype.handleScrollChange = function () { this.clientRect = this.computeClientRect(); }, t;
  }(Ea)); const ba = typeof performance === 'function' ? performance.now : Date.now; const Ca = (function () { function e() { const e = this; this.isEnabled = !0, this.scrollQuery = [window, '.fc-scroller'], this.edgeThreshold = 50, this.maxVelocity = 300, this.pointerScreenX = null, this.pointerScreenY = null, this.isAnimating = !1, this.scrollCaches = null, this.everMovedUp = !1, this.everMovedDown = !1, this.everMovedLeft = !1, this.everMovedRight = !1, this.animate = function () { if (e.isAnimating) { const t = e.computeBestEdge(e.pointerScreenX + window.pageXOffset, e.pointerScreenY + window.pageYOffset); if (t) { const n = ba(); e.handleSide(t, (n - e.msSinceRequest) / 1e3), e.requestAnimation(n); } else e.isAnimating = !1; } }; } return e.prototype.start = function (e, t) { this.isEnabled && (this.scrollCaches = this.buildCaches(), this.pointerScreenX = null, this.pointerScreenY = null, this.everMovedUp = !1, this.everMovedDown = !1, this.everMovedLeft = !1, this.everMovedRight = !1, this.handleMove(e, t)); }, e.prototype.handleMove = function (e, t) { if (this.isEnabled) { const n = e - window.pageXOffset; const r = t - window.pageYOffset; const o = this.pointerScreenY === null ? 0 : r - this.pointerScreenY; const i = this.pointerScreenX === null ? 0 : n - this.pointerScreenX; o < 0 ? this.everMovedUp = !0 : o > 0 && (this.everMovedDown = !0), i < 0 ? this.everMovedLeft = !0 : i > 0 && (this.everMovedRight = !0), this.pointerScreenX = n, this.pointerScreenY = r, this.isAnimating || (this.isAnimating = !0, this.requestAnimation(ba())); } }, e.prototype.stop = function () { if (this.isEnabled) { this.isAnimating = !1; for (let e = 0, t = this.scrollCaches; e < t.length; e++) { t[e].destroy(); } this.scrollCaches = null; } }, e.prototype.requestAnimation = function (e) { this.msSinceRequest = e, requestAnimationFrame(this.animate); }, e.prototype.handleSide = function (e, t) { const n = e.scrollCache; const r = this.edgeThreshold; const o = r - e.distance; const i = o * o / (r * r) * this.maxVelocity * t; let a = 1; switch (e.name) { case 'left': a = -1; case 'right': n.setScrollLeft(n.getScrollLeft() + i * a); break; case 'top': a = -1; case 'bottom': n.setScrollTop(n.getScrollTop() + i * a); } }, e.prototype.computeBestEdge = function (e, t) { for (var n = this.edgeThreshold, r = null, o = 0, i = this.scrollCaches; o < i.length; o++) { const a = i[o]; const s = a.clientRect; const l = e - s.left; const u = s.right - e; const c = t - s.top; const d = s.bottom - t; l >= 0 && u >= 0 && c >= 0 && d >= 0 && (c <= n && this.everMovedUp && a.canScrollUp() && (!r || r.distance > c) && (r = { scrollCache: a, name: 'top', distance: c }), d <= n && this.everMovedDown && a.canScrollDown() && (!r || r.distance > d) && (r = { scrollCache: a, name: 'bottom', distance: d }), l <= n && this.everMovedLeft && a.canScrollLeft() && (!r || r.distance > l) && (r = { scrollCache: a, name: 'left', distance: l }), u <= n && this.everMovedRight && a.canScrollRight() && (!r || r.distance > u) && (r = { scrollCache: a, name: 'right', distance: u })); } return r; }, e.prototype.buildCaches = function () { return this.queryScrollEls().map(((e) => (e === window ? new Da(!1) : new Sa(e, !1)))); }, e.prototype.queryScrollEls = function () { for (var e = [], t = 0, n = this.scrollQuery; t < n.length; t++) { const r = n[t]; typeof r === 'object' ? e.push(r) : e.push.apply(e, Array.prototype.slice.call(document.querySelectorAll(r))); } return e; }, e; }()); const wa = (function (e) { function t(t, n) { const r = e.call(this, t) || this; r.delay = null, r.minDistance = 0, r.touchScrollAllowed = !0, r.mirrorNeedsRevert = !1, r.isInteracting = !1, r.isDragging = !1, r.isDelayEnded = !1, r.isDistanceSurpassed = !1, r.delayTimeoutId = null, r.onPointerDown = function (e) { r.isDragging || (r.isInteracting = !0, r.isDelayEnded = !1, r.isDistanceSurpassed = !1, te(document.body), re(document.body), e.isTouch || e.origEvent.preventDefault(), r.emitter.trigger('pointerdown', e), r.isInteracting && !r.pointer.shouldIgnoreMove && (r.mirror.setIsVisible(!1), r.mirror.start(e.subjectEl, e.pageX, e.pageY), r.startDelay(e), r.minDistance || r.handleDistanceSurpassed(e))); }, r.onPointerMove = function (e) { if (r.isInteracting) { if (r.emitter.trigger('pointermove', e), !r.isDistanceSurpassed) { const t = r.minDistance; const n = e.deltaX; const o = e.deltaY; n * n + o * o >= t * t && r.handleDistanceSurpassed(e); }r.isDragging && (e.origEvent.type !== 'scroll' && (r.mirror.handleMove(e.pageX, e.pageY), r.autoScroller.handleMove(e.pageX, e.pageY)), r.emitter.trigger('dragmove', e)); } }, r.onPointerUp = function (e) { r.isInteracting && (r.isInteracting = !1, ne(document.body), oe(document.body), r.emitter.trigger('pointerup', e), r.isDragging && (r.autoScroller.stop(), r.tryStopDrag(e)), r.delayTimeoutId && (clearTimeout(r.delayTimeoutId), r.delayTimeoutId = null)); }; const o = r.pointer = new ga(t); return o.emitter.on('pointerdown', r.onPointerDown), o.emitter.on('pointermove', r.onPointerMove), o.emitter.on('pointerup', r.onPointerUp), n && (o.selector = n), r.mirror = new ya(), r.autoScroller = new Ca(), r; } return n(t, e), t.prototype.destroy = function () { this.pointer.destroy(), this.onPointerUp({}); }, t.prototype.startDelay = function (e) { const t = this; typeof this.delay === 'number' ? this.delayTimeoutId = setTimeout((() => { t.delayTimeoutId = null, t.handleDelayEnd(e); }), this.delay) : this.handleDelayEnd(e); }, t.prototype.handleDelayEnd = function (e) { this.isDelayEnded = !0, this.tryStartDrag(e); }, t.prototype.handleDistanceSurpassed = function (e) { this.isDistanceSurpassed = !0, this.tryStartDrag(e); }, t.prototype.tryStartDrag = function (e) { this.isDelayEnded && this.isDistanceSurpassed && (this.pointer.wasTouchScroll && !this.touchScrollAllowed || (this.isDragging = !0, this.mirrorNeedsRevert = !1, this.autoScroller.start(e.pageX, e.pageY), this.emitter.trigger('dragstart', e), !1 === this.touchScrollAllowed && this.pointer.cancelTouchScroll())); }, t.prototype.tryStopDrag = function (e) { this.mirror.stop(this.mirrorNeedsRevert, this.stopDrag.bind(this, e)); }, t.prototype.stopDrag = function (e) { this.isDragging = !1, this.emitter.trigger('dragend', e); }, t.prototype.setIgnoreMove = function (e) { this.pointer.shouldIgnoreMove = e; }, t.prototype.setMirrorIsVisible = function (e) { this.mirror.setIsVisible(e); }, t.prototype.setMirrorNeedsRevert = function (e) { this.mirrorNeedsRevert = e; }, t.prototype.setAutoScrollEnabled = function (e) { this.autoScroller.isEnabled = e; }, t; }(ci)); const Ra = (function () { function e(e) { this.origRect = wr(e), this.scrollCaches = Rr(e).map(((e) => new Sa(e, !0))); } return e.prototype.destroy = function () { for (let e = 0, t = this.scrollCaches; e < t.length; e++) { t[e].destroy(); } }, e.prototype.computeLeft = function () { for (var e = this.origRect.left, t = 0, n = this.scrollCaches; t < n.length; t++) { const r = n[t]; e += r.origScrollLeft - r.getScrollLeft(); } return e; }, e.prototype.computeTop = function () { for (var e = this.origRect.top, t = 0, n = this.scrollCaches; t < n.length; t++) { const r = n[t]; e += r.origScrollTop - r.getScrollTop(); } return e; }, e.prototype.isWithinClipping = function (e, t) { for (var n, r, o = { left: e, top: t }, i = 0, a = this.scrollCaches; i < a.length; i++) { const s = a[i]; if (n = s.getEventTarget(), r = void 0, (r = n.tagName) !== 'HTML' && r !== 'BODY' && !ir(o, s.clientRect)) return !1; } return !0; }, e; }()); const Ta = (function () { function e(e, t) { const n = this; this.useSubjectCenter = !1, this.requireInitial = !0, this.initialHit = null, this.movingHit = null, this.finalHit = null, this.handlePointerDown = function (e) { const t = n.dragging; n.initialHit = null, n.movingHit = null, n.finalHit = null, n.prepareHits(), n.processFirstCoord(e), n.initialHit || !n.requireInitial ? (t.setIgnoreMove(!1), n.emitter.trigger('pointerdown', e)) : t.setIgnoreMove(!0); }, this.handleDragStart = function (e) { n.emitter.trigger('dragstart', e), n.handleMove(e, !0); }, this.handleDragMove = function (e) { n.emitter.trigger('dragmove', e), n.handleMove(e); }, this.handlePointerUp = function (e) { n.releaseHits(), n.emitter.trigger('pointerup', e); }, this.handleDragEnd = function (e) { n.movingHit && n.emitter.trigger('hitupdate', null, !0, e), n.finalHit = n.movingHit, n.movingHit = null, n.emitter.trigger('dragend', e); }, this.droppableStore = t, e.emitter.on('pointerdown', this.handlePointerDown), e.emitter.on('dragstart', this.handleDragStart), e.emitter.on('dragmove', this.handleDragMove), e.emitter.on('pointerup', this.handlePointerUp), e.emitter.on('dragend', this.handleDragEnd), this.dragging = e, this.emitter = new kr(); } return e.prototype.processFirstCoord = function (e) { let t; const n = { left: e.pageX, top: e.pageY }; let r = n; const o = e.subjectEl; o !== document && (r = sr(r, t = wr(o))); const i = this.initialHit = this.queryHitForOffset(r.left, r.top); if (i) { if (this.useSubjectCenter && t) { const a = ar(t, i.rect); a && (r = lr(a)); } this.coordAdjust = ur(r, n); } else this.coordAdjust = { left: 0, top: 0 }; }, e.prototype.handleMove = function (e, t) { const n = this.queryHitForOffset(e.pageX + this.coordAdjust.left, e.pageY + this.coordAdjust.top); !t && ka(this.movingHit, n) || (this.movingHit = n, this.emitter.trigger('hitupdate', n, !1, e)); }, e.prototype.prepareHits = function () { this.offsetTrackers = Oe(this.droppableStore, ((e) => (e.component.prepareHits(), new Ra(e.el)))); }, e.prototype.releaseHits = function () { const e = this.offsetTrackers; for (const t in e)e[t].destroy(); this.offsetTrackers = {}; }, e.prototype.queryHitForOffset = function (e, t) { const n = this.droppableStore; const r = this.offsetTrackers; let o = null; for (const i in n) { const a = n[i].component; const s = r[i]; if (s && s.isWithinClipping(e, t)) { const l = s.computeLeft(); const u = s.computeTop(); const c = e - l; const d = t - u; const p = s.origRect; const f = p.right - p.left; const h = p.bottom - p.top; if (c >= 0 && c < f && d >= 0 && d < h) { const v = a.queryHit(c, d, f, h); const g = a.context.getCurrentData().dateProfile; v && an(g.activeRange, v.dateSpan.range) && (!o || v.layer > o.layer) && (v.rect.left += l, v.rect.right += l, v.rect.top += u, v.rect.bottom += u, o = v); } } } return o; }, e; }()); function ka(e, t) { return !e && !t || Boolean(e) === Boolean(t) && Rn(e.dateSpan, t.dateSpan); } function Ma(e, t) { for (var n, o, i = {}, a = 0, s = t.pluginHooks.datePointTransforms; a < s.length; a++) { const l = s[a]; r(i, l(e, t)); } return r(i, (n = e, { date: (o = t.dateEnv).toDate(n.range.start), dateStr: o.formatIso(n.range.start, { omitTime: n.allDay }), allDay: n.allDay })), i; } const xa = (function (e) {
    function t(t) {
      const n = e.call(this, t) || this; n.handlePointerDown = function (e) { const t = n.dragging; t.setIgnoreMove(!n.component.isValidDateDownEl(t.pointer.downEl)); }, n.handleDragEnd = function (e) {
        const t = n.component; if (!n.dragging.pointer.wasTouchScroll) {
          const o = n.hitDragging; const i = o.initialHit; const a = o.finalHit; if (i && a && ka(i, a)) {
            const s = t.context; const l = {
              ...Ma(i.dateSpan, s), dayEl: i.dayEl, jsEvent: e.origEvent, view: s.viewApi || s.calendarApi.view,
            }; s.emitter.trigger('dateClick', l);
          }
        }
      }, n.dragging = new wa(t.el), n.dragging.autoScroller.isEnabled = !1; const o = n.hitDragging = new Ta(n.dragging, li(t)); return o.emitter.on('pointerdown', n.handlePointerDown), o.emitter.on('dragend', n.handleDragEnd), n;
    } return n(t, e), t.prototype.destroy = function () { this.dragging.destroy(); }, t;
  }(ai)); const _a = (function (e) { function t(t) { const n = e.call(this, t) || this; n.dragSelection = null, n.handlePointerDown = function (e) { const t = n; const r = t.component; const o = t.dragging; const i = r.context.options.selectable && r.isValidDateDownEl(e.origEvent.target); o.setIgnoreMove(!i), o.delay = e.isTouch ? (function (e) { const t = e.context.options; let n = t.selectLongPressDelay; n == null && (n = t.longPressDelay); return n; }(r)) : null; }, n.handleDragStart = function (e) { n.component.context.calendarApi.unselect(e); }, n.handleHitUpdate = function (e, t) { const o = n.component.context; let i = null; let a = !1; e && ((i = (function (e, t, n) { const o = e.dateSpan; const i = t.dateSpan; const a = [o.range.start, o.range.end, i.range.start, i.range.end]; a.sort(ce); for (var s = {}, l = 0, u = n; l < u.length; l++) { const c = (0, u[l])(e, t); if (!1 === c) return null; c && r(s, c); } return s.range = { start: a[0], end: a[3] }, s.allDay = o.allDay, s; }(n.hitDragging.initialHit, e, o.pluginHooks.dateSelectionTransformers))) && n.component.isDateSelectionValid(i) || (a = !0, i = null)), i ? o.dispatch({ type: 'SELECT_DATES', selection: i }) : t || o.dispatch({ type: 'UNSELECT_DATES' }), a ? Q() : ee(), t || (n.dragSelection = i); }, n.handlePointerUp = function (e) { n.dragSelection && (xn(n.dragSelection, e, n.component.context), n.dragSelection = null); }; const o = t.component.context.options; const i = n.dragging = new wa(t.el); i.touchScrollAllowed = !1, i.minDistance = o.selectMinDistance || 0, i.autoScroller.isEnabled = o.dragScroll; const a = n.hitDragging = new Ta(n.dragging, li(t)); return a.emitter.on('pointerdown', n.handlePointerDown), a.emitter.on('dragstart', n.handleDragStart), a.emitter.on('hitupdate', n.handleHitUpdate), a.emitter.on('pointerup', n.handlePointerUp), n; } return n(t, e), t.prototype.destroy = function () { this.dragging.destroy(); }, t; }(ai)); const Ia = (function (e) {
    function t(n) {
      const o = e.call(this, n) || this; o.subjectEl = null, o.subjectSeg = null, o.isDragging = !1, o.eventRange = null, o.relevantEvents = null, o.receivingContext = null, o.validMutation = null, o.mutatedRelevantEvents = null, o.handlePointerDown = function (e) { const t = e.origEvent.target; const n = o; const r = n.component; const i = n.dragging; const a = i.mirror; const s = r.context.options; const l = r.context; o.subjectEl = e.subjectEl; const u = o.subjectSeg = dn(e.subjectEl); const c = (o.eventRange = u.eventRange).instance.instanceId; o.relevantEvents = Nt(l.getCurrentData().eventStore, c), i.minDistance = e.isTouch ? 0 : s.eventDragMinDistance, i.delay = e.isTouch && c !== r.props.eventSelection ? (function (e) { const t = e.context.options; let n = t.eventLongPressDelay; n == null && (n = t.longPressDelay); return n; }(r)) : null, a.parentNode = V(t, '.fc'), a.revertDuration = s.dragRevertDuration; const d = r.isValidSegDownEl(t) && !V(t, '.fc-event-resizer'); i.setIgnoreMove(!d), o.isDragging = d && e.subjectEl.classList.contains('fc-event-draggable'); }, o.handleDragStart = function (e) {
        const t = o.component.context; const n = o.eventRange; const r = n.instance.instanceId; e.isTouch ? r !== o.component.props.eventSelection && t.dispatch({ type: 'SELECT_EVENT', eventInstanceId: r }) : t.dispatch({ type: 'UNSELECT_EVENT' }), o.isDragging && (t.calendarApi.unselect(e), t.emitter.trigger('eventDragStart', {
          el: o.subjectEl, event: new zn(t, n.def, n.instance), jsEvent: e.origEvent, view: t.viewApi,
        }));
      }, o.handleHitUpdate = function (e, t) { if (o.isDragging) { const n = o.relevantEvents; const r = o.hitDragging.initialHit; const i = o.component.context; let a = null; let s = null; let l = null; let u = !1; const c = { affectedEvents: n, mutatedEvents: { defs: {}, instances: {} }, isEvent: !0 }; if (e) { const d = e.component; const p = (a = d.context).options; i === a || p.editable && p.droppable ? (s = (function (e, t, n) { const r = e.dateSpan; const o = t.dateSpan; let i = r.range.start; const a = o.range.start; const s = {}; r.allDay !== o.allDay && (s.allDay = o.allDay, s.hasEnd = t.component.context.options.allDayMaintainDuration, o.allDay && (i = be(i))); const l = Qt(i, a, e.component.context.dateEnv, e.component === t.component ? e.component.largeUnit : null); l.milliseconds && (s.allDay = !1); for (var u = { datesDelta: l, standardProps: s }, c = 0, d = n; c < d.length; c++) { (0, d[c])(u, e, t); } return u; }(r, e, a.getCurrentData().pluginHooks.eventDragMutationMassagers))) && (l = Pn(n, a.getCurrentData().eventUiBases, s, a), c.mutatedEvents = l, d.isInteractionValid(c) || (u = !0, s = null, l = null, c.mutatedEvents = { defs: {}, instances: {} })) : a = null; }o.displayDrag(a, c), u ? Q() : ee(), t || (i === a && ka(r, e) && (s = null), o.dragging.setMirrorNeedsRevert(!s), o.dragging.setMirrorIsVisible(!e || !document.querySelector('.fc-event-mirror')), o.receivingContext = a, o.validMutation = s, o.mutatedRelevantEvents = l); } }, o.handlePointerUp = function () { o.isDragging || o.cleanup(); }, o.handleDragEnd = function (e) {
        if (o.isDragging) {
          const t = o.component.context; const n = t.viewApi; const i = o; const a = i.receivingContext; const s = i.validMutation; const l = o.eventRange.def; const u = o.eventRange.instance; const c = new zn(t, l, u); const d = o.relevantEvents; const p = o.mutatedRelevantEvents; const f = o.hitDragging.finalHit; if (o.clearDrag(), t.emitter.trigger('eventDragStop', {
            el: o.subjectEl, event: c, jsEvent: e.origEvent, view: n,
          }), s) {
            if (a === t) {
              const h = new zn(t, p.defs[l.defId], u ? p.instances[u.instanceId] : null); t.dispatch({ type: 'MERGE_EVENTS', eventStore: p }); for (var v = {
                  oldEvent: c, event: h, relatedEvents: Bn(p, t, u), revert() { t.dispatch({ type: 'MERGE_EVENTS', eventStore: d }); },
                }, g = {}, m = 0, y = t.getCurrentData().pluginHooks.eventDropTransformers; m < y.length; m++) { const E = y[m]; r(g, E(s, t)); }t.emitter.trigger('eventDrop', {
                ...v, ...g, el: e.subjectEl, delta: s.datesDelta, jsEvent: e.origEvent, view: n,
              }), t.emitter.trigger('eventChange', v);
            } else if (a) {
              const S = { event: c, relatedEvents: Bn(d, t, u), revert() { t.dispatch({ type: 'MERGE_EVENTS', eventStore: d }); } }; t.emitter.trigger('eventLeave', { ...S, draggedEl: e.subjectEl, view: n }), t.dispatch({ type: 'REMOVE_EVENTS', eventStore: d }), t.emitter.trigger('eventRemove', S); const D = p.defs[l.defId]; const b = p.instances[u.instanceId]; const C = new zn(a, D, b); a.dispatch({ type: 'MERGE_EVENTS', eventStore: p }); const w = { event: C, relatedEvents: Bn(p, a, b), revert() { a.dispatch({ type: 'REMOVE_EVENTS', eventStore: p }); } }; a.emitter.trigger('eventAdd', w), e.isTouch && a.dispatch({ type: 'SELECT_EVENT', eventInstanceId: u.instanceId }), a.emitter.trigger('drop', {
                ...Ma(f.dateSpan, a), draggedEl: e.subjectEl, jsEvent: e.origEvent, view: f.component.context.viewApi,
              }), a.emitter.trigger('eventReceive', { ...w, draggedEl: e.subjectEl, view: f.component.context.viewApi });
            }
          } else t.emitter.trigger('_noEventDrop');
        }o.cleanup();
      }; const i = o.component.context.options; const a = o.dragging = new wa(n.el); a.pointer.selector = t.SELECTOR, a.touchScrollAllowed = !1, a.autoScroller.isEnabled = i.dragScroll; const s = o.hitDragging = new Ta(o.dragging, ui); return s.useSubjectCenter = n.useEventCenter, s.emitter.on('pointerdown', o.handlePointerDown), s.emitter.on('dragstart', o.handleDragStart), s.emitter.on('hitupdate', o.handleHitUpdate), s.emitter.on('pointerup', o.handlePointerUp), s.emitter.on('dragend', o.handleDragEnd), o;
    } return n(t, e), t.prototype.destroy = function () { this.dragging.destroy(); }, t.prototype.displayDrag = function (e, t) { const n = this.component.context; const r = this.receivingContext; r && r !== e && (r === n ? r.dispatch({ type: 'SET_EVENT_DRAG', state: { affectedEvents: t.affectedEvents, mutatedEvents: { defs: {}, instances: {} }, isEvent: !0 } }) : r.dispatch({ type: 'UNSET_EVENT_DRAG' })), e && e.dispatch({ type: 'SET_EVENT_DRAG', state: t }); }, t.prototype.clearDrag = function () { const e = this.component.context; const t = this.receivingContext; t && t.dispatch({ type: 'UNSET_EVENT_DRAG' }), e !== t && e.dispatch({ type: 'UNSET_EVENT_DRAG' }); }, t.prototype.cleanup = function () { this.subjectSeg = null, this.isDragging = !1, this.eventRange = null, this.relevantEvents = null, this.receivingContext = null, this.validMutation = null, this.mutatedRelevantEvents = null; }, t.SELECTOR = '.fc-event-draggable, .fc-event-resizable', t;
  }(ai)); const Pa = (function (e) {
    function t(t) {
      const n = e.call(this, t) || this; n.draggingSegEl = null, n.draggingSeg = null, n.eventRange = null, n.relevantEvents = null, n.validMutation = null, n.mutatedRelevantEvents = null, n.handlePointerDown = function (e) { const t = n.component; const r = dn(n.querySegEl(e)); const o = n.eventRange = r.eventRange; n.dragging.minDistance = t.context.options.eventDragMinDistance, n.dragging.setIgnoreMove(!n.component.isValidSegDownEl(e.origEvent.target) || e.isTouch && n.component.props.eventSelection !== o.instance.instanceId); }, n.handleDragStart = function (e) {
        const t = n.component.context; const r = n.eventRange; n.relevantEvents = Nt(t.getCurrentData().eventStore, n.eventRange.instance.instanceId); const o = n.querySegEl(e); n.draggingSegEl = o, n.draggingSeg = dn(o), t.calendarApi.unselect(), t.emitter.trigger('eventResizeStart', {
          el: o, event: new zn(t, r.def, r.instance), jsEvent: e.origEvent, view: t.viewApi,
        });
      }, n.handleHitUpdate = function (e, t, o) { const i = n.component.context; const a = n.relevantEvents; const s = n.hitDragging.initialHit; const l = n.eventRange.instance; let u = null; let c = null; let d = !1; const p = { affectedEvents: a, mutatedEvents: { defs: {}, instances: {} }, isEvent: !0 }; e && (u = (function (e, t, n, o, i) { for (var a = e.component.context.dateEnv, s = e.dateSpan.range.start, l = t.dateSpan.range.start, u = Qt(s, l, a, e.component.largeUnit), c = {}, d = 0, p = i; d < p.length; d++) { const f = (0, p[d])(e, t); if (!1 === f) return null; f && r(c, f); } if (n) { if (a.add(o.start, u) < o.end) return c.startDelta = u, c; } else if (a.add(o.end, u) > o.start) return c.endDelta = u, c; return null; }(s, e, o.subjectEl.classList.contains('fc-event-resizer-start'), l.range, i.pluginHooks.eventResizeJoinTransforms))), u && (c = Pn(a, i.getCurrentData().eventUiBases, u, i), p.mutatedEvents = c, n.component.isInteractionValid(p) || (d = !0, u = null, c = null, p.mutatedEvents = null)), c ? i.dispatch({ type: 'SET_EVENT_RESIZE', state: p }) : i.dispatch({ type: 'UNSET_EVENT_RESIZE' }), d ? Q() : ee(), t || (u && ka(s, e) && (u = null), n.validMutation = u, n.mutatedRelevantEvents = c); }, n.handleDragEnd = function (e) {
        const t = n.component.context; const o = n.eventRange.def; const i = n.eventRange.instance; const a = new zn(t, o, i); const s = n.relevantEvents; const l = n.mutatedRelevantEvents; if (t.emitter.trigger('eventResizeStop', {
          el: n.draggingSegEl, event: a, jsEvent: e.origEvent, view: t.viewApi,
        }), n.validMutation) {
          const u = new zn(t, l.defs[o.defId], i ? l.instances[i.instanceId] : null); t.dispatch({ type: 'MERGE_EVENTS', eventStore: l }); const c = {
            oldEvent: a, event: u, relatedEvents: Bn(l, t, i), revert() { t.dispatch({ type: 'MERGE_EVENTS', eventStore: s }); },
          }; t.emitter.trigger('eventResize', {
            ...c, el: n.draggingSegEl, startDelta: n.validMutation.startDelta || Ye(0), endDelta: n.validMutation.endDelta || Ye(0), jsEvent: e.origEvent, view: t.viewApi,
          }), t.emitter.trigger('eventChange', c);
        } else t.emitter.trigger('_noEventResize'); n.draggingSeg = null, n.relevantEvents = null, n.validMutation = null;
      }; const o = t.component; const i = n.dragging = new wa(t.el); i.pointer.selector = '.fc-event-resizer', i.touchScrollAllowed = !1, i.autoScroller.isEnabled = o.context.options.dragScroll; const a = n.hitDragging = new Ta(n.dragging, li(t)); return a.emitter.on('pointerdown', n.handlePointerDown), a.emitter.on('dragstart', n.handleDragStart), a.emitter.on('hitupdate', n.handleHitUpdate), a.emitter.on('dragend', n.handleDragEnd), n;
    } return n(t, e), t.prototype.destroy = function () { this.dragging.destroy(); }, t.prototype.querySegEl = function (e) { return V(e.subjectEl, '.fc-event'); }, t;
  }(ai)); const Na = (function () { function e(e) { const t = this; this.context = e, this.isRecentPointerDateSelect = !1, this.onSelect = function (e) { e.jsEvent && (t.isRecentPointerDateSelect = !0); }, this.onDocumentPointerUp = function (e) { const n = t.context; const r = t.documentPointer; const o = n.getCurrentData(); if (!r.wasTouchScroll) { if (o.dateSelection && !t.isRecentPointerDateSelect) { const i = n.options.unselectAuto; const a = n.options.unselectCancel; !i || i && V(r.downEl, a) || n.calendarApi.unselect(e); }o.eventSelection && !V(r.downEl, Ia.SELECTOR) && n.dispatch({ type: 'UNSELECT_EVENT' }); }t.isRecentPointerDateSelect = !1; }; const n = this.documentPointer = new ga(document); n.shouldIgnoreMove = !0, n.shouldWatchScroll = !1, n.emitter.on('pointerup', this.onDocumentPointerUp), e.emitter.on('select', this.onSelect); } return e.prototype.destroy = function () { this.context.emitter.off('select', this.onSelect), this.documentPointer.destroy(); }, e; }()); const Ha = {
    dateClick: _t, eventDragStart: _t, eventDragStop: _t, eventDrop: _t, eventResizeStart: _t, eventResizeStop: _t, eventResize: _t, drop: _t, eventReceive: _t, eventLeave: _t,
  }; const Oa = (function () {
    function e(e, t) {
      const n = this; this.receivingContext = null, this.droppableEvent = null, this.suppliedDragMeta = null, this.dragMeta = null, this.handleDragStart = function (e) { n.dragMeta = n.buildDragMeta(e.subjectEl); }, this.handleHitUpdate = function (e, t, o) { const i = n.hitDragging.dragging; let a = null; let s = null; let l = !1; const u = { affectedEvents: { defs: {}, instances: {} }, mutatedEvents: { defs: {}, instances: {} }, isEvent: n.dragMeta.create }; e && (a = e.component.context, n.canDropElOnCalendar(o.subjectEl, a) && (s = (function (e, t, n) { for (var o = { ...t.leftoverProps }, i = 0, a = n.pluginHooks.externalDefTransforms; i < a.length; i++) { const s = a[i]; r(o, s(e, t)); } const l = Yt(o, n); const u = l.refined; const c = l.extra; const d = Xt(u, c, t.sourceId, e.allDay, n.options.forceEventDuration || Boolean(t.duration), n); let p = e.range.start; e.allDay && t.startTime && (p = n.dateEnv.add(p, t.startTime)); const f = t.duration ? n.dateEnv.add(p, t.duration) : In(e.allDay, p, n); const h = Ie(d.defId, { start: p, end: f }); return { def: d, instance: h }; }(e.dateSpan, n.dragMeta, a)), u.mutatedEvents = Pt(s), (l = !Jr(u, a)) && (u.mutatedEvents = { defs: {}, instances: {} }, s = null))), n.displayDrag(a, u), i.setMirrorIsVisible(t || !s || !document.querySelector('.fc-event-mirror')), l ? Q() : ee(), t || (i.setMirrorNeedsRevert(!s), n.receivingContext = a, n.droppableEvent = s); }, this.handleDragEnd = function (e) {
        const t = n; const o = t.receivingContext; const i = t.droppableEvent; if (n.clearDrag(), o && i) {
          const a = n.hitDragging.finalHit; const s = a.component.context.viewApi; const l = n.dragMeta; if (o.emitter.trigger('drop', {
            ...Ma(a.dateSpan, o), draggedEl: e.subjectEl, jsEvent: e.origEvent, view: s,
          }), l.create) {
            const u = Pt(i); o.dispatch({ type: 'MERGE_EVENTS', eventStore: u }), e.isTouch && o.dispatch({ type: 'SELECT_EVENT', eventInstanceId: i.instance.instanceId }), o.emitter.trigger('eventReceive', {
              event: new zn(o, i.def, i.instance), relatedEvents: [], revert() { o.dispatch({ type: 'REMOVE_EVENTS', eventStore: u }); }, draggedEl: e.subjectEl, view: s,
            });
          }
        }n.receivingContext = null, n.droppableEvent = null;
      }; const o = this.hitDragging = new Ta(e, ui); o.requireInitial = !1, o.emitter.on('dragstart', this.handleDragStart), o.emitter.on('hitupdate', this.handleHitUpdate), o.emitter.on('dragend', this.handleDragEnd), this.suppliedDragMeta = t;
    } return e.prototype.buildDragMeta = function (e) { return typeof this.suppliedDragMeta === 'object' ? fi(this.suppliedDragMeta) : typeof this.suppliedDragMeta === 'function' ? fi(this.suppliedDragMeta(e)) : fi((t = (function (e, t) { const n = di.dataAttrPrefix; const r = (n ? `${n}-` : '') + t; return e.getAttribute(`data-${r}`) || ''; }(e, 'event'))) ? JSON.parse(t) : { create: !1 }); let t; }, e.prototype.displayDrag = function (e, t) { const n = this.receivingContext; n && n !== e && n.dispatch({ type: 'UNSET_EVENT_DRAG' }), e && e.dispatch({ type: 'SET_EVENT_DRAG', state: t }); }, e.prototype.clearDrag = function () { this.receivingContext && this.receivingContext.dispatch({ type: 'UNSET_EVENT_DRAG' }); }, e.prototype.canDropElOnCalendar = function (e, t) { const n = t.options.dropAccept; return typeof n === 'function' ? n.call(t.calendarApi, e) : typeof n !== 'string' || !n || Boolean(z(e, n)); }, e;
  }()); di.dataAttrPrefix = ''; const Aa = (function () { function e(e, t) { const n = this; void 0 === t && (t = {}), this.handlePointerDown = function (e) { const t = n.dragging; const r = n.settings; const o = r.minDistance; const i = r.longPressDelay; t.minDistance = o != null ? o : e.isTouch ? 0 : bt.eventDragMinDistance, t.delay = e.isTouch ? i != null ? i : bt.longPressDelay : 0; }, this.handleDragStart = function (e) { e.isTouch && n.dragging.delay && e.subjectEl.classList.contains('fc-event') && n.dragging.mirror.getMirrorEl().classList.add('fc-event-selected'); }, this.settings = t; const r = this.dragging = new wa(e); r.touchScrollAllowed = !1, t.itemSelector != null && (r.pointer.selector = t.itemSelector), t.appendTo != null && (r.mirror.parentNode = t.appendTo), r.emitter.on('pointerdown', this.handlePointerDown), r.emitter.on('dragstart', this.handleDragStart), new Oa(r, t.eventData); } return e.prototype.destroy = function () { this.dragging.destroy(); }, e; }()); const Ua = (function (e) { function t(t) { const n = e.call(this, t) || this; n.shouldIgnoreMove = !1, n.mirrorSelector = '', n.currentMirrorEl = null, n.handlePointerDown = function (e) { n.emitter.trigger('pointerdown', e), n.shouldIgnoreMove || n.emitter.trigger('dragstart', e); }, n.handlePointerMove = function (e) { n.shouldIgnoreMove || n.emitter.trigger('dragmove', e); }, n.handlePointerUp = function (e) { n.emitter.trigger('pointerup', e), n.shouldIgnoreMove || n.emitter.trigger('dragend', e); }; const r = n.pointer = new ga(t); return r.emitter.on('pointerdown', n.handlePointerDown), r.emitter.on('pointermove', n.handlePointerMove), r.emitter.on('pointerup', n.handlePointerUp), n; } return n(t, e), t.prototype.destroy = function () { this.pointer.destroy(); }, t.prototype.setIgnoreMove = function (e) { this.shouldIgnoreMove = e; }, t.prototype.setMirrorIsVisible = function (e) { if (e) this.currentMirrorEl && (this.currentMirrorEl.style.visibility = '', this.currentMirrorEl = null); else { const t = this.mirrorSelector ? document.querySelector(this.mirrorSelector) : null; t && (this.currentMirrorEl = t, t.style.visibility = 'hidden'); } }, t; }(ci)); const La = (function () { function e(e, t) { let n = document; e === document || e instanceof Element ? (n = e, t = t || {}) : t = e || {}; const r = this.dragging = new Ua(n); typeof t.itemSelector === 'string' ? r.pointer.selector = t.itemSelector : n === document && (r.pointer.selector = '[data-event]'), typeof t.mirrorSelector === 'string' && (r.mirrorSelector = t.mirrorSelector), new Oa(r, t.eventData); } return e.prototype.destroy = function () { this.dragging.destroy(); }, e; }()); const Wa = io({
    componentInteractions: [xa, _a, Ia, Pa], calendarInteractions: [Na], elementDraggingImpl: wa, listenerRefiners: Ha,
  }); const Va = (function (e) {
    function t() { const t = e !== null && e.apply(this, arguments) || this; return t.headerElRef = Ar(), t; } return n(t, e), t.prototype.renderSimpleLayout = function (e, t) {
      const n = this.props; const r = this.context; const o = []; const i = Ki(r.options); return e && o.push({
        type: 'header', key: 'header', isSticky: i, chunk: { elRef: this.headerElRef, tableClassName: 'fc-col-header', rowContent: e },
      }), o.push({
        type: 'body', key: 'body', liquid: !0, chunk: { content: t },
      }), Hr(yo, { viewSpec: r.viewSpec }, ((e, t) => Hr('div', { ref: e, className: ['fc-daygrid'].concat(t).join(' ') }, Hr($i, { liquid: !n.isHeightAuto && !n.forPrint, cols: [], sections: o }))));
    }, t.prototype.renderHScrollLayout = function (e, t, n, r) {
      const o = this.context.pluginHooks.scrollGridImpl; if (!o) throw new Error('No ScrollGrid implementation'); const i = this.props; const a = this.context; const s = !i.forPrint && Ki(a.options); const l = !i.forPrint && Ji(a.options); const u = []; return e && u.push({
        type: 'header',
        key: 'header',
        isSticky: s,
        chunks: [{
          key: 'main', elRef: this.headerElRef, tableClassName: 'fc-col-header', rowContent: e,
        }],
      }), u.push({
        type: 'body', key: 'body', liquid: !0, chunks: [{ key: 'main', content: t }],
      }), l && u.push({
        type: 'footer', key: 'footer', isSticky: !0, chunks: [{ key: 'main', content: Xi }],
      }), Hr(yo, { viewSpec: a.viewSpec }, ((e, t) => Hr('div', { ref: e, className: ['fc-daygrid'].concat(t).join(' ') }, Hr(o, { liquid: !i.isHeightAuto && !i.forPrint, colGroups: [{ cols: [{ span: n, minWidth: r }] }], sections: u }))));
    }, t;
  }(oo)); function za(e, t) { for (var n = [], r = 0; r < t; r++)n[r] = []; for (let o = 0, i = e; o < i.length; o++) { const a = i[o]; n[a.row].push(a); } return n; } function Fa(e, t) { for (var n = [], r = 0; r < t; r++)n[r] = []; for (let o = 0, i = e; o < i.length; o++) { const a = i[o]; n[a.firstCol].push(a); } return n; } function Ba(e, t) { const n = []; if (e) { for (a = 0; a < t; a++)n[a] = { affectedInstances: e.affectedInstances, isEvent: e.isEvent, segs: [] }; for (let r = 0, o = e.segs; r < o.length; r++) { const i = o[r]; n[i.row].segs.push(i); } } else for (var a = 0; a < t; a++)n[a] = null; return n; } const ja = St({ week: 'narrow' }); const Ga = (function (e) {
    function t() {
      const t = e !== null && e.apply(this, arguments) || this; return t.handleRootEl = function (e) { t.rootEl = e, Yr(t.props.elRef, e); }, t.handleMoreLinkClick = function (e) {
        const n = t.props; if (n.onMoreClick) {
          const r = n.segsByEachCol; const o = r.filter(((e) => n.segIsHidden[e.eventRange.instance.instanceId])); n.onMoreClick({
            date: n.date, allSegs: r, hiddenSegs: o, moreCnt: n.moreCnt, dayEl: t.rootEl, ev: e,
          });
        }
      }, t;
    } return n(t, e), t.prototype.render = function () {
      const e = this; const t = this.context; const n = t.options; const o = t.viewApi; const i = this.props; const a = i.date; const s = i.dateProfile; const l = { num: i.moreCnt, text: i.buildMoreLinkText(i.moreCnt), view: o }; const u = n.navLinks ? { 'data-navlink': gr(a, 'week'), tabIndex: 0 } : {}; return Hr(oa, {
        date: a, dateProfile: s, todayRange: i.todayRange, showDayNumber: i.showDayNumber, extraHookProps: i.extraHookProps, elRef: this.handleRootEl,
      }, ((t, o, c, d) => Hr('td', {
        ref: t, className: ['fc-daygrid-day'].concat(o, i.extraClassNames || []).join(' '), ...c, ...i.extraDataAttrs,
      }, Hr('div', { className: 'fc-daygrid-day-frame fc-scrollgrid-sync-inner', ref: i.innerElRef }, i.showWeekNumber && Hr(ca, { date: a, defaultFormat: ja }, ((e, t, n, o) => Hr('a', { ref: e, className: ['fc-daygrid-week-number'].concat(t).join(' '), ...u }, o))), !d && Hr(Za, {
        date: a, dateProfile: s, showDayNumber: i.showDayNumber, todayRange: i.todayRange, extraHookProps: i.extraHookProps,
      }), Hr('div', { className: 'fc-daygrid-day-events', ref: i.fgContentElRef, style: { paddingBottom: i.fgPaddingBottom } }, i.fgContent, Boolean(i.moreCnt) && Hr('div', { className: 'fc-daygrid-day-bottom', style: { marginTop: i.moreMarginTop } }, Hr(uo, {
        hookProps: l, classNames: n.moreLinkClassNames, content: n.moreLinkContent, defaultContent: Ya, didMount: n.moreLinkDidMount, willUnmount: n.moreLinkWillUnmount,
      }, ((t, n, r, o) => Hr('a', { onClick: e.handleMoreLinkClick, ref: t, className: ['fc-daygrid-more-link'].concat(n).join(' ') }, o))))), Hr('div', { className: 'fc-daygrid-day-bg' }, i.bgContent)))));
    }, t;
  }(oo)); function qa(e) { return e.dayNumberText; } function Ya(e) { return e.text; } var Za = (function (e) {
    function t() { return e !== null && e.apply(this, arguments) || this; } return n(t, e), t.prototype.render = function () {
      const e = this.props; const t = this.context.options.navLinks ? { 'data-navlink': gr(e.date), tabIndex: 0 } : {}; return Hr(ia, {
        date: e.date, dateProfile: e.dateProfile, todayRange: e.todayRange, showDayNumber: e.showDayNumber, extraHookProps: e.extraHookProps, defaultContent: qa,
      }, ((e, n) => n && Hr('div', { className: 'fc-daygrid-day-top', ref: e }, Hr('a', { className: 'fc-daygrid-day-number', ...t }, n))));
    }, t;
  }(jr)); const Xa = St({
    hour: 'numeric', minute: '2-digit', omitZeroMinute: !0, meridiem: 'narrow',
  }); function Ka(e) { const t = e.eventRange.ui.display; return t === 'list-item' || t === 'auto' && !e.eventRange.def.allDay && e.firstCol === e.lastCol && e.isStart && e.isEnd; } const Ja = (function (e) {
    function t() { return e !== null && e.apply(this, arguments) || this; } return n(t, e), t.prototype.render = function () {
      const e = this.props; const t = this.context; const n = t.options.eventTimeFormat || Xa; const o = En(e.seg, n, t, !0, e.defaultDisplayEventEnd); return Hr(Qi, {
        seg: e.seg, timeText: o, defaultContent: $a, isDragging: e.isDragging, isResizing: !1, isDateSelecting: !1, isSelected: e.isSelected, isPast: e.isPast, isFuture: e.isFuture, isToday: e.isToday,
      }, ((t, n, o, i) => { return Hr('a', { className: ['fc-daygrid-event', 'fc-daygrid-dot-event'].concat(n).join(' '), ref: t, ...(a = e.seg, (s = a.eventRange.def.url) ? { href: s } : {}) }, i); let a; let s; }));
    }, t;
  }(jr)); function $a(e) { return Hr(Ur, null, Hr('div', { className: 'fc-daygrid-event-dot', style: { borderColor: e.borderColor || e.backgroundColor } }), e.timeText && Hr('div', { className: 'fc-event-time' }, e.timeText), Hr('div', { className: 'fc-event-title' }, e.event.title || Hr(Ur, null, ' '))); } const Qa = (function (e) {
    function t() { return e !== null && e.apply(this, arguments) || this; } return n(t, e), t.prototype.render = function () {
      const e = this.props; return Hr(ea, {
        ...e, extraClassNames: ['fc-daygrid-event', 'fc-daygrid-block-event', 'fc-h-event'], defaultTimeFormat: Xa, defaultDisplayEventEnd: e.defaultDisplayEventEnd, disableResizing: !e.seg.eventRange.def.allDay,
      });
    }, t;
  }(jr)); function es(e, t, n, o, i, a, s, l) {
    for (var u = [], c = [], d = {}, p = {}, f = {}, h = {}, v = {}, g = 0; g < s; g++)u.push([]), c.push(0); for (let m = 0, y = t = hn(t, l); m < y.length; m++) { T(w = y[m], i[`${w.eventRange.instance.instanceId}:${w.firstCol}`] || 0); }!0 === n || !0 === o ? (function (e, t, n, r) { ns(e, t, n, !0, ((e) => e.bottom <= r)); }(c, d, u, a)) : typeof n === 'number' ? (function (e, t, n, r) { ns(e, t, n, !1, ((e, t) => t < r)); }(c, d, u, n)) : typeof o === 'number' && (function (e, t, n, r) { ns(e, t, n, !0, ((e, t) => t < r)); }(c, d, u, o)); for (let E = 0; E < s; E++) { for (var S = 0, D = 0, b = 0, C = u[E]; b < C.length; b++) { var w; const R = C[b]; d[(w = R.seg).eventRange.instance.instanceId] || (p[w.eventRange.instance.instanceId] = R.top, w.firstCol === w.lastCol && w.isStart && w.isEnd ? (f[w.eventRange.instance.instanceId] = R.top - S, D = 0, S = R.bottom) : D += R.bottom - R.top); }D && (c[E] ? h[E] = D : v[E] = D); } function T(e, t) { if (!k(e, t, 0)) for (let n = e.firstCol; n <= e.lastCol; n++) for (let r = 0, o = u[n]; r < o.length; r++) { if (k(e, t, o[r].bottom)) return; } } function k(e, t, n) { if (function (e, t, n) { for (let r = e.firstCol; r <= e.lastCol; r++) for (let o = 0, i = u[r]; o < i.length; o++) { const a = i[o]; if (n < a.bottom && n + t > a.top) return !1; } return !0; }(e, t, n)) { for (let r = e.firstCol; r <= e.lastCol; r++) { for (var o = u[r], i = 0; i < o.length && n >= o[i].top;)i++; o.splice(i, 0, { seg: e, top: n, bottom: n + t }); } return !0; } return !1; } for (const M in i)i[M] || (d[M.split(':')[0]] = !0); return {
      segsByFirstCol: u.map(ts),
      segsByEachCol: u.map(((t, n) => {
        let o = (function (e) { for (var t = [], n = 0, r = e; n < r.length; n++) { const o = r[n]; t.push(o.seg); } return t; }(t)); return o = (function (e, t, n) {
          for (var o = t, i = ve(o, 1), a = { start: o, end: i }, s = [], l = 0, u = e; l < u.length; l++) {
            const c = u[l]; const d = c.eventRange; const p = d.range; const f = nn(p, a); f && s.push({
              ...c,
              firstCol: n,
              lastCol: n,
              eventRange: {
                def: d.def, ui: { ...d.ui, durationEditable: !1 }, instance: d.instance, range: f,
              },
              isStart: c.isStart && f.start.valueOf() === p.start.valueOf(),
              isEnd: c.isEnd && f.end.valueOf() === p.end.valueOf(),
            });
          } return s;
        }(o, e[n].date, n));
      })),
      segIsHidden: d,
      segTops: p,
      segMarginTops: f,
      moreCnts: c,
      moreTops: h,
      paddingBottoms: v,
    };
  } function ts(e, t) { for (var n = [], r = 0, o = e; r < o.length; r++) { const i = o[r]; i.seg.firstCol === t && n.push(i.seg); } return n; } function ns(e, t, n, r, o) { for (var i = e.length, a = {}, s = [], l = 0; l < i; l++)s.push([]); for (l = 0; l < i; l++) for (let u = 0, c = 0, d = n[l]; c < d.length; c++) { const p = d[c]; o(p, u) ? f(p) : h(p), p.top !== p.bottom && u++; } function f(e) { const t = e.seg; const n = t.eventRange.instance.instanceId; if (!a[n]) { a[n] = !0; for (let r = t.firstCol; r <= t.lastCol; r++)s[r].push(e); } } function h(n) { const o = n.seg; const i = o.eventRange.instance.instanceId; if (!t[i]) { t[i] = !0; for (let a = o.firstCol; a <= o.lastCol; a++) { const l = ++e[a]; if (r && l === 1) { const u = s[a].pop(); u && h(u); } } } } } const rs = (function (e) {
    function t() { const t = e !== null && e.apply(this, arguments) || this; return t.cellElRefs = new Li(), t.frameElRefs = new Li(), t.fgElRefs = new Li(), t.segHarnessRefs = new Li(), t.rootElRef = Ar(), t.state = { framePositions: null, maxContentHeight: null, segHeights: {} }, t; } return n(t, e), t.prototype.render = function () {
      const e = this; const t = this.props; const n = this.state; const r = this.context; const o = t.cells.length; const i = Fa(t.businessHourSegs, o); const a = Fa(t.bgEventSegs, o); const s = Fa(this.getHighlightSegs(), o); const l = Fa(this.getMirrorSegs(), o); const u = es(t.cells, t.fgEventSegs, t.dayMaxEvents, t.dayMaxEventRows, n.segHeights, n.maxContentHeight, o, r.options.eventOrder); const c = u.paddingBottoms; const d = u.segsByFirstCol; const p = u.segsByEachCol; const f = u.segIsHidden; const h = u.segTops; const v = u.segMarginTops; const g = u.moreCnts; const m = u.moreTops; const y = t.eventDrag && t.eventDrag.affectedInstances || t.eventResize && t.eventResize.affectedInstances || {}; return Hr('tr', { ref: this.rootElRef }, t.renderIntro && t.renderIntro(), t.cells.map(((n, r) => {
        const o = e.renderFgSegs(d[r], f, h, v, y, t.todayRange); const u = e.renderFgSegs(l[r], {}, h, {}, {}, t.todayRange, Boolean(t.eventDrag), Boolean(t.eventResize), !1); const E = t.showWeekNumbers && r === 0; return Hr(Ga, {
          key: n.key, elRef: e.cellElRefs.createRef(n.key), innerElRef: e.frameElRefs.createRef(n.key), dateProfile: t.dateProfile, date: n.date, showDayNumber: t.showDayNumbers || E, showWeekNumber: E, todayRange: t.todayRange, extraHookProps: n.extraHookProps, extraDataAttrs: n.extraDataAttrs, extraClassNames: n.extraClassNames, moreCnt: g[r], buildMoreLinkText: t.buildMoreLinkText, onMoreClick: t.onMoreClick, segIsHidden: f, moreMarginTop: m[r], segsByEachCol: p[r], fgPaddingBottom: c[r], fgContentElRef: e.fgElRefs.createRef(n.key), fgContent: Hr(Ur, null, Hr(Ur, null, o), Hr(Ur, null, u)), bgContent: Hr(Ur, null, e.renderFillSegs(s[r], 'highlight'), e.renderFillSegs(i[r], 'non-business'), e.renderFillSegs(a[r], 'bg-event')),
        });
      })));
    }, t.prototype.componentDidMount = function () { this.updateSizing(!0); }, t.prototype.componentDidUpdate = function (e, t) { const n = this.props; this.updateSizing(!Le(e, n)); }, t.prototype.getHighlightSegs = function () { const e = this.props; return e.eventDrag && e.eventDrag.segs.length ? e.eventDrag.segs : e.eventResize && e.eventResize.segs.length ? e.eventResize.segs : e.dateSelectionSegs; }, t.prototype.getMirrorSegs = function () { const e = this.props; return e.eventResize && e.eventResize.segs.length ? e.eventResize.segs : []; }, t.prototype.renderFgSegs = function (e, t, n, o, i, a, s, l, u) {
      const c = this.context; const d = this.props.eventSelection; const p = this.state.framePositions; const f = this.props.cells.length === 1; const h = []; if (p) {
        for (let v = 0, g = e; v < g.length; v++) {
          const m = g[v]; const y = m.eventRange.instance.instanceId; const E = s || l || u; const S = i[y]; const D = t[y] || S; const b = t[y] || E || m.firstCol !== m.lastCol || !m.isStart || !m.isEnd; let C = void 0; let w = void 0; let R = void 0; let T = void 0; b ? (w = n[y], c.isRtl ? (T = 0, R = p.lefts[m.lastCol] - p.lefts[m.firstCol]) : (R = 0, T = p.rights[m.firstCol] - p.rights[m.lastCol])) : C = o[y], h.push(Hr('div', {
            className: `fc-daygrid-event-harness${b ? ' fc-daygrid-event-harness-abs' : ''}`,
            key: y,
            ref: E ? null : this.segHarnessRefs.createRef(`${y}:${m.firstCol}`),
            style: {
              visibility: D ? 'hidden' : '', marginTop: C || '', top: w || '', left: R || '', right: T || '',
            },
          }, Ka(m) ? Hr(Ja, {
            seg: m, isDragging: s, isSelected: y === d, defaultDisplayEventEnd: f, ...Sn(m, a),
          }) : Hr(Qa, {
            seg: m, isDragging: s, isResizing: l, isDateSelecting: u, isSelected: y === d, defaultDisplayEventEnd: f, ...Sn(m, a),
          })));
        }
      } return h;
    }, t.prototype.renderFillSegs = function (e, t) { const n = this.context.isRtl; const i = this.props.todayRange; const a = this.state.framePositions; const s = []; if (a) for (let l = 0, u = e; l < u.length; l++) { const c = u[l]; const d = n ? { right: 0, left: a.lefts[c.lastCol] - a.lefts[c.firstCol] } : { left: 0, right: a.rights[c.firstCol] - a.rights[c.lastCol] }; s.push(Hr('div', { key: bn(c.eventRange), className: 'fc-daygrid-bg-harness', style: d }, t === 'bg-event' ? Hr(la, { seg: c, ...Sn(c, i) }) : sa(t))); } return Hr.apply(void 0, o([Ur, {}], s)); }, t.prototype.updateSizing = function (e) { const t = this.props; const n = this.frameElRefs; if (t.clientWidth !== null) { if (e) { const r = t.cells.map(((e) => n.currentMap[e.key])); if (r.length) { const o = this.rootElRef.current; this.setState({ framePositions: new Mr(o, r, !0, !1) }); } } const i = !0 === t.dayMaxEvents || !0 === t.dayMaxEventRows; this.setState({ segHeights: this.computeSegHeights(), maxContentHeight: i ? this.computeMaxContentHeight() : null }); } }, t.prototype.computeSegHeights = function () { return Oe(this.segHarnessRefs.currentMap, ((e) => e.getBoundingClientRect().height)); }, t.prototype.computeMaxContentHeight = function () { const e = this.props.cells[0].key; const t = this.cellElRefs.currentMap[e]; const n = this.fgElRefs.currentMap[e]; return t.getBoundingClientRect().bottom - n.getBoundingClientRect().top; }, t.prototype.getCellEls = function () { const e = this.cellElRefs.currentMap; return this.props.cells.map(((t) => e[t.key])); }, t;
  }(oo)); rs.addStateEquality({ segHeights: Le }); const os = (function (e) { function t() { const t = e !== null && e.apply(this, arguments) || this; return t.repositioner = new Go(t.updateSize.bind(t)), t.handleRootEl = function (e) { t.rootEl = e, t.props.elRef && Yr(t.props.elRef, e); }, t.handleDocumentMousedown = function (e) { const n = t.props.onClose; n && !t.rootEl.contains(e.target) && n(); }, t.handleDocumentScroll = function () { t.repositioner.request(10); }, t.handleCloseClick = function () { const e = t.props.onClose; e && e(); }, t; } return n(t, e), t.prototype.render = function () { const e = this.context.theme; const t = this.props; const n = ['fc-popover', e.getClass('popover')].concat(t.extraClassNames || []); return Hr('div', { className: n.join(' '), ...t.extraAttrs, ref: this.handleRootEl }, Hr('div', { className: `fc-popover-header ${e.getClass('popoverHeader')}` }, Hr('span', { className: 'fc-popover-title' }, t.title), Hr('span', { className: `fc-popover-close ${e.getIconClass('close')}`, onClick: this.handleCloseClick })), Hr('div', { className: `fc-popover-body ${e.getClass('popoverContent')}` }, t.children)); }, t.prototype.componentDidMount = function () { document.addEventListener('mousedown', this.handleDocumentMousedown), document.addEventListener('scroll', this.handleDocumentScroll), this.updateSize(); }, t.prototype.componentWillUnmount = function () { document.removeEventListener('mousedown', this.handleDocumentMousedown), document.removeEventListener('scroll', this.handleDocumentScroll); }, t.prototype.updateSize = function () { const e = this.props; const t = e.alignmentEl; const n = e.topAlignmentEl; const r = this.rootEl; if (r) { let o; const i = r.getBoundingClientRect(); const a = t.getBoundingClientRect(); let s = n ? n.getBoundingClientRect().top : a.top; s = Math.min(s, window.innerHeight - i.height - 10), s = Math.max(s, 10), o = this.context.isRtl ? a.right - i.width : a.left, o = Math.min(o, window.innerWidth - i.width - 10), j(r, { top: s, left: o = Math.max(o, 10) }); } }, t; }(jr)); const is = (function (e) {
    function t() { const t = e !== null && e.apply(this, arguments) || this; return t.handlePopoverEl = function (e) { t.popoverEl = e, e ? t.context.registerInteractiveComponent(t, { el: e, useEventCenter: !1 }) : t.context.unregisterInteractiveComponent(t); }, t; } return n(t, e), t.prototype.render = function () {
      const e = this.context; const t = e.options; const n = e.dateEnv; const o = this.props; const i = o.date; const a = o.hiddenInstances; const s = o.todayRange; const l = o.dateProfile; const u = o.selectedInstanceId; const c = n.format(i, t.dayPopoverFormat); return Hr(oa, {
        date: i, dateProfile: l, todayRange: s, elRef: this.handlePopoverEl,
      }, ((e, t, n) => Hr(os, {
        elRef: e, title: c, extraClassNames: ['fc-more-popover'].concat(t), extraAttrs: n, onClose: o.onCloseClick, alignmentEl: o.alignmentEl, topAlignmentEl: o.topAlignmentEl,
      }, Hr(ia, { date: i, dateProfile: l, todayRange: s }, ((e, t) => t && Hr('div', { className: 'fc-more-popover-misc', ref: e }, t))), o.segs.map(((e) => {
        const t = e.eventRange.instance.instanceId; return Hr('div', { className: 'fc-daygrid-event-harness', key: t, style: { visibility: a[t] ? 'hidden' : '' } }, Ka(e) ? Hr(Ja, {
          seg: e, isDragging: !1, isSelected: t === u, defaultDisplayEventEnd: !1, ...Sn(e, s),
        }) : Hr(Qa, {
          seg: e, isDragging: !1, isResizing: !1, isDateSelecting: !1, isSelected: t === u, defaultDisplayEventEnd: !1, ...Sn(e, s),
        }));
      })))));
    }, t.prototype.queryHit = function (e, t, n, r) {
      const o = this.props.date; if (e < n && t < r) {
        return {
          component: this,
          dateSpan: { allDay: !0, range: { start: o, end: ve(o, 1) } },
          dayEl: this.popoverEl,
          rect: {
            left: 0, top: 0, right: n, bottom: r,
          },
          layer: 1,
        };
      }
    }, t.prototype.isPopover = function () { return !0; }, t;
  }(oo)); const as = (function (e) {
    function t() {
      const t = e !== null && e.apply(this, arguments) || this; return t.splitBusinessHourSegs = it(za), t.splitBgEventSegs = it(za), t.splitFgEventSegs = it(za), t.splitDateSelectionSegs = it(za), t.splitEventDrag = it(Ba), t.splitEventResize = it(Ba), t.buildBuildMoreLinkText = it(ss), t.rowRefs = new Li(), t.state = { morePopoverState: null }, t.handleRootEl = function (e) { t.rootEl = e, Yr(t.props.elRef, e); }, t.handleMoreLinkClick = function (e) {
        const n = t.context; const o = n.dateEnv; let i = n.options.moreLinkClick; function a(e) {
          const t = e.eventRange; const r = t.def; const i = t.instance; const a = t.range; return {
            event: new zn(n, r, i), start: o.toDate(a.start), end: o.toDate(a.end), isStart: e.isStart, isEnd: e.isEnd,
          };
        } typeof i === 'function' && (i = i({
          date: o.toDate(e.date), allDay: !0, allSegs: e.allSegs.map(a), hiddenSegs: e.hiddenSegs.map(a), jsEvent: e.ev, view: n.viewApi,
        })), i && i !== 'popover' ? typeof i === 'string' && n.calendarApi.zoomTo(e.date, i) : t.setState({ morePopoverState: { ...e, currentFgEventSegs: t.props.fgEventSegs } });
      }, t.handleMorePopoverClose = function () { t.setState({ morePopoverState: null }); }, t;
    } return n(t, e), t.prototype.render = function () {
      const e = this; const t = this.props; const n = t.dateProfile; let r = t.dayMaxEventRows; let o = t.dayMaxEvents; const i = t.expandRows; const a = this.state.morePopoverState; const s = t.cells.length; const l = this.splitBusinessHourSegs(t.businessHourSegs, s); const u = this.splitBgEventSegs(t.bgEventSegs, s); const c = this.splitFgEventSegs(t.fgEventSegs, s); const d = this.splitDateSelectionSegs(t.dateSelectionSegs, s); const p = this.splitEventDrag(t.eventDrag, s); const f = this.splitEventResize(t.eventResize, s); const h = this.buildBuildMoreLinkText(this.context.options.moreLinkText); let v = !0 === o || !0 === r; return v && !i && (v = !1, r = null, o = null), Hr('div', { className: ['fc-daygrid-body', v ? 'fc-daygrid-body-balanced' : 'fc-daygrid-body-unbalanced', i ? '' : 'fc-daygrid-body-natural'].join(' '), ref: this.handleRootEl, style: { width: t.clientWidth, minWidth: t.tableMinWidth } }, Hr(Mi, { unit: 'day' }, ((v, g) => Hr(Ur, null, Hr('table', { className: 'fc-scrollgrid-sync-table', style: { width: t.clientWidth, minWidth: t.tableMinWidth, height: i ? t.clientHeight : '' } }, t.colGroupNode, Hr('tbody', null, t.cells.map(((i, a) => Hr(rs, {
        ref: e.rowRefs.createRef(a), key: i.length ? i[0].date.toISOString() : a, showDayNumbers: s > 1, showWeekNumbers: t.showWeekNumbers, todayRange: g, dateProfile: n, cells: i, renderIntro: t.renderRowIntro, businessHourSegs: l[a], eventSelection: t.eventSelection, bgEventSegs: u[a].filter(ls), fgEventSegs: c[a], dateSelectionSegs: d[a], eventDrag: p[a], eventResize: f[a], dayMaxEvents: o, dayMaxEventRows: r, clientWidth: t.clientWidth, clientHeight: t.clientHeight, buildMoreLinkText: h, onMoreClick: e.handleMoreLinkClick,
      }))))), !t.forPrint && a && a.currentFgEventSegs === t.fgEventSegs && Hr(is, {
        date: a.date, dateProfile: n, segs: a.allSegs, alignmentEl: a.dayEl, topAlignmentEl: s === 1 ? t.headerAlignElRef.current : null, onCloseClick: e.handleMorePopoverClose, selectedInstanceId: t.eventSelection, hiddenInstances: (t.eventDrag ? t.eventDrag.affectedInstances : null) || (t.eventResize ? t.eventResize.affectedInstances : null) || {}, todayRange: g,
      })))));
    }, t.prototype.prepareHits = function () { this.rowPositions = new Mr(this.rootEl, this.rowRefs.collect().map(((e) => e.getCellEls()[0])), !1, !0), this.colPositions = new Mr(this.rootEl, this.rowRefs.currentMap[0].getCellEls(), !0, !1); }, t.prototype.positionToHit = function (e, t) {
      const n = this.colPositions; const r = this.rowPositions; const o = n.leftToIndex(e); const i = r.topToIndex(t); if (i != null && o != null) {
        return {
          row: i,
          col: o,
          dateSpan: { range: this.getCellRange(i, o), allDay: !0 },
          dayEl: this.getCellEl(i, o),
          relativeRect: {
            left: n.lefts[o], right: n.rights[o], top: r.tops[i], bottom: r.bottoms[i],
          },
        };
      }
    }, t.prototype.getCellEl = function (e, t) { return this.rowRefs.currentMap[e].getCellEls()[t]; }, t.prototype.getCellRange = function (e, t) { const n = this.props.cells[e][t].date; return { start: n, end: ve(n, 1) }; }, t;
  }(oo)); function ss(e) { return typeof e === 'function' ? e : function (t) { return `+${t} ${e}`; }; } function ls(e) { return e.eventRange.def.allDay; } const us = (function (e) {
    function t() { const t = e !== null && e.apply(this, arguments) || this; return t.slicer = new cs(), t.tableRef = Ar(), t.handleRootEl = function (e) { e ? t.context.registerInteractiveComponent(t, { el: e }) : t.context.unregisterInteractiveComponent(t); }, t; } return n(t, e), t.prototype.render = function () {
      const e = this.props; const t = this.context; return Hr(as, {
        ref: this.tableRef, elRef: this.handleRootEl, ...this.slicer.sliceProps(e, e.dateProfile, e.nextDayThreshold, t, e.dayTableModel), dateProfile: e.dateProfile, cells: e.dayTableModel.cells, colGroupNode: e.colGroupNode, tableMinWidth: e.tableMinWidth, renderRowIntro: e.renderRowIntro, dayMaxEvents: e.dayMaxEvents, dayMaxEventRows: e.dayMaxEventRows, showWeekNumbers: e.showWeekNumbers, expandRows: e.expandRows, headerAlignElRef: e.headerAlignElRef, clientWidth: e.clientWidth, clientHeight: e.clientHeight, forPrint: e.forPrint,
      });
    }, t.prototype.prepareHits = function () { this.tableRef.current.prepareHits(); }, t.prototype.queryHit = function (e, t) {
      const n = this.tableRef.current.positionToHit(e, t); if (n) {
        return {
          component: this,
          dateSpan: n.dateSpan,
          dayEl: n.dayEl,
          rect: {
            left: n.relativeRect.left, right: n.relativeRect.right, top: n.relativeRect.top, bottom: n.relativeRect.bottom,
          },
          layer: 0,
        };
      }
    }, t;
  }(oo)); var cs = (function (e) { function t() { const t = e !== null && e.apply(this, arguments) || this; return t.forceDayIfListItem = !0, t; } return n(t, e), t.prototype.sliceRange = function (e, t) { return t.sliceRange(e); }, t; }(Hi)); const ds = (function (e) {
    function t() { const t = e !== null && e.apply(this, arguments) || this; return t.buildDayTableModel = it(ps), t.headerRef = Ar(), t.tableRef = Ar(), t; } return n(t, e), t.prototype.render = function () {
      const e = this; const t = this.context; const n = t.options; const r = t.dateProfileGenerator; const o = this.props; const i = this.buildDayTableModel(o.dateProfile, r); const a = n.dayHeaders && Hr(_i, {
        ref: this.headerRef, dateProfile: o.dateProfile, dates: i.headerDates, datesRepDistinctDays: i.rowCnt === 1,
      }); const s = function (t) {
        return Hr(us, {
          ref: e.tableRef, dateProfile: o.dateProfile, dayTableModel: i, businessHours: o.businessHours, dateSelection: o.dateSelection, eventStore: o.eventStore, eventUiBases: o.eventUiBases, eventSelection: o.eventSelection, eventDrag: o.eventDrag, eventResize: o.eventResize, nextDayThreshold: n.nextDayThreshold, colGroupNode: t.tableColGroupNode, tableMinWidth: t.tableMinWidth, dayMaxEvents: n.dayMaxEvents, dayMaxEventRows: n.dayMaxEventRows, showWeekNumbers: n.weekNumbers, expandRows: !o.isHeightAuto, headerAlignElRef: e.headerElRef, clientWidth: t.clientWidth, clientHeight: t.clientHeight, forPrint: o.forPrint,
        });
      }; return n.dayMinWidth ? this.renderHScrollLayout(a, s, i.colCnt, n.dayMinWidth) : this.renderSimpleLayout(a, s);
    }, t;
  }(Va)); function ps(e, t) { const n = new Pi(e.renderRange, t); return new Ni(n, /year|month|week/.test(e.currentRangeUnit)); } const fs = io({
    initialView: 'dayGridMonth',
    optionRefiners: {
      moreLinkClick: _t, moreLinkClassNames: _t, moreLinkContent: _t, moreLinkDidMount: _t, moreLinkWillUnmount: _t,
    },
    views: {
      dayGrid: { component: ds, dateProfileGeneratorClass: (function (e) { function t() { return e !== null && e.apply(this, arguments) || this; } return n(t, e), t.prototype.buildRenderRange = function (t, n, r) { let o; const i = this.props.dateEnv; const a = e.prototype.buildRenderRange.call(this, t, n, r); let s = a.start; let l = a.end; (/^(year|month)$/.test(n) && (s = i.startOfWeek(s), (o = i.startOfWeek(l)).valueOf() !== l.valueOf() && (l = he(o, 1))), this.props.monthMode && this.props.fixedWeekCount) && (l = he(l, 6 - Math.ceil(me(s, l)))); return { start: s, end: l }; }, t; }(Co)) },
      dayGridDay: { type: 'dayGrid', duration: { days: 1 } },
      dayGridWeek: { type: 'dayGrid', duration: { weeks: 1 } },
      dayGridMonth: {
        type: 'dayGrid', duration: { months: 1 }, monthMode: !0, fixedWeekCount: !0,
      },
    },
  }); const hs = (function (e) { function t() { return e !== null && e.apply(this, arguments) || this; } return n(t, e), t.prototype.getKeyInfo = function () { return { allDay: {}, timed: {} }; }, t.prototype.getKeysForDateSpan = function (e) { return e.allDay ? ['allDay'] : ['timed']; }, t.prototype.getKeysForEventDef = function (e) { return e.allDay ? un(e) ? ['timed', 'allDay'] : ['allDay'] : ['timed']; }, t; }(pr)); const vs = (function () { function e(e, t, n) { this.positions = e, this.dateProfile = t, this.slatMetas = n; } return e.prototype.safeComputeTop = function (e) { const t = this.dateProfile; if (sn(t.currentRange, e)) { const n = be(e); const r = e.valueOf() - n.valueOf(); if (r >= $e(t.slotMinTime) && r < $e(t.slotMaxTime)) return this.computeTimeTop(Ye(r)); } }, e.prototype.computeDateTop = function (e, t) { return t || (t = be(e)), this.computeTimeTop(Ye(e.valueOf() - t.valueOf())); }, e.prototype.computeTimeTop = function (e) { let t; let n; const r = this.positions; const o = this.dateProfile; const i = this.slatMetas; const a = r.els.length; const s = i[1].date.valueOf() - i[0].date.valueOf(); let l = (e.milliseconds - $e(o.slotMinTime)) / s; return l = Math.max(0, l), l = Math.min(a, l), t = Math.floor(l), n = l - (t = Math.min(t, a - 1)), r.tops[t] + r.getHeight(t) * n; }, e; }()); const gs = [{ hours: 1 }, { minutes: 30 }, { minutes: 15 }, { seconds: 30 }, { seconds: 15 }]; const ms = (function (e) { function t() { const t = e !== null && e.apply(this, arguments) || this; return t.rootElRef = Ar(), t.slatElRefs = new Li(), t; } return n(t, e), t.prototype.render = function () { const e = this.props; const t = this.context; return Hr('div', { className: 'fc-timegrid-slots', ref: this.rootElRef }, Hr('table', { className: t.theme.getClass('table'), style: { minWidth: e.tableMinWidth, width: e.clientWidth, height: e.minHeight } }, e.tableColGroupNode, Hr(ys, { slatElRefs: this.slatElRefs, axis: e.axis, slatMetas: e.slatMetas }))); }, t.prototype.componentDidMount = function () { this.updateSizing(); }, t.prototype.componentDidUpdate = function () { this.updateSizing(); }, t.prototype.componentWillUnmount = function () { this.props.onCoords && this.props.onCoords(null); }, t.prototype.updateSizing = function () { let e; const t = this.props; t.onCoords && t.clientWidth !== null && (this.rootElRef.current.offsetHeight && t.onCoords(new vs(new Mr(this.rootElRef.current, (e = this.slatElRefs.currentMap, t.slatMetas.map(((t) => e[t.key]))), !1, !0), this.props.dateProfile, t.slatMetas))); }, t; }(jr)); var ys = (function (e) {
    function t() { return e !== null && e.apply(this, arguments) || this; } return n(t, e), t.prototype.render = function () {
      const e = this.props; const t = this.context; const n = t.options; const o = e.slatElRefs; return Hr('tbody', null, e.slatMetas.map(((i, a) => {
        const s = { time: i.time, date: t.dateEnv.toDate(i.date), view: t.viewApi }; const l = ['fc-timegrid-slot', 'fc-timegrid-slot-lane', i.isLabeled ? '' : 'fc-timegrid-slot-minor']; return Hr('tr', { key: i.key, ref: o.createRef(i.key) }, e.axis && Hr(Ss, { ...i }), Hr(uo, {
          hookProps: s, classNames: n.slotLaneClassNames, content: n.slotLaneContent, didMount: n.slotLaneDidMount, willUnmount: n.slotLaneWillUnmount,
        }, ((e, t, n, r) => Hr('td', { ref: e, className: l.concat(t).join(' '), 'data-time': i.isoTimeStr }, r))));
      })));
    }, t;
  }(jr)); const Es = St({
    hour: 'numeric', minute: '2-digit', omitZeroMinute: !0, meridiem: 'short',
  }); function Ss(e) {
    const t = ['fc-timegrid-slot', 'fc-timegrid-slot-label', e.isLabeled ? 'fc-scrollgrid-shrink' : 'fc-timegrid-slot-minor']; return Hr(zr.Consumer, null, ((n) => {
      if (e.isLabeled) {
        const r = n.dateEnv; const o = n.options; const i = n.viewApi; const a = o.slotLabelFormat == null ? Es : Array.isArray(o.slotLabelFormat) ? St(o.slotLabelFormat[0]) : St(o.slotLabelFormat); const s = {
          level: 0, time: e.time, date: r.toDate(e.date), view: i, text: r.format(e.date, a),
        }; return Hr(uo, {
          hookProps: s, classNames: o.slotLabelClassNames, content: o.slotLabelContent, defaultContent: Ds, didMount: o.slotLabelDidMount, willUnmount: o.slotLabelWillUnmount,
        }, ((n, r, o, i) => Hr('td', { ref: n, className: t.concat(r).join(' '), 'data-time': e.isoTimeStr }, Hr('div', { className: 'fc-timegrid-slot-label-frame fc-scrollgrid-shrink-frame' }, Hr('div', { className: 'fc-timegrid-slot-label-cushion fc-scrollgrid-shrink-cushion', ref: o }, i)))));
      } return Hr('td', { className: t.join(' '), 'data-time': e.isoTimeStr });
    }));
  } function Ds(e) { return e.text; } function bs(e, t, n, r, o) {
    for (var i = new Date(0), a = e, s = Ye(0), l = n || (function (e) { let t; let n; let r; for (t = gs.length - 1; t >= 0; t--) if (n = Ye(gs[t]), (r = Qe(n, e)) !== null && r > 1) return n; return e; }(r)), u = []; $e(a) < $e(t);) {
      const c = o.add(i, a); const d = Qe(s, l) !== null; u.push({
        date: c, time: a, key: c.toISOString(), isoTimeStr: nt(c), isLabeled: d,
      }), a = Xe(a, r), s = Xe(s, r);
    } return u;
  } const Cs = St({ week: 'short' }); const ws = (function (e) {
    function t() {
      const t = e !== null && e.apply(this, arguments) || this; return t.allDaySplitter = new hs(), t.headerElRef = Ar(), t.rootElRef = Ar(), t.scrollerElRef = Ar(), t.state = { slatCoords: null }, t.handleScrollTopRequest = function (e) { const n = t.scrollerElRef.current; n && (n.scrollTop = e); }, t.renderHeadAxis = function (e) { void 0 === e && (e = ''); const n = t.context.options; const o = t.props.dateProfile.renderRange; const i = ye(o.start, o.end); const a = n.navLinks && i === 1 ? { 'data-navlink': gr(o.start, 'week'), tabIndex: 0 } : {}; return n.weekNumbers ? Hr(ca, { date: o.start, defaultFormat: Cs }, ((t, n, o, i) => Hr('th', { ref: t, className: ['fc-timegrid-axis', 'fc-scrollgrid-shrink'].concat(n).join(' ') }, Hr('div', { className: 'fc-timegrid-axis-frame fc-scrollgrid-shrink-frame fc-timegrid-axis-frame-liquid', style: { height: e } }, Hr('a', { ref: o, className: 'fc-timegrid-axis-cushion fc-scrollgrid-shrink-cushion', ...a }, i))))) : Hr('th', { className: 'fc-timegrid-axis' }, Hr('div', { className: 'fc-timegrid-axis-frame', style: { height: e } })); }, t.renderTableRowAxis = function (e) {
        const n = t.context; const r = n.options; const o = n.viewApi; const i = { text: r.allDayText, view: o }; return Hr(uo, {
          hookProps: i, classNames: r.allDayClassNames, content: r.allDayContent, defaultContent: Rs, didMount: r.allDayDidMount, willUnmount: r.allDayWillUnmount,
        }, ((t, n, r, o) => Hr('td', { ref: t, className: ['fc-timegrid-axis', 'fc-scrollgrid-shrink'].concat(n).join(' ') }, Hr('div', { className: `fc-timegrid-axis-frame fc-scrollgrid-shrink-frame${e == null ? ' fc-timegrid-axis-frame-liquid' : ''}`, style: { height: e } }, Hr('span', { className: 'fc-timegrid-axis-cushion fc-scrollgrid-shrink-cushion', ref: r }, o)))));
      }, t.handleSlatCoords = function (e) { t.setState({ slatCoords: e }); }, t;
    } return n(t, e), t.prototype.renderSimpleLayout = function (e, t, n) {
      const r = this.context; const o = this.props; const i = []; const a = Ki(r.options); return e && i.push({
        type: 'header', key: 'header', isSticky: a, chunk: { elRef: this.headerElRef, tableClassName: 'fc-col-header', rowContent: e },
      }), t && (i.push({ type: 'body', key: 'all-day', chunk: { content: t } }), i.push({ type: 'body', key: 'all-day-divider', outerContent: Hr('tr', { className: 'fc-scrollgrid-section' }, Hr('td', { className: `fc-timegrid-divider ${r.theme.getClass('tableCellShaded')}` })) })), i.push({
        type: 'body', key: 'body', liquid: !0, expandRows: Boolean(r.options.expandRows), chunk: { scrollerElRef: this.scrollerElRef, content: n },
      }), Hr(yo, { viewSpec: r.viewSpec, elRef: this.rootElRef }, ((e, t) => Hr('div', { className: ['fc-timegrid'].concat(t).join(' '), ref: e }, Hr($i, { liquid: !o.isHeightAuto && !o.forPrint, cols: [{ width: 'shrink' }], sections: i }))));
    }, t.prototype.renderHScrollLayout = function (e, t, n, r, o, i, a) {
      const s = this; const l = this.context.pluginHooks.scrollGridImpl; if (!l) throw new Error('No ScrollGrid implementation'); const u = this.context; const c = this.props; const d = !c.forPrint && Ki(u.options); const p = !c.forPrint && Ji(u.options); const f = []; e && f.push({
        type: 'header',
        key: 'header',
        isSticky: d,
        syncRowHeights: !0,
        chunks: [{ key: 'axis', rowContent(e) { return Hr('tr', null, s.renderHeadAxis(e.rowSyncHeights[0])); } }, {
          key: 'cols', elRef: this.headerElRef, tableClassName: 'fc-col-header', rowContent: e,
        }],
      }), t && (f.push({
        type: 'body', key: 'all-day', syncRowHeights: !0, chunks: [{ key: 'axis', rowContent(e) { return Hr('tr', null, s.renderTableRowAxis(e.rowSyncHeights[0])); } }, { key: 'cols', content: t }],
      }), f.push({ key: 'all-day-divider', type: 'body', outerContent: Hr('tr', { className: 'fc-scrollgrid-section' }, Hr('td', { colSpan: 2, className: `fc-timegrid-divider ${u.theme.getClass('tableCellShaded')}` })) })); const h = u.options.nowIndicator; return f.push({
        type: 'body', key: 'body', liquid: !0, expandRows: Boolean(u.options.expandRows), chunks: [{ key: 'axis', content(e) { return Hr('div', { className: 'fc-timegrid-axis-chunk' }, Hr('table', { style: { height: e.expandRows ? e.clientHeight : '' } }, e.tableColGroupNode, Hr('tbody', null, Hr(Ts, { slatMetas: i }))), Hr('div', { className: 'fc-timegrid-now-indicator-container' }, Hr(Mi, { unit: h ? 'minute' : 'day' }, ((e) => { const t = h && a && a.safeComputeTop(e); return typeof t === 'number' ? Hr(na, { isAxis: !0, date: e }, ((e, n, r, o) => Hr('div', { ref: e, className: ['fc-timegrid-now-indicator-arrow'].concat(n).join(' '), style: { top: t } }, o))) : null; })))); } }, { key: 'cols', scrollerElRef: this.scrollerElRef, content: n }],
      }), p && f.push({
        key: 'footer', type: 'footer', isSticky: !0, chunks: [{ key: 'axis', content: Xi }, { key: 'cols', content: Xi }],
      }), Hr(yo, { viewSpec: u.viewSpec, elRef: this.rootElRef }, ((e, t) => Hr('div', { className: ['fc-timegrid'].concat(t).join(' '), ref: e }, Hr(l, { liquid: !c.isHeightAuto && !c.forPrint, colGroups: [{ width: 'shrink', cols: [{ width: 'shrink' }] }, { cols: [{ span: r, minWidth: o }] }], sections: f }))));
    }, t.prototype.getAllDayMaxEventProps = function () { const e = this.context.options; let t = e.dayMaxEvents; let n = e.dayMaxEventRows; return !0 !== t && !0 !== n || (t = void 0, n = 5), { dayMaxEvents: t, dayMaxEventRows: n }; }, t;
  }(oo)); function Rs(e) { return e.text; } var Ts = (function (e) { function t() { return e !== null && e.apply(this, arguments) || this; } return n(t, e), t.prototype.render = function () { return this.props.slatMetas.map(((e) => Hr('tr', { key: e.key }, Hr(Ss, { ...e })))); }, t; }(jr)); function ks(e, t) { let n; const r = []; for (n = 0; n < t; n++)r.push([]); if (e) for (n = 0; n < e.length; n++)r[e[n].col].push(e[n]); return r; } function Ms(e, t) { const n = []; if (e) { for (a = 0; a < t; a++)n[a] = { affectedInstances: e.affectedInstances, isEvent: e.isEvent, segs: [] }; for (let r = 0, o = e.segs; r < o.length; r++) { const i = o[r]; n[i.col].segs.push(i); } } else for (var a = 0; a < t; a++)n[a] = null; return n; } function xs(e, t, n, r, o) { return _s(e, t, n, r), (function (e, t) { for (let n = 0, r = e; n < r.length; n++) { (c = r[n]).level = null, c.forwardCoord = null, c.backwardCoord = null, c.forwardPressure = null; } let o; const i = (function (e) { let t; let n; let r; const o = []; for (t = 0; t < e.length; t++) { for (n = e[t], r = 0; r < o.length && Is(n, o[r]).length; r++);n.level = r, (o[r] || (o[r] = [])).push(n); } return o; }(e = hn(e, t))); if ((function (e) { let t; let n; let r; let o; let i; for (t = 0; t < e.length; t++) for (n = e[t], r = 0; r < n.length; r++) for ((o = n[r]).forwardSegs = [], i = t + 1; i < e.length; i++)Is(o, e[i], o.forwardSegs); }(i)), o = i[0]) { for (let a = 0, s = o; a < s.length; a++) { Ps(c = s[a]); } for (let l = 0, u = o; l < u.length; l++) { var c; Ns(c = u[l], 0, 0, t); } } return e; }(e, o)); } function _s(e, t, n, r) { for (let o = 0, i = e; o < i.length; o++) { const a = i[o]; a.top = n.computeDateTop(a.start, t), a.bottom = Math.max(a.top + (r || 0), n.computeDateTop(a.end, t)); } } function Is(e, t, n) { void 0 === n && (n = []); for (let r = 0; r < t.length; r++)o = e, i = t[r], o.bottom > i.top && o.top < i.bottom && n.push(t[r]); let o; let i; return n; } function Ps(e) { let t; let n; const r = e.forwardSegs; let o = 0; if (e.forwardPressure == null) { for (t = 0; t < r.length; t++)Ps(n = r[t]), o = Math.max(o, 1 + n.forwardPressure); e.forwardPressure = o; } } function Ns(e, t, n, r) { let o; const i = e.forwardSegs; if (e.forwardCoord == null) for (i.length ? (!(function (e, t) { const n = e.map(Hs); const r = [{ field: 'forwardPressure', order: -1 }, { field: 'backwardCoord', order: 1 }].concat(t); n.sort(((e, t) => ae(e, t, r))), n.map(((e) => e._seg)); }(i, r)), Ns(i[0], t + 1, n, r), e.forwardCoord = i[0].backwardCoord) : e.forwardCoord = 1, e.backwardCoord = e.forwardCoord - (e.forwardCoord - n) / (t + 1), o = 0; o < i.length; o++)Ns(i[o], 0, e.forwardCoord, r); } function Hs(e) { const t = vn(e); return t.forwardPressure = e.forwardPressure, t.backwardCoord = e.backwardCoord, t; } const Os = St({ hour: 'numeric', minute: '2-digit', meridiem: !1 }); const As = (function (e) { function t() { return e !== null && e.apply(this, arguments) || this; } return n(t, e), t.prototype.render = function () { const e = ['fc-timegrid-event', 'fc-v-event']; return this.props.isCondensed && e.push('fc-timegrid-event-condensed'), Hr(ea, { ...this.props, defaultTimeFormat: Os, extraClassNames: e }); }, t; }(jr)); di.timeGridEventCondensedHeight = 30; const Us = (function (e) {
    function t() { return e !== null && e.apply(this, arguments) || this; } return n(t, e), t.prototype.render = function () {
      const e = this; const t = this.props; const n = this.context.options.selectMirror; const o = t.eventDrag && t.eventDrag.segs || t.eventResize && t.eventResize.segs || n && t.dateSelectionSegs || []; const i = t.eventDrag && t.eventDrag.affectedInstances || t.eventResize && t.eventResize.affectedInstances || {}; return Hr(oa, {
        elRef: t.elRef, date: t.date, dateProfile: t.dateProfile, todayRange: t.todayRange, extraHookProps: t.extraHookProps,
      }, ((a, s, l) => Hr('td', {
        ref: a, className: ['fc-timegrid-col'].concat(s, t.extraClassNames || []).join(' '), ...l, ...t.extraDataAttrs,
      }, Hr('div', { className: 'fc-timegrid-col-frame' }, Hr('div', { className: 'fc-timegrid-col-bg' }, e.renderFillSegs(t.businessHourSegs, 'non-business'), e.renderFillSegs(t.bgEventSegs, 'bg-event'), e.renderFillSegs(t.dateSelectionSegs, 'highlight')), Hr('div', { className: 'fc-timegrid-col-events' }, e.renderFgSegs(t.fgEventSegs, i)), Hr('div', { className: 'fc-timegrid-col-events' }, e.renderFgSegs(o, {}, Boolean(t.eventDrag), Boolean(t.eventResize), Boolean(n))), Hr('div', { className: 'fc-timegrid-now-indicator-container' }, e.renderNowIndicator(t.nowIndicatorSegs)), Hr(Ls, {
        date: t.date, dateProfile: t.dateProfile, todayRange: t.todayRange, extraHookProps: t.extraHookProps,
      })))));
    }, t.prototype.renderFgSegs = function (e, t, n, r, o) { const i = this.props; return i.forPrint ? this.renderPrintFgSegs(e) : i.slatCoords ? this.renderPositionedFgSegs(e, t, n, r, o) : void 0; }, t.prototype.renderPrintFgSegs = function (e) {
      const t = this.props; return e.map(((e) => Hr('div', { className: 'fc-timegrid-event-harness', key: e.eventRange.instance.instanceId }, Hr(As, {
        seg: e, isDragging: !1, isResizing: !1, isDateSelecting: !1, isSelected: !1, isCondensed: !1, ...Sn(e, t.todayRange, t.nowDate),
      }))));
    }, t.prototype.renderPositionedFgSegs = function (e, t, n, o, i) {
      const a = this; const s = this.context; const l = this.props; return (e = xs(e, l.date, l.slatCoords, s.options.eventMinHeight, s.options.eventOrder)).map(((e) => {
        const s = e.eventRange.instance.instanceId; const u = n || o || i ? ({ left: 0, right: 0, ...a.computeSegTopBottomCss(e) }) : a.computeFgSegPositionCss(e); return Hr('div', { className: `fc-timegrid-event-harness${e.level > 0 ? ' fc-timegrid-event-harness-inset' : ''}`, key: s, style: { visibility: t[s] ? 'hidden' : '', ...u } }, Hr(As, {
          seg: e, isDragging: n, isResizing: o, isDateSelecting: i, isSelected: s === l.eventSelection, isCondensed: e.bottom - e.top < di.timeGridEventCondensedHeight, ...Sn(e, l.todayRange, l.nowDate),
        }));
      }));
    }, t.prototype.renderFillSegs = function (e, t) { const n = this; const o = this.context; const i = this.props; if (i.slatCoords) { _s(e, i.date, i.slatCoords, o.options.eventMinHeight); const a = e.map(((e) => Hr('div', { key: bn(e.eventRange), className: 'fc-timegrid-bg-harness', style: n.computeSegTopBottomCss(e) }, t === 'bg-event' ? Hr(la, { seg: e, ...Sn(e, i.todayRange, i.nowDate) }) : sa(t)))); return Hr(Ur, null, a); } }, t.prototype.renderNowIndicator = function (e) { const t = this.props; const n = t.slatCoords; const r = t.date; if (n) return e.map(((e, t) => Hr(na, { isAxis: !1, date: r, key: t }, ((t, o, i, a) => Hr('div', { ref: t, className: ['fc-timegrid-now-indicator-line'].concat(o).join(' '), style: { top: n.computeDateTop(e.start, r) } }, a))))); }, t.prototype.computeFgSegPositionCss = function (e) { let t; let n; const o = this.context; const i = o.isRtl; const a = o.options.slotEventOverlap; const s = e.backwardCoord; let l = e.forwardCoord; a && (l = Math.min(1, s + 2 * (l - s))), i ? (t = 1 - l, n = s) : (t = s, n = 1 - l); const u = { zIndex: e.level + 1, left: `${100 * t}%`, right: `${100 * n}%` }; return a && e.forwardPressure && (u[i ? 'marginLeft' : 'marginRight'] = 20), ({ ...u, ...this.computeSegTopBottomCss(e) }); }, t.prototype.computeSegTopBottomCss = function (e) { return { top: e.top, bottom: -e.bottom }; }, t;
  }(jr)); var Ls = (function (e) {
    function t() { return e !== null && e.apply(this, arguments) || this; } return n(t, e), t.prototype.render = function () {
      const e = this.props; return Hr(ia, {
        date: e.date, dateProfile: e.dateProfile, todayRange: e.todayRange, extraHookProps: e.extraHookProps,
      }, ((e, t) => t && Hr('div', { className: 'fc-timegrid-col-misc', ref: e }, t)));
    }, t;
  }(jr)); const Ws = (function (e) {
    function t() { const t = e !== null && e.apply(this, arguments) || this; return t.splitFgEventSegs = it(ks), t.splitBgEventSegs = it(ks), t.splitBusinessHourSegs = it(ks), t.splitNowIndicatorSegs = it(ks), t.splitDateSelectionSegs = it(ks), t.splitEventDrag = it(Ms), t.splitEventResize = it(Ms), t.rootElRef = Ar(), t.cellElRefs = new Li(), t; } return n(t, e), t.prototype.render = function () {
      const e = this; const t = this.props; const n = this.context.options.nowIndicator && t.slatCoords && t.slatCoords.safeComputeTop(t.nowDate); const r = t.cells.length; const o = this.splitFgEventSegs(t.fgEventSegs, r); const i = this.splitBgEventSegs(t.bgEventSegs, r); const a = this.splitBusinessHourSegs(t.businessHourSegs, r); const s = this.splitNowIndicatorSegs(t.nowIndicatorSegs, r); const l = this.splitDateSelectionSegs(t.dateSelectionSegs, r); const u = this.splitEventDrag(t.eventDrag, r); const c = this.splitEventResize(t.eventResize, r); return Hr('div', { className: 'fc-timegrid-cols', ref: this.rootElRef }, Hr('table', { style: { minWidth: t.tableMinWidth, width: t.clientWidth } }, t.tableColGroupNode, Hr('tbody', null, Hr('tr', null, t.axis && Hr('td', { className: 'fc-timegrid-col fc-timegrid-axis' }, Hr('div', { className: 'fc-timegrid-col-frame' }, Hr('div', { className: 'fc-timegrid-now-indicator-container' }, typeof n === 'number' && Hr(na, { isAxis: !0, date: t.nowDate }, ((e, t, r, o) => Hr('div', { ref: e, className: ['fc-timegrid-now-indicator-arrow'].concat(t).join(' '), style: { top: n } }, o)))))), t.cells.map(((n, r) => Hr(Us, {
        key: n.key, elRef: e.cellElRefs.createRef(n.key), dateProfile: t.dateProfile, date: n.date, nowDate: t.nowDate, todayRange: t.todayRange, extraHookProps: n.extraHookProps, extraDataAttrs: n.extraDataAttrs, extraClassNames: n.extraClassNames, fgEventSegs: o[r], bgEventSegs: i[r], businessHourSegs: a[r], nowIndicatorSegs: s[r], dateSelectionSegs: l[r], eventDrag: u[r], eventResize: c[r], slatCoords: t.slatCoords, eventSelection: t.eventSelection, forPrint: t.forPrint,
      })))))));
    }, t.prototype.componentDidMount = function () { this.updateCoords(); }, t.prototype.componentDidUpdate = function () { this.updateCoords(); }, t.prototype.updateCoords = function () { let e; const t = this.props; t.onColCoords && t.clientWidth !== null && t.onColCoords(new Mr(this.rootElRef.current, (e = this.cellElRefs.currentMap, t.cells.map(((t) => e[t.key]))), !0, !1)); }, t;
  }(jr)); const Vs = (function (e) {
    function t() { const t = e !== null && e.apply(this, arguments) || this; return t.processSlotOptions = it(zs), t.state = { slatCoords: null }, t.handleScrollRequest = function (e) { const n = t.props.onScrollTopRequest; const r = t.state.slatCoords; if (n && r) { if (e.time) { let o = r.computeTimeTop(e.time); (o = Math.ceil(o)) && o++, n(o); } return !0; } }, t.handleColCoords = function (e) { t.colCoords = e; }, t.handleSlatCoords = function (e) { t.setState({ slatCoords: e }), t.props.onSlatCoords && t.props.onSlatCoords(e); }, t; } return n(t, e), t.prototype.render = function () {
      const e = this.props; const t = this.state; return Hr('div', { className: 'fc-timegrid-body', ref: e.rootElRef, style: { width: e.clientWidth, minWidth: e.tableMinWidth } }, Hr(ms, {
        axis: e.axis, dateProfile: e.dateProfile, slatMetas: e.slatMetas, clientWidth: e.clientWidth, minHeight: e.expandRows ? e.clientHeight : '', tableMinWidth: e.tableMinWidth, tableColGroupNode: e.axis ? e.tableColGroupNode : null, onCoords: this.handleSlatCoords,
      }), Hr(Ws, {
        cells: e.cells, axis: e.axis, dateProfile: e.dateProfile, businessHourSegs: e.businessHourSegs, bgEventSegs: e.bgEventSegs, fgEventSegs: e.fgEventSegs, dateSelectionSegs: e.dateSelectionSegs, eventSelection: e.eventSelection, eventDrag: e.eventDrag, eventResize: e.eventResize, todayRange: e.todayRange, nowDate: e.nowDate, nowIndicatorSegs: e.nowIndicatorSegs, clientWidth: e.clientWidth, tableMinWidth: e.tableMinWidth, tableColGroupNode: e.tableColGroupNode, slatCoords: t.slatCoords, onColCoords: this.handleColCoords, forPrint: e.forPrint,
      }));
    }, t.prototype.componentDidMount = function () { this.scrollResponder = this.context.createScrollResponder(this.handleScrollRequest); }, t.prototype.componentDidUpdate = function (e) { this.scrollResponder.update(e.dateProfile !== this.props.dateProfile); }, t.prototype.componentWillUnmount = function () { this.scrollResponder.detach(); }, t.prototype.positionToHit = function (e, t) {
      const n = this.context; const r = n.dateEnv; const o = n.options; const i = this.colCoords; const a = this.props.dateProfile; const s = this.state.slatCoords; const l = this.processSlotOptions(this.props.slotDuration, o.snapDuration); const u = l.snapDuration; const c = l.snapsPerSlot; const d = i.leftToIndex(e); const p = s.positions.topToIndex(t); if (d != null && p != null) {
        const f = s.positions.tops[p]; const h = s.positions.getHeight(p); const v = (t - f) / h; const g = p * c + Math.floor(v * c); const m = this.props.cells[d].date; const y = Xe(a.slotMinTime, Ke(u, g)); const E = r.add(m, y); return {
          col: d,
          dateSpan: { range: { start: E, end: r.add(E, u) }, allDay: !1 },
          dayEl: i.els[d],
          relativeRect: {
            left: i.lefts[d], right: i.rights[d], top: f, bottom: f + h,
          },
        };
      }
    }, t;
  }(jr)); function zs(e, t) { let n = t || e; let r = Qe(e, n); return r === null && (n = e, r = 1), { snapDuration: n, snapsPerSlot: r }; } const Fs = (function (e) {
    function t() { const t = e !== null && e.apply(this, arguments) || this; return t.buildDayRanges = it(Bs), t.slicer = new js(), t.timeColsRef = Ar(), t.handleRootEl = function (e) { e ? t.context.registerInteractiveComponent(t, { el: e }) : t.context.unregisterInteractiveComponent(t); }, t; } return n(t, e), t.prototype.render = function () {
      const e = this; const t = this.props; const n = this.context; const o = t.dateProfile; const i = t.dayTableModel; const a = n.options.nowIndicator; const s = this.buildDayRanges(i, o, n.dateEnv); return Hr(Mi, { unit: a ? 'minute' : 'day' }, ((l, u) => Hr(Vs, {
        ref: e.timeColsRef, rootElRef: e.handleRootEl, ...e.slicer.sliceProps(t, o, null, n, s), forPrint: t.forPrint, axis: t.axis, dateProfile: o, slatMetas: t.slatMetas, slotDuration: t.slotDuration, cells: i.cells[0], tableColGroupNode: t.tableColGroupNode, tableMinWidth: t.tableMinWidth, clientWidth: t.clientWidth, clientHeight: t.clientHeight, expandRows: t.expandRows, nowDate: l, nowIndicatorSegs: a && e.slicer.sliceNowDate(l, n, s), todayRange: u, onScrollTopRequest: t.onScrollTopRequest, onSlatCoords: t.onSlatCoords,
      })));
    }, t.prototype.queryHit = function (e, t) {
      const n = this.timeColsRef.current.positionToHit(e, t); if (n) {
        return {
          component: this,
          dateSpan: n.dateSpan,
          dayEl: n.dayEl,
          rect: {
            left: n.relativeRect.left, right: n.relativeRect.right, top: n.relativeRect.top, bottom: n.relativeRect.bottom,
          },
          layer: 0,
        };
      }
    }, t;
  }(oo)); function Bs(e, t, n) { for (var r = [], o = 0, i = e.headerDates; o < i.length; o++) { const a = i[o]; r.push({ start: n.add(a, t.slotMinTime), end: n.add(a, t.slotMaxTime) }); } return r; } var js = (function (e) {
    function t() { return e !== null && e.apply(this, arguments) || this; } return n(t, e), t.prototype.sliceRange = function (e, t) {
      for (var n = [], r = 0; r < t.length; r++) {
        const o = nn(e, t[r]); o && n.push({
          start: o.start, end: o.end, isStart: o.start.valueOf() === e.start.valueOf(), isEnd: o.end.valueOf() === e.end.valueOf(), col: r,
        });
      } return n;
    }, t;
  }(Hi)); const Gs = (function (e) {
    function t() { const t = e !== null && e.apply(this, arguments) || this; return t.buildTimeColsModel = it(qs), t.buildSlatMetas = it(bs), t; } return n(t, e), t.prototype.render = function () {
      const e = this; const t = this.context; const n = t.options; const o = t.dateEnv; const i = t.dateProfileGenerator; const a = this.props; const s = a.dateProfile; const l = this.buildTimeColsModel(s, i); const u = this.allDaySplitter.splitProps(a); const c = this.buildSlatMetas(s.slotMinTime, s.slotMaxTime, n.slotLabelInterval, n.slotDuration, o); const d = n.dayMinWidth; const p = !d; const f = d; const h = n.dayHeaders && Hr(_i, {
        dates: l.headerDates, dateProfile: s, datesRepDistinctDays: !0, renderIntro: p ? this.renderHeadAxis : null,
      }); const v = !1 !== n.allDaySlot && function (t) {
        return Hr(us, {
          ...u.allDay, dateProfile: s, dayTableModel: l, nextDayThreshold: n.nextDayThreshold, tableMinWidth: t.tableMinWidth, colGroupNode: t.tableColGroupNode, renderRowIntro: p ? e.renderTableRowAxis : null, showWeekNumbers: !1, expandRows: !1, headerAlignElRef: e.headerElRef, clientWidth: t.clientWidth, clientHeight: t.clientHeight, forPrint: a.forPrint, ...e.getAllDayMaxEventProps(),
        });
      }; const g = function (t) {
        return Hr(Fs, {
          ...u.timed, dayTableModel: l, dateProfile: s, axis: p, slotDuration: n.slotDuration, slatMetas: c, forPrint: a.forPrint, tableColGroupNode: t.tableColGroupNode, tableMinWidth: t.tableMinWidth, clientWidth: t.clientWidth, clientHeight: t.clientHeight, onSlatCoords: e.handleSlatCoords, expandRows: t.expandRows, onScrollTopRequest: e.handleScrollTopRequest,
        });
      }; return f ? this.renderHScrollLayout(h, v, g, l.colCnt, d, c, this.state.slatCoords) : this.renderSimpleLayout(h, v, g);
    }, t;
  }(ws)); function qs(e, t) { const n = new Pi(e.renderRange, t); return new Ni(n, !1); } const Ys = io({
    initialView: 'timeGridWeek',
    optionRefiners: { allDaySlot: Boolean },
    views: {
      timeGrid: {
        component: Gs, usesMinMaxTime: !0, allDaySlot: !0, slotDuration: '00:30:00', slotEventOverlap: !0,
      },
      timeGridDay: { type: 'timeGrid', duration: { days: 1 } },
      timeGridWeek: { type: 'timeGrid', duration: { weeks: 1 } },
    },
  }); const Zs = (function (e) {
    function t() { return e !== null && e.apply(this, arguments) || this; } return n(t, e), t.prototype.render = function () {
      const e = this.props; const t = e.dayDate; const n = e.todayRange; const o = this.context; const i = o.theme; const a = o.dateEnv; const s = o.options; const l = o.viewApi; const u = hr(t, n); const c = s.listDayFormat ? a.format(t, s.listDayFormat) : ''; const d = s.listDaySideFormat ? a.format(t, s.listDaySideFormat) : ''; const p = s.navLinks ? gr(t) : null; const f = {
        date: a.toDate(t), view: l, text: c, sideText: d, navLinkData: p, ...u,
      }; const h = ['fc-list-day'].concat(vr(u, i)); return Hr(uo, {
        hookProps: f, classNames: s.dayHeaderClassNames, content: s.dayHeaderContent, defaultContent: Xs, didMount: s.dayHeaderDidMount, willUnmount: s.dayHeaderWillUnmount,
      }, ((e, n, r, o) => Hr('tr', { ref: e, className: h.concat(n).join(' '), 'data-date': tt(t) }, Hr('th', { colSpan: 3 }, Hr('div', { className: `fc-list-day-cushion ${i.getClass('tableCellShaded')}`, ref: r }, o)))));
    }, t;
  }(jr)); function Xs(e) { const t = e.navLinkData ? { 'data-navlink': e.navLinkData, tabIndex: 0 } : {}; return Hr(Ur, null, e.text && Hr('a', { className: 'fc-list-day-text', ...t }, e.text), e.sideText && Hr('a', { className: 'fc-list-day-side-text', ...t }, e.sideText)); } const Ks = St({ hour: 'numeric', minute: '2-digit', meridiem: 'short' }); const Js = (function (e) {
    function t() { return e !== null && e.apply(this, arguments) || this; } return n(t, e), t.prototype.render = function () {
      const e = this.props; const t = this.context; const n = e.seg; const r = t.options.eventTimeFormat || Ks; return Hr(Qi, {
        seg: n, timeText: '', disableDragging: !0, disableResizing: !0, defaultContent: $s, isPast: e.isPast, isFuture: e.isFuture, isToday: e.isToday, isSelected: e.isSelected, isDragging: e.isDragging, isResizing: e.isResizing, isDateSelecting: e.isDateSelecting,
      }, ((e, o, i, a, s) => Hr('tr', { className: ['fc-list-event', s.event.url ? 'fc-event-forced-url' : ''].concat(o).join(' '), ref: e }, (function (e, t, n) {
        const r = n.options; if (!1 !== r.displayEventTime) {
          const o = e.eventRange.def; const i = e.eventRange.instance; let a = !1; let s = void 0; if (o.allDay ? a = !0 : $t(e.eventRange.range) ? e.isStart ? s = En(e, t, n, null, null, i.range.start, e.end) : e.isEnd ? s = En(e, t, n, null, null, e.start, i.range.end) : a = !0 : s = En(e, t, n), a) {
            const l = { text: n.options.allDayText, view: n.viewApi }; return Hr(uo, {
              hookProps: l, classNames: r.allDayClassNames, content: r.allDayContent, defaultContent: Qs, didMount: r.allDayDidMount, willUnmount: r.allDayWillUnmount,
            }, ((e, t, n, r) => Hr('td', { className: ['fc-list-event-time'].concat(t).join(' '), ref: e }, r)));
          } return Hr('td', { className: 'fc-list-event-time' }, s);
        } return null;
      }(n, r, t)), Hr('td', { className: 'fc-list-event-graphic' }, Hr('span', { className: 'fc-list-event-dot', style: { borderColor: s.borderColor || s.backgroundColor } })), Hr('td', { className: 'fc-list-event-title', ref: i }, a))));
    }, t;
  }(jr)); function $s(e) { const t = e.event; const n = t.url; return Hr('a', { ...(n ? { href: n } : {}) }, t.title); } function Qs(e) { return e.text; } const el = (function (e) {
    function t() { const t = e !== null && e.apply(this, arguments) || this; return t.computeDateVars = it(nl), t.eventStoreToSegs = it(t._eventStoreToSegs), t.setRootEl = function (e) { e ? t.context.registerInteractiveComponent(t, { el: e }) : t.context.unregisterInteractiveComponent(t); }, t; } return n(t, e), t.prototype.render = function () { const e = this; const t = this.props; const n = this.context; const r = ['fc-list', n.theme.getClass('table'), !1 !== n.options.stickyHeaderDates ? 'fc-list-sticky' : '']; const o = this.computeDateVars(t.dateProfile); const i = o.dayDates; const a = o.dayRanges; const s = this.eventStoreToSegs(t.eventStore, t.eventUiBases, a); return Hr(yo, { viewSpec: n.viewSpec, elRef: this.setRootEl }, ((n, o) => Hr('div', { ref: n, className: r.concat(o).join(' ') }, Hr(Ui, { liquid: !t.isHeightAuto, overflowX: t.isHeightAuto ? 'visible' : 'hidden', overflowY: t.isHeightAuto ? 'visible' : 'auto' }, s.length > 0 ? e.renderSegList(s, i) : e.renderEmptyMessage())))); }, t.prototype.renderEmptyMessage = function () {
      const e = this.context; const t = e.options; const n = e.viewApi; const r = { text: t.noEventsText, view: n }; return Hr(uo, {
        hookProps: r, classNames: t.noEventsClassNames, content: t.noEventsContent, defaultContent: tl, didMount: t.noEventsDidMount, willUnmount: t.noEventsWillUnmount,
      }, ((e, t, n, r) => Hr('div', { className: ['fc-list-empty'].concat(t).join(' '), ref: e }, Hr('div', { className: 'fc-list-empty-cushion', ref: n }, r))));
    }, t.prototype.renderSegList = function (e, t) {
      const n = this.context; const o = n.theme; const i = n.options; const a = (function (e) { let t; let n; const r = []; for (t = 0; t < e.length; t++)n = e[t], (r[n.dayIndex] || (r[n.dayIndex] = [])).push(n); return r; }(e)); return Hr(Mi, { unit: 'day' }, ((e, n) => {
        for (var s = [], l = 0; l < a.length; l++) {
          let u = a[l]; if (u) {
            const c = t[l].toISOString(); s.push(Hr(Zs, { key: c, dayDate: t[l], todayRange: n })); for (let d = 0, p = u = hn(u, i.eventOrder); d < p.length; d++) {
              const f = p[d]; s.push(Hr(Js, {
                key: `${c}:${f.eventRange.instance.instanceId}`, seg: f, isDragging: !1, isResizing: !1, isDateSelecting: !1, isSelected: !1, ...Sn(f, n, e),
              }));
            }
          }
        } return Hr('table', { className: `fc-list-table ${o.getClass('table')}` }, Hr('tbody', null, s));
      }));
    }, t.prototype._eventStoreToSegs = function (e, t, n) { return this.eventRangesToSegs(ln(e, t, this.props.dateProfile.activeRange, this.context.options.nextDayThreshold).fg, n); }, t.prototype.eventRangesToSegs = function (e, t) { for (var n = [], r = 0, o = e; r < o.length; r++) { const i = o[r]; n.push.apply(n, this.eventRangeToSegs(i, t)); } return n; }, t.prototype.eventRangeToSegs = function (e, t) {
      let n; let r; let o; const i = this.context.dateEnv; const a = this.context.options.nextDayThreshold; const s = e.range; const l = e.def.allDay; const u = []; for (n = 0; n < t.length; n++) {
        if ((r = nn(s, t[n])) && (o = {
          component: this, eventRange: e, start: r.start, end: r.end, isStart: e.isStart && r.start.valueOf() === s.start.valueOf(), isEnd: e.isEnd && r.end.valueOf() === s.end.valueOf(), dayIndex: n,
        }, u.push(o), !o.isEnd && !l && n + 1 < t.length && s.end < i.add(t[n + 1].start, a))) { o.end = s.end, o.isEnd = !0; break; }
      } return u;
    }, t;
  }(oo)); function tl(e) { return e.text; } function nl(e) { for (var t = be(e.renderRange.start), n = e.renderRange.end, r = [], o = []; t < n;)r.push(t), o.push({ start: t, end: ve(t, 1) }), t = ve(t, 1); return { dayDates: r, dayRanges: o }; } function rl(e) { return !1 === e ? null : St(e); } const ol = io({
    optionRefiners: {
      listDayFormat: rl, listDaySideFormat: rl, noEventsClassNames: _t, noEventsContent: _t, noEventsDidMount: _t, noEventsWillUnmount: _t,
    },
    views: {
      list: { component: el, buttonTextKey: 'list', listDayFormat: { month: 'long', day: 'numeric', year: 'numeric' } },
      listDay: { type: 'list', duration: { days: 1 }, listDayFormat: { weekday: 'long' } },
      listWeek: {
        type: 'list', duration: { weeks: 1 }, listDayFormat: { weekday: 'long' }, listDaySideFormat: { month: 'long', day: 'numeric', year: 'numeric' },
      },
      listMonth: { type: 'list', duration: { month: 1 }, listDaySideFormat: { weekday: 'long' } },
      listYear: { type: 'list', duration: { year: 1 }, listDaySideFormat: { weekday: 'long' } },
    },
  }); const il = (function (e) { function t() { return e !== null && e.apply(this, arguments) || this; } return n(t, e), t; }(Pr)); il.prototype.classes = {
    root: 'fc-theme-bootstrap', table: 'table-bordered', tableCellShaded: 'table-active', buttonGroup: 'btn-group', button: 'btn btn-primary', buttonActive: 'active', popover: 'popover', popoverHeader: 'popover-header', popoverContent: 'popover-body',
  }, il.prototype.baseIconClass = 'fa', il.prototype.iconClasses = {
    close: 'fa-times', prev: 'fa-chevron-left', next: 'fa-chevron-right', prevYear: 'fa-angle-double-left', nextYear: 'fa-angle-double-right',
  }, il.prototype.rtlIconClasses = {
    prev: 'fa-chevron-right', next: 'fa-chevron-left', prevYear: 'fa-angle-double-right', nextYear: 'fa-angle-double-left',
  }, il.prototype.iconOverrideOption = 'bootstrapFontAwesome', il.prototype.iconOverrideCustomButtonOption = 'bootstrapFontAwesome', il.prototype.iconOverridePrefix = 'fa-'; const al = io({ themeClasses: { bootstrap: il } }); const sl = io({
    eventSourceDefs: [{
      parseMeta(e) {
        let t = e.googleCalendarId; return !t && e.url && (t = (function (e) { let t; if (/^[^/]+@([^/.]+\.)*(google|googlemail|gmail)\.com$/.test(e)) return e; if ((t = /^https:\/\/www.googleapis.com\/calendar\/v3\/calendars\/([^/]*)/.exec(e)) || (t = /^https?:\/\/www.google.com\/calendar\/feeds\/([^/]*)/.exec(e))) return decodeURIComponent(t[1]); }(e.url))), t ? {
          googleCalendarId: t, googleCalendarApiKey: e.googleCalendarApiKey, googleCalendarApiBase: e.googleCalendarApiBase, extraParams: e.extraParams,
        } : null;
      },
      fetch(e, t, n) {
        const o = e.context; const i = o.dateEnv; const a = o.options; const s = e.eventSource.meta; const l = s.googleCalendarApiKey || a.googleCalendarApiKey; if (l) {
          const u = (function (e) { let t = e.googleCalendarApiBase; t || (t = 'https://www.googleapis.com/calendar/v3/calendars'); return `${t}/${encodeURIComponent(e.googleCalendarId)}/events`; }(s)); const c = s.extraParams; const d = typeof c === 'function' ? c() : c; const p = (function (e, t, n, o) {
            let i; let a; let s; o.canComputeOffset ? (a = o.formatIso(e.start), s = o.formatIso(e.end)) : (a = ve(e.start, -1).toISOString(), s = ve(e.end, 1).toISOString()); i = {
              ...n || {}, key: t, timeMin: a, timeMax: s, singleEvents: !0, maxResults: 9999,
            }, o.timeZone !== 'local' && (i.timeZone = o.timeZone); return i;
          }(e.range, l, d, i)); Wo('GET', u, p, ((e, r) => {
            let o; let i; e.error ? n({ message: `Google Calendar API: ${e.error.message}`, errors: e.error.errors, xhr: r }) : t({
              rawEvents: (o = e.items, i = p.timeZone, o.map(((e) => (function (e, t) {
                let n = e.htmlLink || null; n && t && (n = (function (e, t) { return e.replace(/(\?.*?)?(#|$)/, ((e, n, r) => (n ? `${n}&` : '?') + t + r)); }(n, `ctz=${t}`))); return {
                  id: e.id, title: e.summary, start: e.start.dateTime || e.start.date, end: e.end.dateTime || e.end.date, url: n, location: e.location, description: e.description,
                };
              }(e, i))))),
              xhr: r,
            });
          }), ((e, t) => { n({ message: e, xhr: t }); }));
        } else n({ message: 'Specify a googleCalendarApiKey. See http://fullcalendar.io/docs/google_calendar/' });
      },
    }],
    optionRefiners: { googleCalendarApiKey: String },
    eventSourceRefiners: {
      googleCalendarApiKey: String, googleCalendarId: String, googleCalendarApiBase: String, extraParams: _t,
    },
  }); return Fo.push(Wa, fs, Ys, ol, al, sl), e.BASE_OPTION_DEFAULTS = bt, e.BASE_OPTION_REFINERS = Dt, e.BaseComponent = jr, e.BgEvent = la, e.BootstrapTheme = il, e.Calendar = pa, e.CalendarApi = Vn, e.CalendarContent = Ei, e.CalendarDataManager = Zo, e.CalendarDataProvider = oi, e.CalendarRoot = bi, e.Component = Nr, e.ContentHook = po, e.CustomContentRenderContext = co, e.DateComponent = oo, e.DateEnv = Xn, e.DateProfileGenerator = Co, e.DayCellContent = ia, e.DayCellRoot = oa, e.DayGridView = ds, e.DayHeader = _i, e.DaySeriesModel = Pi, e.DayTable = us, e.DayTableModel = Ni, e.DayTableSlicer = cs, e.DayTimeCols = Fs, e.DayTimeColsSlicer = js, e.DayTimeColsView = Gs, e.DelayedRunner = Go, e.Draggable = Aa, e.ElementDragging = ci, e.ElementScrollController = _r, e.Emitter = kr, e.EventApi = zn, e.EventRoot = Qi, e.EventSourceApi = L, e.FeaturefulElementDragging = wa, e.Fragment = Ur, e.Interaction = ai, e.ListView = el, e.MountHook = ho, e.NamedTimeZoneImpl = ii, e.NowIndicatorRoot = na, e.NowTimer = Mi, e.PointerDragging = ga, e.PositionCache = Mr, e.RefMap = Li, e.RenderHook = uo, e.ScrollController = xr, e.ScrollResponder = Vr, e.Scroller = Ui, e.SimpleScrollGrid = $i, e.Slicer = Hi, e.Splitter = pr, e.StandardEvent = ea, e.Table = as, e.TableDateCell = Ri, e.TableDowCell = Ti, e.TableView = Va, e.Theme = Pr, e.ThirdPartyDraggable = La, e.TimeCols = Vs, e.TimeColsSlatsCoords = vs, e.TimeColsView = ws, e.ViewApi = On, e.ViewContextType = zr, e.ViewRoot = yo, e.WeekNumberRoot = ca, e.WindowScrollController = Ir, e.addDays = ve, e.addDurations = Xe, e.addMs = ge, e.addWeeks = he, e.allowContextMenu = oe, e.allowSelection = ne, e.applyMutationToEventStore = Pn, e.applyStyle = j, e.applyStyleProp = G, e.asCleanDays = function (e) { return e.years || e.months || e.milliseconds ? 0 : e.days; }, e.asRoughMinutes = function (e) { return $e(e) / 6e4; }, e.asRoughMs = $e, e.asRoughSeconds = function (e) { return $e(e) / 1e3; }, e.buildClassNameNormalizer = vo, e.buildDayRanges = Bs, e.buildDayTableModel = ps, e.buildEventApis = Bn, e.buildEventRangeKey = bn, e.buildHashFromArray = function (e, t) { for (var n = {}, r = 0; r < e.length; r++) { const o = t(e[r], r); n[o[0]] = o[1]; } return n; }, e.buildNavLinkData = gr, e.buildSegCompareObj = vn, e.buildSegTimeText = En, e.buildSlatMetas = bs, e.buildTimeColsModel = qs, e.collectFromHash = Fe, e.combineEventUis = Vt, e.compareByFieldSpec = se, e.compareByFieldSpecs = ae, e.compareNumbers = ce, e.compareObjs = Ve, e.computeEdges = br, e.computeFallbackHeaderFormat = Ci, e.computeHeightAndMargins = function (e) { return e.getBoundingClientRect().height + (function (e) { const t = window.getComputedStyle(e); return parseInt(t.marginTop, 10) + parseInt(t.marginBottom, 10); }(e)); }, e.computeInnerRect = Cr, e.computeRect = wr, e.computeSegDraggable = gn, e.computeSegEndResizable = yn, e.computeSegStartResizable = mn, e.computeShrinkWidth = Wi, e.computeSmallestCellWidth = pe, e.computeVisibleDayRange = Jt, e.config = di, e.constrainPoint = sr, e.createContext = Lr, e.createDuration = Ye, e.createElement = Hr, e.createEmptyEventStore = Ht, e.createEventInstance = Ie, e.createEventUi = Wt, e.createFormatter = St, e.createPlugin = io, e.createRef = Ar, e.diffDates = Qt, e.diffDayAndTime = Ee, e.diffDays = ye, e.diffPoints = ur, e.diffWeeks = me, e.diffWholeDays = De, e.diffWholeWeeks = Se, e.disableCursor = Q, e.elementClosest = V, e.elementMatches = z, e.enableCursor = ee, e.eventTupleToStore = Pt, e.filterEventStoreDefs = At, e.filterHash = He, e.findDirectChildren = function (e, t) { for (var n = e instanceof HTMLElement ? [e] : e, r = [], o = 0; o < n.length; o++) for (let i = n[o].children, a = 0; a < i.length; a++) { const s = i[a]; t && !z(s, t) || r.push(s); } return r; }, e.findElements = F, e.flexibleCompare = le, e.flushToDom = Wr, e.formatDate = function (e, t) { void 0 === t && (t = {}); const n = tr(t); const r = St(t); const o = n.createMarkerMeta(e); return o ? n.format(o.marker, r, { forcedTzo: o.forcedTzo }) : ''; }, e.formatDayString = tt, e.formatIsoTimeString = nt, e.formatRange = function (e, t, n) {
    const r = tr(typeof n === 'object' && n ? n : {}); const o = St(n); const i = r.createMarkerMeta(e); const a = r.createMarkerMeta(t); return i && a ? r.formatRange(i.marker, a.marker, o, {
      forcedStartTzo: i.forcedTzo, forcedEndTzo: a.forcedTzo, isEndExclusive: n.isEndExclusive, defaultSeparator: bt.defaultRangeSeparator,
    }) : '';
  }, e.getAllowYScrolling = zi, e.getCanVGrowWithinCell = cr, e.getClippingParents = Rr, e.getDateMeta = hr, e.getDayClassNames = vr, e.getDefaultEventEnd = In, e.getElSeg = dn, e.getEventClassNames = Dn, e.getIsRtlScrollbarOnLeft = Er, e.getRectCenter = lr, e.getRelevantEvents = Nt, e.getScrollGridClassNames = Yi, e.getScrollbarWidths = Sr, e.getSectionClassNames = Zi, e.getSectionHasLiquidHeight = Vi, e.getSegMeta = Sn, e.getSlotClassNames = function (e, t) { const n = ['fc-slot', `fc-slot-${fe[e.dow]}`]; return e.isDisabled ? n.push('fc-slot-disabled') : (e.isToday && (n.push('fc-slot-today'), n.push(t.getClass('today'))), e.isPast && n.push('fc-slot-past'), e.isFuture && n.push('fc-slot-future')), n; }, e.getStickyFooterScrollbar = Ji, e.getStickyHeaderDates = Ki, e.getUnequalProps = We, e.globalLocales = Kn, e.globalPlugins = Fo, e.greatestDurationDenominator = et, e.guid = $, e.hasBgRendering = un, e.hasShrinkWidth = qi, e.identity = _t, e.interactionSettingsStore = ui, e.interactionSettingsToStore = li, e.intersectRanges = nn, e.intersectRects = ar, e.isArraysEqual = ot, e.isColPropsEqual = Bi, e.isDateSpansEqual = Rn, e.isInt = de, e.isInteractionValid = Jr, e.isMultiDayRange = $t, e.isPropsEqual = Le, e.isPropsValid = Qr, e.isValidDate = xe, e.listenBySelector = Z, e.mapHash = Oe, e.memoize = it, e.memoizeArraylike = function (e, t, n) { let r = []; const o = []; return function (i) { for (var a = r.length, s = i.length, l = 0; l < a; l++) if (i[l]) { if (!ot(r[l], i[l])) { n && n(o[l]); const u = e.apply(this, i[l]); t && t(u, o[l]) || (o[l] = u); } } else n && n(o[l]); for (;l < s; l++)o[l] = e.apply(this, i[l]); return r = i, o.splice(s), o; }; }, e.memoizeHashlike = function (e, t, n) { let r = {}; let o = {}; return function (i) { const a = {}; for (const s in i) if (o[s]) if (ot(r[s], i[s]))a[s] = o[s]; else { n && n(o[s]); const l = e.apply(this, i[s]); a[s] = t && t(l, o[s]) ? o[s] : l; } else a[s] = e.apply(this, i[s]); return r = i, o = a, a; }; }, e.memoizeObjArg = at, e.mergeEventStores = Ot, e.multiplyDuration = Ke, e.padStart = ue, e.parseBusinessHours = or, e.parseClassNames = Ut, e.parseDragMeta = fi, e.parseEventDef = Xt, e.parseFieldSpecs = ie, e.parseMarker = Zn, e.pointInsideRect = ir, e.preventContextMenu = re, e.preventDefault = q, e.preventSelection = te, e.rangeContainsMarker = sn, e.rangeContainsRange = an, e.rangesEqual = rn, e.rangesIntersect = on, e.refineEventDef = Yt, e.refineProps = xt, e.removeElement = W, e.removeExact = function (e, t) { for (var n = 0, r = 0; r < e.length;)e[r] === t ? (e.splice(r, 1), n++) : r++; return n; }, e.render = Or, e.renderChunkContent = Fi, e.renderFill = sa, e.renderMicroColGroup = ji, e.renderScrollShim = Xi, e.requestJson = Wo, e.sanitizeShrinkWidth = Gi, e.setElSeg = cn, e.setRef = Yr, e.sliceEventStore = ln, e.sliceEvents = function (e, t) { return ln(e.eventStore, e.eventUiBases, e.dateProfile.activeRange, t ? e.nextDayThreshold : null).fg; }, e.sortEventSegs = hn, e.startOfDay = be, e.translateRect = function (e, t, n) {
    return {
      left: e.left + t, right: e.right + t, top: e.top + n, bottom: e.bottom + n,
    };
  }, e.triggerDateSelect = xn, e.unpromisify = Tr, e.version = '<%= version %>', e.whenTransitionDone = K, e.wholeDivideDurations = Qe, e;
}({}));
